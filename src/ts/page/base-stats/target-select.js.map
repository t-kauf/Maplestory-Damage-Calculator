{
  "version": 3,
  "sources": ["target-select.ts"],
  "sourcesContent": ["/**\r\n * Pure logic layer for Target/Stage selection\r\n * Data retrieval and filtering functions without DOM dependencies\r\n */\r\nimport { stageDefenses } from '@ts/services/stage-defense.service';\r\nimport { CONTENT_TYPE, MAX_CHAPTER_NUMBER, type ContentType } from '@ts/types';\r\n\r\nexport type { ContentType };\r\n\r\n// ============================================================================\r\n// TYPE DEFINITIONS\r\n// ============================================================================\r\n\r\nexport interface StageEntry {\r\n    stage?: string;\r\n    defense: number;\r\n    accuracy?: number | string;\r\n    chapter?: string;\r\n    boss?: string;\r\n}\r\n\r\nexport interface SavedContentTypeData {\r\n    contentType: ContentType | null;\r\n    subcategory: string | null;\r\n    selectedStage: string | null;\r\n}\r\n\r\n// ============================================================================\r\n// STAGE DATA RETRIEVAL\r\n// ============================================================================\r\n\r\nexport function getStageEntries(contentType: ContentType): StageEntry[] {\r\n    switch (contentType) {\r\n        case CONTENT_TYPE.CHAPTER_BOSS:\r\n            return stageDefenses.chapterBosses;\r\n        case CONTENT_TYPE.WORLD_BOSS:\r\n            return stageDefenses.worldBosses;\r\n        case CONTENT_TYPE.STAGE_HUNT:\r\n            return stageDefenses.stageHunts;\r\n        case CONTENT_TYPE.GROWTH_DUNGEON:\r\n            return stageDefenses.growthDungeons;\r\n        default:\r\n            return [];\r\n    }\r\n}\r\n\r\nexport function filterStageHuntsByChapter(chapter: string): StageEntry[] {\r\n    return stageDefenses.stageHunts.filter(e => e.stage.startsWith(`${chapter}-`));\r\n}\r\n\r\nexport function filterGrowthDungeonsByType(dungeonType: string): StageEntry[] {\r\n    return stageDefenses.growthDungeons.filter(e => e.stage.startsWith(dungeonType));\r\n}\r\n\r\n// ============================================================================\r\n// DROPDOWN DATA GENERATION\r\n// ============================================================================\r\n\r\nexport function getSubcategoryOptions(contentType: ContentType): Array<{ value: string; label: string }> {\r\n    if (contentType === CONTENT_TYPE.STAGE_HUNT) {\r\n        const options: Array<{ value: string; label: string }> = [];\r\n        for (let ch = 1; ch <= MAX_CHAPTER_NUMBER; ch++) {\r\n            options.push({\r\n                value: `chapter-${ch}`,\r\n                label: `Chapter ${ch}`\r\n            });\r\n        }\r\n        return options;\r\n    }\r\n\r\n    if (contentType === CONTENT_TYPE.GROWTH_DUNGEON) {\r\n        const types = ['Weapon', 'EXP', 'Equipment', 'Enhancement', 'Hero Training Ground'];\r\n        return types.map(type => ({\r\n            value: type,\r\n            label: `${type} Stages`\r\n        }));\r\n    }\r\n\r\n    return [];\r\n}\r\n\r\nexport function getFilteredStageEntries(\r\n    contentType: ContentType,\r\n    filter: string\r\n): Array<{ entry: StageEntry; identifier: string; prefix: string }> {\r\n    let entries: StageEntry[] = [];\r\n    let prefix = '';\r\n\r\n    if (contentType === CONTENT_TYPE.STAGE_HUNT) {\r\n        entries = filterStageHuntsByChapter(filter);\r\n        prefix = 'stageHunt';\r\n    } else if (contentType === CONTENT_TYPE.GROWTH_DUNGEON) {\r\n        entries = filterGrowthDungeonsByType(filter);\r\n        prefix = 'growthDungeon';\r\n    } else if (contentType === CONTENT_TYPE.CHAPTER_BOSS) {\r\n        entries = getStageEntries(CONTENT_TYPE.CHAPTER_BOSS);\r\n        prefix = 'chapterBoss';\r\n    } else if (contentType === CONTENT_TYPE.WORLD_BOSS) {\r\n        entries = getStageEntries(CONTENT_TYPE.WORLD_BOSS);\r\n        prefix = 'worldBoss';\r\n    }\r\n\r\n    return entries.map(entry => ({\r\n        entry,\r\n        identifier: entry.stage || entry.chapter || entry.boss || '',\r\n        prefix\r\n    }));\r\n}\r\n\r\nexport function formatStageLabel(\r\n    entry: StageEntry,\r\n    identifier: string,\r\n    contentType: ContentType\r\n): string {\r\n    const accuracy = entry.accuracy ? `, Acc: ${entry.accuracy}` : '';\r\n    const defense = Math.floor(entry.defense * 100);\r\n\r\n    if (contentType === CONTENT_TYPE.CHAPTER_BOSS) {\r\n        return `Chapter ${identifier} (Def: ${defense}${accuracy})`;\r\n    }\r\n\r\n    if (contentType === CONTENT_TYPE.WORLD_BOSS) {\r\n        return `${identifier} (Def: ${defense}${accuracy})`;\r\n    }\r\n\r\n    return `${identifier} (Def: ${defense}${accuracy})`;\r\n}\r\n\r\n// ============================================================================\r\n// CONTENT TYPE VALIDATION\r\n// ============================================================================\r\n\r\nexport function requiresSubcategory(contentType: ContentType): boolean {\r\n    return contentType === CONTENT_TYPE.STAGE_HUNT || contentType === CONTENT_TYPE.GROWTH_DUNGEON;\r\n}\r\n\r\nexport function requiresStageSelection(contentType: ContentType): boolean {\r\n    return contentType === CONTENT_TYPE.CHAPTER_BOSS ||\r\n           contentType === CONTENT_TYPE.WORLD_BOSS ||\r\n           contentType === CONTENT_TYPE.STAGE_HUNT ||\r\n           contentType === CONTENT_TYPE.GROWTH_DUNGEON;\r\n}\r\n"],
  "mappings": "AAIA,SAAS,qBAAqB;AAC9B,SAAS,cAAc,0BAA4C;AA0B5D,SAAS,gBAAgB,aAAwC;AACpE,UAAQ,aAAa;AAAA,IACjB,KAAK,aAAa;AACd,aAAO,cAAc;AAAA,IACzB,KAAK,aAAa;AACd,aAAO,cAAc;AAAA,IACzB,KAAK,aAAa;AACd,aAAO,cAAc;AAAA,IACzB,KAAK,aAAa;AACd,aAAO,cAAc;AAAA,IACzB;AACI,aAAO,CAAC;AAAA,EAChB;AACJ;AAEO,SAAS,0BAA0B,SAA+B;AACrE,SAAO,cAAc,WAAW,OAAO,OAAK,EAAE,MAAM,WAAW,GAAG,OAAO,GAAG,CAAC;AACjF;AAEO,SAAS,2BAA2B,aAAmC;AAC1E,SAAO,cAAc,eAAe,OAAO,OAAK,EAAE,MAAM,WAAW,WAAW,CAAC;AACnF;AAMO,SAAS,sBAAsB,aAAmE;AACrG,MAAI,gBAAgB,aAAa,YAAY;AACzC,UAAM,UAAmD,CAAC;AAC1D,aAAS,KAAK,GAAG,MAAM,oBAAoB,MAAM;AAC7C,cAAQ,KAAK;AAAA,QACT,OAAO,WAAW,EAAE;AAAA,QACpB,OAAO,WAAW,EAAE;AAAA,MACxB,CAAC;AAAA,IACL;AACA,WAAO;AAAA,EACX;AAEA,MAAI,gBAAgB,aAAa,gBAAgB;AAC7C,UAAM,QAAQ,CAAC,UAAU,OAAO,aAAa,eAAe,sBAAsB;AAClF,WAAO,MAAM,IAAI,WAAS;AAAA,MACtB,OAAO;AAAA,MACP,OAAO,GAAG,IAAI;AAAA,IAClB,EAAE;AAAA,EACN;AAEA,SAAO,CAAC;AACZ;AAEO,SAAS,wBACZ,aACA,QACgE;AAChE,MAAI,UAAwB,CAAC;AAC7B,MAAI,SAAS;AAEb,MAAI,gBAAgB,aAAa,YAAY;AACzC,cAAU,0BAA0B,MAAM;AAC1C,aAAS;AAAA,EACb,WAAW,gBAAgB,aAAa,gBAAgB;AACpD,cAAU,2BAA2B,MAAM;AAC3C,aAAS;AAAA,EACb,WAAW,gBAAgB,aAAa,cAAc;AAClD,cAAU,gBAAgB,aAAa,YAAY;AACnD,aAAS;AAAA,EACb,WAAW,gBAAgB,aAAa,YAAY;AAChD,cAAU,gBAAgB,aAAa,UAAU;AACjD,aAAS;AAAA,EACb;AAEA,SAAO,QAAQ,IAAI,YAAU;AAAA,IACzB;AAAA,IACA,YAAY,MAAM,SAAS,MAAM,WAAW,MAAM,QAAQ;AAAA,IAC1D;AAAA,EACJ,EAAE;AACN;AAEO,SAAS,iBACZ,OACA,YACA,aACM;AACN,QAAM,WAAW,MAAM,WAAW,UAAU,MAAM,QAAQ,KAAK;AAC/D,QAAM,UAAU,KAAK,MAAM,MAAM,UAAU,GAAG;AAE9C,MAAI,gBAAgB,aAAa,cAAc;AAC3C,WAAO,WAAW,UAAU,UAAU,OAAO,GAAG,QAAQ;AAAA,EAC5D;AAEA,MAAI,gBAAgB,aAAa,YAAY;AACzC,WAAO,GAAG,UAAU,UAAU,OAAO,GAAG,QAAQ;AAAA,EACpD;AAEA,SAAO,GAAG,UAAU,UAAU,OAAO,GAAG,QAAQ;AACpD;AAMO,SAAS,oBAAoB,aAAmC;AACnE,SAAO,gBAAgB,aAAa,cAAc,gBAAgB,aAAa;AACnF;AAEO,SAAS,uBAAuB,aAAmC;AACtE,SAAO,gBAAgB,aAAa,gBAC7B,gBAAgB,aAAa,cAC7B,gBAAgB,aAAa,cAC7B,gBAAgB,aAAa;AACxC;",
  "names": []
}
