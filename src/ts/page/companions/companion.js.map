{
  "version": 3,
  "sources": ["companion.ts"],
  "sourcesContent": ["/**\r\n * Pure logic layer for Companion System\r\n * Helper functions for calculating companion preset DPS differences and optimizations\r\n * No DOM dependencies - all functions are pure and testable\r\n */\r\n\r\nimport { StatCalculationService } from '@ts/services/stat-calculation-service.js';\r\nimport type {\r\n    CompanionEffects,\r\n    CompanionKey,\r\n    CompanionPreset,\r\n    CompanionPresetId,\r\n    DpsComparisonResult,\r\n    BothDpsResults,\r\n    CompanionClass,\r\n    CompanionData\r\n} from '@ts/types/page/companions/companions.types';\r\nimport type { MonsterType } from '@ts/types';\r\nimport { loadoutStore } from '@ts/store/loadout.store';\r\n\r\n// ============================================================================\r\n// HELPER FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Smart routing helper to apply effects to a StatCalculationService\r\n * Intelligently routes each stat key to the correct chainable method based on stat type\r\n *\r\n * @param service - The service instance\r\n * @param effects - Effects object with stat-value pairs\r\n * @param isRemoving - If true, subtract the effects (for removing current effects)\r\n * @returns Returns the service for chaining\r\n */\r\nfunction applyEffectsToService(\r\n    service: StatCalculationService,\r\n    effects: Record<string, number>,\r\n    isRemoving: boolean = false\r\n): StatCalculationService {\r\n    if (!effects) return service;\r\n\r\n    // Stat type mappings for proper routing to chainable methods\r\n    const statTypes: Record<string, (value: number) => void> = {\r\n        // Flat attack - applies weapon attack bonus\r\n        attack: (value) => isRemoving\r\n            ? service.subtractAttack(Math.abs(value), true)\r\n            : service.addAttack(value, true),\r\n\r\n        // Flat main stat - converts to stat damage (100 main stat = 1% stat damage)\r\n        mainStat: (value) => service.addMainStat(isRemoving ? -Math.abs(value) : value),\r\n\r\n        // Main stat % with diminishing returns\r\n        statDamage: (value) => service.addMainStatPct(isRemoving ? -Math.abs(value) : value),\r\n\r\n        // Multiplicative stat (Final Damage) - for removal, we need special handling\r\n        // Since multiplicative stats can't be easily reversed, we use subtractStat for removal\r\n        finalDamage: (value) => {\r\n            if (isRemoving) {\r\n                service.subtractStat('finalDamage', value);\r\n            } else {\r\n                service.addMultiplicativeStat('finalDamage', value);\r\n            }\r\n        },\r\n\r\n        // Diminishing returns stats - for removal, use subtractStat\r\n        attackSpeed: (value) => {\r\n            if (isRemoving) {\r\n                service.subtractStat('attackSpeed', value);\r\n            } else {\r\n                service.addDiminishingReturnStat('attackSpeed', value, 150);\r\n            }\r\n        },\r\n        defPenMultiplier: (value) => {\r\n            if (isRemoving) {\r\n                service.subtractStat('defPenMultiplier', value);\r\n            } else {\r\n                service.addDiminishingReturnStat('defPenMultiplier', value, 100);\r\n            }\r\n        }\r\n    };\r\n\r\n    // Apply each effect using the appropriate method\r\n    Object.entries(effects).forEach(([statKey, value]) => {\r\n        if (value === 0 || value === undefined || value === null) return;\r\n\r\n        // Use type-specific handler if available, otherwise default to percentage stat\r\n        if (statTypes[statKey]) {\r\n            statTypes[statKey](value);\r\n        } else {\r\n            // Default: treat as additive percentage stat\r\n            const adjustedValue = isRemoving ? -Math.abs(value) : value;\r\n            service.addPercentageStat(statKey, adjustedValue);\r\n        }\r\n    });\r\n\r\n    return service;\r\n}\r\n\r\n// ============================================================================\r\n// DPS CALCULATION FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate DPS difference between two effect sets\r\n * @param currentEffects - Currently equipped effects (to be removed)\r\n * @param newEffects - New effects to apply\r\n * @param monsterType - 'boss' or 'normal'\r\n * @returns DPS comparison results\r\n */\r\nexport function calculateDpsDifference(\r\n    currentEffects: Record<string, number>,\r\n    newEffects: Record<string, number>,\r\n    monsterType: MonsterType = 'boss'\r\n): DpsComparisonResult {\r\n    // Get base stats (which already include current effects)\r\n    const baseStats = loadoutStore.getBaseStats();\r\n\r\n    // Calculate stats without current effects (clean baseline)\r\n    // Start from baseStats and remove current effects\r\n    const baselineService = new StatCalculationService(baseStats, null);\r\n    applyEffectsToService(baselineService, currentEffects, true); // true = removing\r\n    const baselineDps = baselineService.computeDPS(monsterType);\r\n\r\n    // Calculate current preset DPS (baseStats already include current effects)\r\n    const currentService = new StatCalculationService(baseStats, null);\r\n    const currentPresetDps = currentService.computeDPS(monsterType);\r\n\r\n    // Calculate stats with new effects\r\n    // Start from baseline (no effects) and add new effects\r\n    const newService = new StatCalculationService(baseStats, null);\r\n    applyEffectsToService(newService, currentEffects, true); // Remove current first\r\n    applyEffectsToService(newService, newEffects, false);    // Then add new\r\n    const newPresetDps = newService.computeDPS(monsterType);\r\n\r\n    // Calculate gains relative to baseline\r\n    const currentPresetGain = currentPresetDps - baselineDps;\r\n    const newPresetGain = newPresetDps - baselineDps;\r\n\r\n    // Calculate absolute percentage difference (in percentage points)\r\n    // This shows the direct difference between the two presets' gains over baseline\r\n    const dpsGain = baselineDps > 0 ? ((newPresetGain - currentPresetGain) / baselineDps) * 100 : 0;\r\n\r\n    return {\r\n        baselineDps,\r\n        currentPresetDps,\r\n        newPresetDps,\r\n        currentPresetGain,\r\n        newPresetGain,\r\n        dpsGain\r\n    };\r\n}\r\n\r\n/**\r\n * Calculate DPS for both boss and normal targets\r\n * @param currentEffects - Currently equipped effects\r\n * @param newEffects - New effects to apply\r\n * @returns Results for both target types\r\n */\r\nexport function calculateBothDpsDifferences(\r\n    currentEffects: Record<string, number>,\r\n    newEffects: Record<string, number>\r\n): BothDpsResults {\r\n    const bossResults = calculateDpsDifference(currentEffects, newEffects, 'boss');\r\n    const normalResults = calculateDpsDifference(currentEffects, newEffects, 'normal');\r\n\r\n    return {\r\n        boss: bossResults,\r\n        normal: normalResults\r\n    };\r\n}\r\n\r\n// ============================================================================\r\n// PRESET MANAGEMENT FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Check if a preset has at least one slot filled\r\n * @param preset - Preset object with main and subs\r\n * @returns True if at least one slot has a companion\r\n */\r\nexport function presetHasAnyCompanion(preset: CompanionPreset): boolean {\r\n    if (!preset) return false;\r\n    if (preset.main) return true;\r\n    if (preset.subs && preset.subs.some(sub => sub)) return true;\r\n    return false;\r\n}\r\n\r\n/**\r\n * Calculate the total value of a specific stat across all companions in a preset\r\n * @param preset - Preset object\r\n * @param targetStat - The stat to sum (e.g., 'bossDamage', 'normalDamage')\r\n * @param getCompanionEffects - Function to get companion effects\r\n * @param getCompanion - Function to get companion data\r\n * @returns Total value of the target stat\r\n */\r\nexport function calculatePresetStatValue(\r\n    preset: CompanionPreset,\r\n    targetStat: string,\r\n    getCompanionEffects: (className: CompanionClass, rarity: string, level: number) => CompanionEffects | null,\r\n    getCompanion: (key: CompanionKey) => CompanionData\r\n): number {\r\n    if (!preset) return 0;\r\n\r\n    let total = 0;\r\n    const allSlots: (CompanionKey | null)[] = [preset.main, ...preset.subs];\r\n\r\n    allSlots.forEach(companionKey => {\r\n        if (!companionKey) return;\r\n\r\n        const [className, rarity] = companionKey.split('-');\r\n        const companionData = getCompanion(companionKey);\r\n\r\n        if (!companionData.unlocked) return;\r\n\r\n        const level = companionData.level || 1;\r\n        const effects = getCompanionEffects(className as CompanionClass, rarity, level);\r\n\r\n        if (effects && effects.equipEffect && effects.equipEffect[targetStat]) {\r\n            total += effects.equipEffect[targetStat];\r\n        }\r\n    });\r\n\r\n    return total;\r\n}\r\n\r\n/**\r\n * Generate optimal preset for a specific target by calculating actual DPS\r\n * @param targetStat - The stat to maximize ('bossDamage' or 'normalDamage')\r\n * @param getCompanionEffects - Function to get companion effects\r\n * @param getCompanion - Function to get companion data\r\n * @param getMaxCompanionLevel - Function to get max companion level\r\n * @param lockedMainCompanion - Companion key to force as main, or null to optimize all slots\r\n * @returns Optimal preset with main and subs filled\r\n */\r\nexport function generateOptimalPreset(\r\n    targetStat: 'bossDamage' | 'normalDamage',\r\n    getCompanionEffects: (className: CompanionClass, rarity: string, level: number) => CompanionEffects | null,\r\n    getCompanion: (key: CompanionKey) => CompanionData,\r\n    getMaxCompanionLevel: () => number,\r\n    lockedMainCompanion: CompanionKey | null = null\r\n): CompanionPreset {\r\n    // Exclude classes that will never be optimal: DarkKnight, Marksman\r\n    const classes: CompanionClass[] = ['Hero', 'ArchMageIL', 'ArchMageFP', 'BowMaster', 'NightLord', 'Shadower'];\r\n    // Only consider Legendary, Unique, Epic (Normal and Rare are never optimal)\r\n    const rarities = ['Legendary', 'Unique', 'Epic'];\r\n\r\n    // Determine monster type from target stat\r\n    const monsterType: MonsterType = targetStat === 'bossDamage' ? 'boss' : 'normal';\r\n\r\n    // Collect all unlocked companions with their data\r\n    interface UnlockedCompanion {\r\n        companionKey: CompanionKey;\r\n        effects: Record<string, number>;\r\n    }\r\n\r\n    const unlockedCompanions: UnlockedCompanion[] = [];\r\n\r\n    rarities.forEach(rarity => {\r\n        classes.forEach(className => {\r\n            const companionKey: CompanionKey = `${className}-${rarity}` as CompanionKey;\r\n            const companionData = getCompanion(companionKey);\r\n\r\n            // Only consider unlocked companions\r\n            if (!companionData.unlocked) return;\r\n\r\n            const level = companionData.level || getMaxCompanionLevel();\r\n            const effects = getCompanionEffects(className, rarity, level);\r\n\r\n            if (!effects || !effects.equipEffect) return;\r\n\r\n            unlockedCompanions.push({\r\n                companionKey,\r\n                effects: effects.equipEffect\r\n            });\r\n        });\r\n    });\r\n\r\n    // If no unlocked companions, return empty preset\r\n    if (unlockedCompanions.length === 0) {\r\n        return { main: null, subs: [null, null, null, null, null, null] };\r\n    }\r\n\r\n    // Get base stats for DPS calculation\r\n    const baseStats = loadoutStore.getBaseStats();\r\n    let bestDps = 0;\r\n    let bestPreset: CompanionPreset = { main: null, subs: [null, null, null, null, null, null] };\r\n\r\n    // Helper function to generate combinations\r\n    function* generateCombinations(companions: UnlockedCompanion[], size: number, start: number = 0): Generator<UnlockedCompanion[]> {\r\n        if (size === 0) {\r\n            yield [];\r\n            return;\r\n        }\r\n        for (let i = start; i < companions.length; i++) {\r\n            for (const rest of generateCombinations(companions, size - 1, i + 1)) {\r\n                yield [companions[i], ...rest];\r\n            }\r\n        }\r\n    }\r\n\r\n    // Handle locked main companion case\r\n    if (lockedMainCompanion) {\r\n        // Validate locked main is still unlocked\r\n        const lockedMainData = unlockedCompanions.find(c => c.companionKey === lockedMainCompanion);\r\n        if (!lockedMainData) {\r\n            // Locked main is no longer valid, return empty preset\r\n            return { main: null, subs: [null, null, null, null, null, null] };\r\n        }\r\n\r\n        // Filter out the locked main from sub candidates (can't duplicate)\r\n        const subCandidates = unlockedCompanions.filter(c => c.companionKey !== lockedMainCompanion);\r\n\r\n        // For performance, limit to reasonable number of combinations\r\n        const maxCombinationsToTest = 50000;\r\n        let combinationsTested = 0;\r\n\r\n        // Reuse service instance to avoid redundant calculations\r\n        const service = new StatCalculationService(baseStats, null);\r\n\r\n        // Test each combination of 6 subs (main is locked)\r\n        for (const subCombination of generateCombinations(subCandidates, 6)) {\r\n            combinationsTested++;\r\n            if (combinationsTested > maxCombinationsToTest) {\r\n                console.warn(`Reached max combinations limit (${maxCombinationsToTest}), using best found so far`);\r\n                break;\r\n            }\r\n\r\n            // Calculate total effects for this preset\r\n            const totalEffects: Record<string, number> = {};\r\n\r\n            // Add locked main companion effects\r\n            Object.entries(lockedMainData.effects).forEach(([stat, value]) => {\r\n                totalEffects[stat] = (totalEffects[stat] || 0) + value;\r\n            });\r\n\r\n            // Add sub companion effects\r\n            subCombination.forEach(comp => {\r\n                Object.entries(comp.effects).forEach(([stat, value]) => {\r\n                    totalEffects[stat] = (totalEffects[stat] || 0) + value;\r\n                });\r\n            });\r\n\r\n            // Apply effects to base stats and calculate DPS\r\n            service.reset();\r\n            applyEffectsToService(service, totalEffects, false);\r\n            const dps = service.computeDPS(monsterType);\r\n\r\n            // Track best\r\n            if (dps > bestDps) {\r\n                bestDps = dps;\r\n                bestPreset = {\r\n                    main: lockedMainCompanion,\r\n                    subs: subCombination.map(c => c.companionKey) as [\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null\r\n                    ]\r\n                };\r\n            }\r\n        }\r\n    } else {\r\n        // No locked main - test all 7 slots\r\n        // For performance, limit to reasonable number of combinations\r\n        const maxCombinationsToTest = 50000;\r\n        let combinationsTested = 0;\r\n\r\n        // Reuse service instance to avoid redundant calculations\r\n        const service = new StatCalculationService(baseStats, null);\r\n\r\n        // Test each combination of 7 companions\r\n        for (const combination of generateCombinations(unlockedCompanions, 7)) {\r\n            combinationsTested++;\r\n            if (combinationsTested > maxCombinationsToTest) {\r\n                console.warn(`Reached max combinations limit (${maxCombinationsToTest}), using best found so far`);\r\n                break;\r\n            }\r\n\r\n            // First companion is main, rest are subs\r\n            const mainCompanion = combination[0];\r\n            const subCompanions = combination.slice(1);\r\n\r\n            // Calculate total effects for this preset\r\n            const totalEffects: Record<string, number> = {};\r\n\r\n            // Add main companion effects\r\n            Object.entries(mainCompanion.effects).forEach(([stat, value]) => {\r\n                totalEffects[stat] = (totalEffects[stat] || 0) + value;\r\n            });\r\n\r\n            // Add sub companion effects\r\n            subCompanions.forEach(comp => {\r\n                Object.entries(comp.effects).forEach(([stat, value]) => {\r\n                    totalEffects[stat] = (totalEffects[stat] || 0) + value;\r\n                });\r\n            });\r\n\r\n            // Apply effects to base stats and calculate DPS\r\n            service.reset();\r\n            applyEffectsToService(service, totalEffects, false);\r\n            const dps = service.computeDPS(monsterType);\r\n\r\n            // Track best\r\n            if (dps > bestDps) {\r\n                bestDps = dps;\r\n                bestPreset = {\r\n                    main: mainCompanion.companionKey,\r\n                    subs: subCompanions.map(c => c.companionKey) as [\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null\r\n                    ]\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    return bestPreset;\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
