{
  "version": 3,
  "sources": ["companion.ts"],
  "sourcesContent": ["/**\r\n * Pure logic layer for Companion System\r\n * Helper functions for calculating companion preset DPS differences and optimizations\r\n * No DOM dependencies - all functions are pure and testable\r\n */\r\n\r\nimport { StatCalculationService } from '@ts/services/stat-calculation-service.js';\r\nimport type {\r\n    CompanionEffects,\r\n    CompanionKey,\r\n    CompanionPreset,\r\n    CompanionPresetId,\r\n    DpsComparisonResult,\r\n    BothDpsResults,\r\n    CompanionClass,\r\n    CompanionData\r\n} from '@ts/types/page/companions/companions.types';\r\nimport { COMPANION_STAT_KEY_TO_STAT_ID } from '@ts/types/page/companions/companions.types';\r\nimport type { MonsterType, BaseStats } from '@ts/types';\r\nimport { loadoutStore } from '@ts/store/loadout.store';\r\n\r\n// ============================================================================\r\n// HELPER FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Smart routing helper to apply effects to a StatCalculationService\r\n * Intelligently routes each stat key to the correct chainable method based on stat type\r\n *\r\n * @param service - The service instance\r\n * @param effects - Effects object with stat-value pairs\r\n * @param isRemoving - If true, subtract the effects (for removing current effects)\r\n * @returns Returns the service for chaining\r\n */\r\nfunction applyEffectsToService(\r\n    service: StatCalculationService,\r\n    effects: Record<string, number>,\r\n    isRemoving: boolean = false\r\n): StatCalculationService {\r\n    if (!effects) return service;\r\n\r\n    // Stat type mappings for proper routing to chainable methods\r\n    const statTypes: Record<string, (value: number) => void> = {\r\n        // Flat attack - applies weapon attack bonus\r\n        attack: (value) => isRemoving\r\n            ? service.subtract('attack', Math.abs(value))\r\n            : service.add('attack', value),\r\n\r\n        // Flat main stat - converts to stat damage (100 main stat = 1% stat damage)\r\n        mainStat: (value) => service.add('mainStat', isRemoving ? -Math.abs(value) : value),\r\n\r\n        // Main stat % with diminishing returns\r\n        statDamage: (value) => service.add('mainStatPct', isRemoving ? -Math.abs(value) : value),\r\n\r\n        // Multiplicative stat (Final Damage) - for removal, we use subtract\r\n        finalDamage: (value) => {\r\n            if (isRemoving) {\r\n                service.subtract('finalDamage', value);\r\n            } else {\r\n                service.add('finalDamage', value);\r\n            }\r\n        },\r\n\r\n        // Diminishing returns stats - for removal, use subtract\r\n        attackSpeed: (value) => {\r\n            if (isRemoving) {\r\n                service.subtract('attackSpeed', value);\r\n            } else {\r\n                service.add('attackSpeed', value);\r\n            }\r\n        },\r\n        defPenMultiplier: (value) => {\r\n            if (isRemoving) {\r\n                service.subtract('defPenMultiplier', value);\r\n            } else {\r\n                service.add('defPenMultiplier', value);\r\n            }\r\n        }\r\n    };\r\n\r\n    // Apply each effect using the appropriate method\r\n    Object.entries(effects).forEach(([statKey, value]) => {\r\n        if (value === 0 || value === undefined || value === null) return;\r\n\r\n        // Use type-specific handler if available, otherwise default to percentage stat\r\n        if (statTypes[statKey]) {\r\n            statTypes[statKey](value);\r\n        } else {\r\n            // Default: treat as additive percentage stat\r\n            const adjustedValue = isRemoving ? -Math.abs(value) : value;\r\n            service.add(statKey, adjustedValue);\r\n        }\r\n    });\r\n\r\n    return service;\r\n}\r\n\r\n// ============================================================================\r\n// DPS CALCULATION FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate DPS difference between two effect sets\r\n * @param currentEffects - Currently equipped effects (to be removed)\r\n * @param newEffects - New effects to apply\r\n * @param monsterType - 'boss' or 'normal'\r\n * @returns DPS comparison results\r\n */\r\nexport function calculateDpsDifference(\r\n    currentEffects: Record<string, number>,\r\n    newEffects: Record<string, number>,\r\n    monsterType: MonsterType = 'boss'\r\n): DpsComparisonResult {\r\n    // Get base stats (which already include current effects)\r\n    const baseStats = loadoutStore.getBaseStats();\r\n\r\n    // Calculate stats without current effects (clean baseline)\r\n    // Start from baseStats and remove current effects\r\n    const baselineService = new StatCalculationService(baseStats, null);\r\n    applyEffectsToService(baselineService, currentEffects, true); // true = removing\r\n    const baselineDps = baselineService.computeDPS(monsterType);\r\n\r\n    // Calculate current preset DPS (baseStats already include current effects)\r\n    const currentService = new StatCalculationService(baseStats, null);\r\n    const currentPresetDps = currentService.computeDPS(monsterType);\r\n\r\n    // Calculate stats with new effects\r\n    // Start from baseline (no effects) and add new effects\r\n    const newService = new StatCalculationService(baseStats, null);\r\n    applyEffectsToService(newService, currentEffects, true); // Remove current first\r\n    applyEffectsToService(newService, newEffects, false);    // Then add new\r\n    const newPresetDps = newService.computeDPS(monsterType);\r\n\r\n    // Calculate gains relative to baseline\r\n    const currentPresetGain = currentPresetDps - baselineDps;\r\n    const newPresetGain = newPresetDps - baselineDps;\r\n\r\n    // Calculate absolute percentage difference (in percentage points)\r\n    // This shows the direct difference between the two presets' gains over baseline\r\n    const dpsGain = baselineDps > 0 ? ((newPresetGain - currentPresetGain) / baselineDps) * 100 : 0;\r\n\r\n    return {\r\n        baselineDps,\r\n        currentPresetDps,\r\n        newPresetDps,\r\n        currentPresetGain,\r\n        newPresetGain,\r\n        dpsGain\r\n    };\r\n}\r\n\r\n/**\r\n * Calculate DPS for both boss and normal targets\r\n * @param currentEffects - Currently equipped effects\r\n * @param newEffects - New effects to apply\r\n * @returns Results for both target types\r\n */\r\nexport function calculateBothDpsDifferences(\r\n    currentEffects: Record<string, number>,\r\n    newEffects: Record<string, number>\r\n): BothDpsResults {\r\n    const bossResults = calculateDpsDifference(currentEffects, newEffects, 'boss');\r\n    const normalResults = calculateDpsDifference(currentEffects, newEffects, 'normal');\r\n\r\n    return {\r\n        boss: bossResults,\r\n        normal: normalResults\r\n    };\r\n}\r\n\r\n// ============================================================================\r\n// PRESET MANAGEMENT FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Check if a preset has at least one slot filled\r\n * @param preset - Preset object with main and subs\r\n * @returns True if at least one slot has a companion\r\n */\r\nexport function presetHasAnyCompanion(preset: CompanionPreset): boolean {\r\n    if (!preset) return false;\r\n    if (preset.main) return true;\r\n    if (preset.subs && preset.subs.some(sub => sub)) return true;\r\n    return false;\r\n}\r\n\r\n/**\r\n * Calculate the total value of a specific stat across all companions in a preset\r\n * @param preset - Preset object\r\n * @param targetStat - The stat to sum (e.g., 'bossDamage', 'normalDamage')\r\n * @param getCompanionEffects - Function to get companion effects\r\n * @param getCompanion - Function to get companion data\r\n * @returns Total value of the target stat\r\n */\r\nexport function calculatePresetStatValue(\r\n    preset: CompanionPreset,\r\n    targetStat: string,\r\n    getCompanionEffects: (className: CompanionClass, rarity: string, level: number) => CompanionEffects | null,\r\n    getCompanion: (key: CompanionKey) => CompanionData\r\n): number {\r\n    if (!preset) return 0;\r\n\r\n    let total = 0;\r\n    const allSlots: (CompanionKey | null)[] = [preset.main, ...preset.subs];\r\n\r\n    allSlots.forEach(companionKey => {\r\n        if (!companionKey) return;\r\n\r\n        const [className, rarity] = companionKey.split('-');\r\n        const companionData = getCompanion(companionKey);\r\n\r\n        if (!companionData.unlocked) return;\r\n\r\n        const level = companionData.level || 1;\r\n        const effects = getCompanionEffects(className as CompanionClass, rarity, level);\r\n\r\n        if (effects && effects.equipEffect && effects.equipEffect[targetStat]) {\r\n            total += effects.equipEffect[targetStat];\r\n        }\r\n    });\r\n\r\n    return total;\r\n}\r\n\r\n/**\r\n * Generate optimal preset for a specific target using optimized 3-phase algorithm\r\n * @param targetStat - The stat to maximize ('bossDamage' or 'normalDamage')\r\n * @param getCompanionEffects - Function to get companion effects\r\n * @param getCompanion - Function to get companion data\r\n * @param getMaxCompanionLevel - Function to get max companion level\r\n * @param lockedMainCompanion - Companion key to force as main, or null to optimize all slots\r\n * @returns Optimal preset with main and subs filled\r\n */\r\nexport function generateOptimalPreset(\r\n    targetStat: 'bossDamage' | 'normalDamage',\r\n    getCompanionEffects: (className: CompanionClass, rarity: string, level: number) => CompanionEffects | null,\r\n    getCompanion: (key: CompanionKey) => CompanionData,\r\n    getMaxCompanionLevel: () => number,\r\n    lockedMainCompanion: CompanionKey | null = null\r\n): CompanionPreset {\r\n    // Exclude classes that will never be optimal: DarkKnight, Marksman\r\n    const classes: CompanionClass[] = ['Hero', 'ArchMageIL', 'ArchMageFP', 'BowMaster', 'NightLord', 'Shadower'];\r\n    // Only consider Legendary, Unique, Epic (Normal and Rare are never optimal)\r\n    const rarities = ['Legendary', 'Unique', 'Epic'];\r\n\r\n    // Determine monster type from target stat\r\n    const monsterType: MonsterType = targetStat === 'bossDamage' ? 'boss' : 'normal';\r\n\r\n    // Collect all unlocked companions with their data\r\n    interface UnlockedCompanion {\r\n        companionKey: CompanionKey;\r\n        effects: Record<string, number>;\r\n    }\r\n\r\n    const unlockedCompanions: UnlockedCompanion[] = [];\r\n\r\n    rarities.forEach(rarity => {\r\n        classes.forEach(className => {\r\n            const companionKey: CompanionKey = `${className}-${rarity}` as CompanionKey;\r\n            const companionData = getCompanion(companionKey);\r\n\r\n            // Only consider unlocked companions\r\n            if (!companionData.unlocked) return;\r\n\r\n            const level = companionData.level || getMaxCompanionLevel();\r\n            const effects = getCompanionEffects(className, rarity, level);\r\n\r\n            if (!effects || !effects.equipEffect) return;\r\n\r\n            unlockedCompanions.push({\r\n                companionKey,\r\n                effects: effects.equipEffect\r\n            });\r\n        });\r\n    });\r\n\r\n    // If no unlocked companions, return empty preset\r\n    if (unlockedCompanions.length === 0) {\r\n        return { main: null, subs: [null, null, null, null, null, null] };\r\n    }\r\n\r\n    // Handle locked main companion case\r\n    let lockedMain: UnlockedCompanion | null = null;\r\n    if (lockedMainCompanion) {\r\n        const lockedMainData = unlockedCompanions.find(c => c.companionKey === lockedMainCompanion);\r\n        if (!lockedMainData) {\r\n            // Locked main is no longer valid, return empty preset\r\n            console.warn(`[generateOptimalPreset] Locked main companion ${lockedMainCompanion} not found or not unlocked`);\r\n            return { main: null, subs: [null, null, null, null, null, null] };\r\n        }\r\n        lockedMain = lockedMainData;\r\n        // Remove locked main from candidates (can't duplicate)\r\n        const lockedIndex = unlockedCompanions.indexOf(lockedMainData);\r\n        unlockedCompanions.splice(lockedIndex, 1);\r\n    }\r\n\r\n    // Check if we have enough companions to fill all slots\r\n    const minRequired = lockedMain ? 6 : 7;\r\n    if (unlockedCompanions.length < minRequired) {\r\n        console.warn(`[generateOptimalPreset] Only ${unlockedCompanions.length} companions available, filling all available slots`);\r\n        const allKeys = unlockedCompanions.map(c => c.companionKey);\r\n        if (lockedMain) {\r\n            return {\r\n                main: lockedMain.companionKey,\r\n                subs: [\r\n                    allKeys[0] || null,\r\n                    allKeys[1] || null,\r\n                    allKeys[2] || null,\r\n                    allKeys[3] || null,\r\n                    allKeys[4] || null,\r\n                    allKeys[5] || null\r\n                ]\r\n            };\r\n        } else {\r\n            return {\r\n                main: allKeys[0] || null,\r\n                subs: [\r\n                    allKeys[1] || null,\r\n                    allKeys[2] || null,\r\n                    allKeys[3] || null,\r\n                    allKeys[4] || null,\r\n                    allKeys[5] || null,\r\n                    allKeys[6] || null\r\n                ]\r\n            };\r\n        }\r\n    }\r\n\r\n    // Get base stats for DPS calculation\r\n    const baseStats = loadoutStore.getBaseStats();\r\n    const baselineService = new StatCalculationService(baseStats, null);\r\n    const baselineDps = baselineService.computeDPS(monsterType);\r\n\r\n    // Helper function to generate combinations\r\n    function* generateCombinations(companions: UnlockedCompanion[], size: number, start: number = 0): Generator<UnlockedCompanion[]> {\r\n        if (size === 0) {\r\n            yield [];\r\n            return;\r\n        }\r\n        for (let i = start; i < companions.length; i++) {\r\n            for (const rest of generateCombinations(companions, size - 1, i + 1)) {\r\n                yield [companions[i], ...rest];\r\n            }\r\n        }\r\n    }\r\n\r\n    // =========================================================================\r\n    // PHASE 1: Individual companion scoring\r\n    // =========================================================================\r\n\r\n    interface ScoredCompanion {\r\n        companion: UnlockedCompanion;\r\n        individualDps: number;\r\n        dpsGain: number;\r\n    }\r\n\r\n    const scoredCompanions: ScoredCompanion[] = unlockedCompanions.map(comp => {\r\n        const service = new StatCalculationService(baseStats, null);\r\n        applyEffectsToService(service, comp.effects, false);\r\n        const dps = service.computeDPS(monsterType);\r\n        const gain = dps - baselineDps;\r\n\r\n        return {\r\n            companion: comp,\r\n            individualDps: dps,\r\n            dpsGain: gain\r\n        };\r\n    });\r\n\r\n    // Sort by individual DPS contribution\r\n    scoredCompanions.sort((a, b) => b.dpsGain - a.dpsGain);\r\n\r\n    // =========================================================================\r\n    // PHASE 2: Smart locking based on marginal gains\r\n    // =========================================================================\r\n\r\n    const locked: ScoredCompanion[] = [];\r\n    const pool = [...scoredCompanions];\r\n\r\n    // Lock top performers with adaptive threshold\r\n    let prevGain = Infinity;\r\n    const MIN_LOCKED = 2; // Lock at least 2 clear winners\r\n    const MAX_LOCKED = 4; // Lock at most 4 (leave room for optimization)\r\n    const MARGINAL_GAIN_THRESHOLD = 0.6; // Lock if > 60% of previous companion's value\r\n    const MIN_GAIN_PERCENT = 0.008; // Must provide at least 0.8% gain to be locked\r\n\r\n    for (let i = 0; i < scoredCompanions.length && locked.length < MAX_LOCKED; i++) {\r\n        const score = scoredCompanions[i];\r\n        const gainPercent = score.dpsGain / baselineDps;\r\n\r\n        const shouldLock =\r\n            locked.length < MIN_LOCKED || // Always lock at least 2\r\n            score.dpsGain > prevGain * MARGINAL_GAIN_THRESHOLD || // High marginal value\r\n            gainPercent > MIN_GAIN_PERCENT; // Above minimum threshold\r\n\r\n        if (shouldLock) {\r\n            locked.push(score);\r\n            pool.splice(pool.indexOf(score), 1);\r\n            prevGain = score.dpsGain;\r\n        }\r\n    }\r\n\r\n    // Track selected companion keys to prevent duplicates\r\n    const selectedKeys = new Set<CompanionKey>();\r\n    if (lockedMain) {\r\n        selectedKeys.add(lockedMain.companionKey);\r\n    }\r\n    locked.forEach(s => selectedKeys.add(s.companion.companionKey));\r\n\r\n    // =========================================================================\r\n    // PHASE 3: Restricted combination testing\r\n    // =========================================================================\r\n\r\n    // Take top 12-15 from pool for final permutation\r\n    const POOL_SIZE = Math.min(15, unlockedCompanions.length);\r\n    const candidates = locked.concat(pool.slice(0, Math.min(POOL_SIZE - locked.length, pool.length)));\r\n\r\n    // Need to select 7 total (or 6 if main is locked)\r\n    const totalSlots = lockedMain ? 6 : 7;\r\n    const numToSelect = totalSlots - locked.length;\r\n\r\n    // CRITICAL: Filter out companions already selected (by key comparison) to prevent duplicates\r\n    const remaining: UnlockedCompanion[] = candidates\r\n        .slice(locked.length)\r\n        .map(s => s.companion)\r\n        .filter(comp => !selectedKeys.has(comp.companionKey));\r\n\r\n    let bestDps = 0;\r\n    let bestPreset: CompanionPreset = { main: null, subs: [null, null, null, null, null, null] };\r\n\r\n    const service = new StatCalculationService(baseStats, null);\r\n    let combinationsTested = 0;\r\n    const maxCombinations = 15000; // Reasonable limit for Phase 3\r\n\r\n    // Helper to calculate DPS for a combination\r\n    const calculateDpsForCombination = (companions: UnlockedCompanion[]): number => {\r\n        const totalEffects: Record<string, number> = {};\r\n\r\n        companions.forEach(comp => {\r\n            Object.entries(comp.effects).forEach(([stat, value]) => {\r\n                totalEffects[stat] = (totalEffects[stat] || 0) + value;\r\n            });\r\n        });\r\n\r\n        service.reset();\r\n        applyEffectsToService(service, totalEffects, false);\r\n        return service.computeDPS(monsterType);\r\n    };\r\n\r\n    // Generate combinations of remaining slots\r\n    for (const combination of generateCombinations(remaining, numToSelect)) {\r\n        combinationsTested++;\r\n        if (combinationsTested > maxCombinations) {\r\n            console.warn(`[Phase 3] Reached max combinations limit (${maxCombinations}), using best found so far`);\r\n            break;\r\n        }\r\n\r\n        // Combine locked + new combination\r\n        let fullSelection: UnlockedCompanion[];\r\n        if (lockedMain) {\r\n            // Include locked main + locked from Phase 2 + new combination\r\n            fullSelection = [lockedMain, ...locked.map(s => s.companion), ...combination];\r\n        } else {\r\n            fullSelection = locked.map(s => s.companion).concat(combination);\r\n        }\r\n\r\n        // Calculate DPS\r\n        const dps = calculateDpsForCombination(fullSelection);\r\n\r\n        if (dps > bestDps) {\r\n            bestDps = dps;\r\n\r\n            // If main is locked, it should be the main slot\r\n            if (lockedMain) {\r\n                // fullSelection = [lockedMain, ...6 subs]\r\n                // Skip first element (locked main) when creating subs array\r\n                bestPreset = {\r\n                    main: lockedMain.companionKey,\r\n                    subs: fullSelection.slice(1).map(c => c.companionKey) as [\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null\r\n                    ]\r\n                };\r\n            } else {\r\n                // First companion is main, rest are subs\r\n                bestPreset = {\r\n                    main: fullSelection[0].companionKey,\r\n                    subs: fullSelection.slice(1).map(c => c.companionKey) as [\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null,\r\n                        CompanionKey | null\r\n                    ]\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    const totalGainPercent = ((bestDps - baselineDps) / baselineDps * 100);\r\n\r\n    return bestPreset;\r\n}\r\n\r\n// ============================================================================\r\n// PRESET SWAP HELPER\r\n// ============================================================================\r\n\r\n/**\r\n * Swap companion preset effects using StatCalculationService\r\n *\r\n * This function calculates new base stats by removing current companion effects\r\n * and adding new companion effects, using the proper StatCalculationService methods\r\n * to handle stat-specific logic (weapon bonuses, diminishing returns, etc.)\r\n *\r\n * @param currentEffects - Currently equipped companion effects (to remove)\r\n * @param newEffects - New preset effects (to add)\r\n * @returns New base stats object to persist via loadoutStore.updateBaseStats()\r\n *\r\n * @example\r\n * // When switching presets with user confirmation that stats are incorporated\r\n * const newStats = swapCompanionPresetEffects(currentPresetEffects, newPresetEffects);\r\n * loadoutStore.updateBaseStats(newStats);\r\n */\r\nexport function swapCompanionPresetEffects(\r\n    currentEffects: Record<string, number>,\r\n    newEffects: Record<string, number>\r\n): BaseStats {\r\n    // 1. Get current base stats from loadoutStore\r\n    const baseStats = loadoutStore.getBaseStats();\r\n\r\n    // 2. Create StatCalculationService instance with fresh stats\r\n    const service = new StatCalculationService(baseStats, null);\r\n\r\n    // 3. Subtract current effects\r\n    Object.entries(currentEffects).forEach(([statKey, value]) => {\r\n        if (value === 0 || value === undefined || value === null) return;\r\n\r\n        const mappedId = COMPANION_STAT_KEY_TO_STAT_ID[statKey];\r\n        if (!mappedId) {\r\n            console.warn(`[swapCompanionPresetEffects] Unknown companion stat key: ${statKey}, skipping removal`);\r\n            return;\r\n        }\r\n\r\n        service.subtract(mappedId, value);\r\n    });\r\n\r\n    // 4. Add new effects\r\n    Object.entries(newEffects).forEach(([statKey, value]) => {\r\n        if (value === 0 || value === undefined || value === null) return;\r\n\r\n        const mappedId = COMPANION_STAT_KEY_TO_STAT_ID[statKey];\r\n        if (!mappedId) {\r\n            console.warn(`[swapCompanionPresetEffects] Unknown companion stat key: ${statKey}, skipping addition`);\r\n            return;\r\n        }\r\n\r\n        service.add(mappedId, value);\r\n    });\r\n\r\n    // 5. Return the modified stats\r\n    return service.getStats();\r\n}\r\n"],
  "mappings": "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",
  "names": ["service"]
}
