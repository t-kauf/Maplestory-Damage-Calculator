{
  "version": 3,
  "sources": ["companion.ts"],
  "sourcesContent": ["/**\n * Pure logic layer for Companion System\n * Helper functions for calculating companion preset DPS differences and optimizations\n * No DOM dependencies - all functions are pure and testable\n */\n\nimport { StatCalculationService } from '@ts/services/stat-calculation-service.js';\nimport type {\n    CompanionEffects,\n    CompanionKey,\n    CompanionPreset,\n    CompanionPresetId,\n    DpsComparisonResult,\n    BothDpsResults,\n    CompanionClass,\n    CompanionData\n} from '@ts/types/page/companions/companions.types';\nimport { COMPANION_STAT_KEY_TO_STAT_ID } from '@ts/types/page/companions/companions.types';\nimport type { MonsterType, BaseStats } from '@ts/types';\nimport { loadoutStore } from '@ts/store/loadout.store';\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Smart routing helper to apply effects to a StatCalculationService\n * Intelligently routes each stat key to the correct chainable method based on stat type\n *\n * @param service - The service instance\n * @param effects - Effects object with stat-value pairs\n * @param isRemoving - If true, subtract the effects (for removing current effects)\n * @returns Returns the service for chaining\n */\nfunction applyEffectsToService(\n    service: StatCalculationService,\n    effects: Record<string, number>,\n    isRemoving: boolean = false\n): StatCalculationService {\n    if (!effects) return service;\n\n    // Stat type mappings for proper routing to chainable methods\n    const statTypes: Record<string, (value: number) => void> = {\n        // Flat attack - applies weapon attack bonus\n        attack: (value) => isRemoving\n            ? service.subtract('attack', Math.abs(value))\n            : service.add('attack', value),\n\n        // Flat main stat - converts to stat damage (100 main stat = 1% stat damage)\n        mainStat: (value) => service.add('mainStat', isRemoving ? -Math.abs(value) : value),\n\n        // Main stat % with diminishing returns\n        statDamage: (value) => service.add('mainStatPct', isRemoving ? -Math.abs(value) : value),\n\n        // Multiplicative stat (Final Damage) - for removal, we use subtract\n        finalDamage: (value) => {\n            if (isRemoving) {\n                service.subtract('finalDamage', value);\n            } else {\n                service.add('finalDamage', value);\n            }\n        },\n\n        // Diminishing returns stats - for removal, use subtract\n        attackSpeed: (value) => {\n            if (isRemoving) {\n                service.subtract('attackSpeed', value);\n            } else {\n                service.add('attackSpeed', value);\n            }\n        },\n        defPenMultiplier: (value) => {\n            if (isRemoving) {\n                service.subtract('defPenMultiplier', value);\n            } else {\n                service.add('defPenMultiplier', value);\n            }\n        }\n    };\n\n    // Apply each effect using the appropriate method\n    Object.entries(effects).forEach(([statKey, value]) => {\n        if (value === 0 || value === undefined || value === null) return;\n\n        // Use type-specific handler if available, otherwise default to percentage stat\n        if (statTypes[statKey]) {\n            statTypes[statKey](value);\n        } else {\n            // Default: treat as additive percentage stat\n            const adjustedValue = isRemoving ? -Math.abs(value) : value;\n            service.add(statKey, adjustedValue);\n        }\n    });\n\n    return service;\n}\n\n// ============================================================================\n// DPS CALCULATION FUNCTIONS\n// ============================================================================\n\n/**\n * Calculate DPS difference between two effect sets\n * @param currentEffects - Currently equipped effects (to be removed)\n * @param newEffects - New effects to apply\n * @param monsterType - 'boss' or 'normal'\n * @returns DPS comparison results\n */\nexport function calculateDpsDifference(\n    currentEffects: Record<string, number>,\n    newEffects: Record<string, number>,\n    monsterType: MonsterType = 'boss'\n): DpsComparisonResult {\n    // Get base stats (which already include current effects)\n    const baseStats = loadoutStore.getBaseStats();\n\n    // Calculate stats without current effects (clean baseline)\n    // Start from baseStats and remove current effects\n    const baselineService = new StatCalculationService(baseStats, null);\n    applyEffectsToService(baselineService, currentEffects, true); // true = removing\n    const baselineDps = baselineService.computeDPS(monsterType);\n\n    // Calculate current preset DPS (baseStats already include current effects)\n    const currentService = new StatCalculationService(baseStats, null);\n    const currentPresetDps = currentService.computeDPS(monsterType);\n\n    // Calculate stats with new effects\n    // Start from baseline (no effects) and add new effects\n    const newService = new StatCalculationService(baseStats, null);\n    applyEffectsToService(newService, currentEffects, true); // Remove current first\n    applyEffectsToService(newService, newEffects, false);    // Then add new\n    const newPresetDps = newService.computeDPS(monsterType);\n\n    // Calculate gains relative to baseline\n    const currentPresetGain = currentPresetDps - baselineDps;\n    const newPresetGain = newPresetDps - baselineDps;\n\n    // Calculate absolute percentage difference (in percentage points)\n    // This shows the direct difference between the two presets' gains over baseline\n    const dpsGain = baselineDps > 0 ? ((newPresetGain - currentPresetGain) / baselineDps) * 100 : 0;\n\n    return {\n        baselineDps,\n        currentPresetDps,\n        newPresetDps,\n        currentPresetGain,\n        newPresetGain,\n        dpsGain\n    };\n}\n\n/**\n * Calculate DPS for both boss and normal targets\n * @param currentEffects - Currently equipped effects\n * @param newEffects - New effects to apply\n * @returns Results for both target types\n */\nexport function calculateBothDpsDifferences(\n    currentEffects: Record<string, number>,\n    newEffects: Record<string, number>\n): BothDpsResults {\n    const bossResults = calculateDpsDifference(currentEffects, newEffects, 'boss');\n    const normalResults = calculateDpsDifference(currentEffects, newEffects, 'normal');\n\n    return {\n        boss: bossResults,\n        normal: normalResults\n    };\n}\n\n// ============================================================================\n// PRESET MANAGEMENT FUNCTIONS\n// ============================================================================\n\n/**\n * Check if a preset has at least one slot filled\n * @param preset - Preset object with main and subs\n * @returns True if at least one slot has a companion\n */\nexport function presetHasAnyCompanion(preset: CompanionPreset): boolean {\n    if (!preset) return false;\n    if (preset.main) return true;\n    if (preset.subs && preset.subs.some(sub => sub)) return true;\n    return false;\n}\n\n/**\n * Calculate the total value of a specific stat across all companions in a preset\n * @param preset - Preset object\n * @param targetStat - The stat to sum (e.g., 'bossDamage', 'normalDamage')\n * @param getCompanionEffects - Function to get companion effects\n * @param getCompanion - Function to get companion data\n * @returns Total value of the target stat\n */\nexport function calculatePresetStatValue(\n    preset: CompanionPreset,\n    targetStat: string,\n    getCompanionEffects: (className: CompanionClass, rarity: string, level: number) => CompanionEffects | null,\n    getCompanion: (key: CompanionKey) => CompanionData\n): number {\n    if (!preset) return 0;\n\n    let total = 0;\n    const allSlots: (CompanionKey | null)[] = [preset.main, ...preset.subs];\n\n    allSlots.forEach(companionKey => {\n        if (!companionKey) return;\n\n        const [className, rarity] = companionKey.split('-');\n        const companionData = getCompanion(companionKey);\n\n        if (!companionData.unlocked) return;\n\n        const level = companionData.level || 1;\n        const effects = getCompanionEffects(className as CompanionClass, rarity, level);\n\n        if (effects && effects.equipEffect && effects.equipEffect[targetStat]) {\n            total += effects.equipEffect[targetStat];\n        }\n    });\n\n    return total;\n}\n\n/**\n * Generate optimal preset for a specific target using optimized 3-phase algorithm\n * @param targetStat - The stat to maximize ('bossDamage' or 'normalDamage')\n * @param getCompanionEffects - Function to get companion effects\n * @param getCompanion - Function to get companion data\n * @param getMaxCompanionLevel - Function to get max companion level\n * @param lockedMainCompanion - Companion key to force as main, or null to optimize all slots\n * @returns Optimal preset with main and subs filled\n */\nexport function generateOptimalPreset(\n    targetStat: 'bossDamage' | 'normalDamage',\n    getCompanionEffects: (className: CompanionClass, rarity: string, level: number) => CompanionEffects | null,\n    getCompanion: (key: CompanionKey) => CompanionData,\n    getMaxCompanionLevel: () => number,\n    lockedMainCompanion: CompanionKey | null = null\n): CompanionPreset {\n    // Exclude classes that will never be optimal: DarkKnight, Marksman\n    const classes: CompanionClass[] = ['Hero', 'ArchMageIL', 'ArchMageFP', 'BowMaster', 'NightLord', 'Shadower'];\n    // Only consider Legendary, Unique, Epic (Normal and Rare are never optimal)\n    const rarities = ['Legendary', 'Unique', 'Epic'];\n\n    // Determine monster type from target stat\n    const monsterType: MonsterType = targetStat === 'bossDamage' ? 'boss' : 'normal';\n\n    // Collect all unlocked companions with their data\n    interface UnlockedCompanion {\n        companionKey: CompanionKey;\n        effects: Record<string, number>;\n    }\n\n    const unlockedCompanions: UnlockedCompanion[] = [];\n\n    rarities.forEach(rarity => {\n        classes.forEach(className => {\n            const companionKey: CompanionKey = `${className}-${rarity}` as CompanionKey;\n            const companionData = getCompanion(companionKey);\n\n            // Only consider unlocked companions\n            if (!companionData.unlocked) return;\n\n            const level = companionData.level || getMaxCompanionLevel();\n            const effects = getCompanionEffects(className, rarity, level);\n\n            if (!effects || !effects.equipEffect) return;\n\n            unlockedCompanions.push({\n                companionKey,\n                effects: effects.equipEffect\n            });\n        });\n    });\n\n    // If no unlocked companions, return empty preset\n    if (unlockedCompanions.length === 0) {\n        return { main: null, subs: [null, null, null, null, null, null] };\n    }\n\n    // Handle locked main companion case\n    let lockedMain: UnlockedCompanion | null = null;\n    if (lockedMainCompanion) {\n        const lockedMainData = unlockedCompanions.find(c => c.companionKey === lockedMainCompanion);\n        if (!lockedMainData) {\n            // Locked main is no longer valid, return empty preset\n            console.warn(`[generateOptimalPreset] Locked main companion ${lockedMainCompanion} not found or not unlocked`);\n            return { main: null, subs: [null, null, null, null, null, null] };\n        }\n        lockedMain = lockedMainData;\n        // Remove locked main from candidates (can't duplicate)\n        const lockedIndex = unlockedCompanions.indexOf(lockedMainData);\n        unlockedCompanions.splice(lockedIndex, 1);\n    }\n\n    // Check if we have enough companions to fill all slots\n    const minRequired = lockedMain ? 6 : 7;\n    if (unlockedCompanions.length < minRequired) {\n        console.warn(`[generateOptimalPreset] Only ${unlockedCompanions.length} companions available, filling all available slots`);\n        const allKeys = unlockedCompanions.map(c => c.companionKey);\n        if (lockedMain) {\n            return {\n                main: lockedMain.companionKey,\n                subs: [\n                    allKeys[0] || null,\n                    allKeys[1] || null,\n                    allKeys[2] || null,\n                    allKeys[3] || null,\n                    allKeys[4] || null,\n                    allKeys[5] || null\n                ]\n            };\n        } else {\n            return {\n                main: allKeys[0] || null,\n                subs: [\n                    allKeys[1] || null,\n                    allKeys[2] || null,\n                    allKeys[3] || null,\n                    allKeys[4] || null,\n                    allKeys[5] || null,\n                    allKeys[6] || null\n                ]\n            };\n        }\n    }\n\n    // Get base stats for DPS calculation\n    const baseStats = loadoutStore.getBaseStats();\n    const baselineService = new StatCalculationService(baseStats, null);\n    const baselineDps = baselineService.computeDPS(monsterType);\n\n    // Helper function to generate combinations\n    function* generateCombinations(companions: UnlockedCompanion[], size: number, start: number = 0): Generator<UnlockedCompanion[]> {\n        if (size === 0) {\n            yield [];\n            return;\n        }\n        for (let i = start; i < companions.length; i++) {\n            for (const rest of generateCombinations(companions, size - 1, i + 1)) {\n                yield [companions[i], ...rest];\n            }\n        }\n    }\n\n    // =========================================================================\n    // PHASE 1: Individual companion scoring\n    // =========================================================================\n\n    interface ScoredCompanion {\n        companion: UnlockedCompanion;\n        individualDps: number;\n        dpsGain: number;\n    }\n\n    const scoredCompanions: ScoredCompanion[] = unlockedCompanions.map(comp => {\n        const service = new StatCalculationService(baseStats, null);\n        applyEffectsToService(service, comp.effects, false);\n        const dps = service.computeDPS(monsterType);\n        const gain = dps - baselineDps;\n\n        return {\n            companion: comp,\n            individualDps: dps,\n            dpsGain: gain\n        };\n    });\n\n    // Sort by individual DPS contribution\n    scoredCompanions.sort((a, b) => b.dpsGain - a.dpsGain);\n\n    // =========================================================================\n    // PHASE 2: Smart locking based on marginal gains\n    // =========================================================================\n\n    const locked: ScoredCompanion[] = [];\n    const pool = [...scoredCompanions];\n\n    // Lock top performers with adaptive threshold\n    let prevGain = Infinity;\n    const MIN_LOCKED = 2; // Lock at least 2 clear winners\n    const MAX_LOCKED = 4; // Lock at most 4 (leave room for optimization)\n    const MARGINAL_GAIN_THRESHOLD = 0.6; // Lock if > 60% of previous companion's value\n    const MIN_GAIN_PERCENT = 0.008; // Must provide at least 0.8% gain to be locked\n\n    for (let i = 0; i < scoredCompanions.length && locked.length < MAX_LOCKED; i++) {\n        const score = scoredCompanions[i];\n        const gainPercent = score.dpsGain / baselineDps;\n\n        const shouldLock =\n            locked.length < MIN_LOCKED || // Always lock at least 2\n            score.dpsGain > prevGain * MARGINAL_GAIN_THRESHOLD || // High marginal value\n            gainPercent > MIN_GAIN_PERCENT; // Above minimum threshold\n\n        if (shouldLock) {\n            locked.push(score);\n            pool.splice(pool.indexOf(score), 1);\n            prevGain = score.dpsGain;\n        }\n    }\n\n    // Track selected companion keys to prevent duplicates\n    const selectedKeys = new Set<CompanionKey>();\n    if (lockedMain) {\n        selectedKeys.add(lockedMain.companionKey);\n    }\n    locked.forEach(s => selectedKeys.add(s.companion.companionKey));\n\n    // =========================================================================\n    // PHASE 3: Restricted combination testing\n    // =========================================================================\n\n    // Take top 12-15 from pool for final permutation\n    const POOL_SIZE = Math.min(15, unlockedCompanions.length);\n    const candidates = locked.concat(pool.slice(0, Math.min(POOL_SIZE - locked.length, pool.length)));\n\n    // Need to select 7 total (or 6 if main is locked)\n    const totalSlots = lockedMain ? 6 : 7;\n    const numToSelect = totalSlots - locked.length;\n\n    // CRITICAL: Filter out companions already selected (by key comparison) to prevent duplicates\n    const remaining: UnlockedCompanion[] = candidates\n        .slice(locked.length)\n        .map(s => s.companion)\n        .filter(comp => !selectedKeys.has(comp.companionKey));\n\n    let bestDps = 0;\n    let bestPreset: CompanionPreset = { main: null, subs: [null, null, null, null, null, null] };\n\n    const service = new StatCalculationService(baseStats, null);\n    let combinationsTested = 0;\n    const maxCombinations = 15000; // Reasonable limit for Phase 3\n\n    // Helper to calculate DPS for a combination\n    const calculateDpsForCombination = (companions: UnlockedCompanion[]): number => {\n        const totalEffects: Record<string, number> = {};\n\n        companions.forEach(comp => {\n            Object.entries(comp.effects).forEach(([stat, value]) => {\n                totalEffects[stat] = (totalEffects[stat] || 0) + value;\n            });\n        });\n\n        service.reset();\n        applyEffectsToService(service, totalEffects, false);\n        return service.computeDPS(monsterType);\n    };\n\n    // Generate combinations of remaining slots\n    for (const combination of generateCombinations(remaining, numToSelect)) {\n        combinationsTested++;\n        if (combinationsTested > maxCombinations) {\n            console.warn(`[Phase 3] Reached max combinations limit (${maxCombinations}), using best found so far`);\n            break;\n        }\n\n        // Combine locked + new combination\n        let fullSelection: UnlockedCompanion[];\n        if (lockedMain) {\n            // Include locked main + locked from Phase 2 + new combination\n            fullSelection = [lockedMain, ...locked.map(s => s.companion), ...combination];\n        } else {\n            fullSelection = locked.map(s => s.companion).concat(combination);\n        }\n\n        // Calculate DPS\n        const dps = calculateDpsForCombination(fullSelection);\n\n        if (dps > bestDps) {\n            bestDps = dps;\n\n            // If main is locked, it should be the main slot\n            if (lockedMain) {\n                // fullSelection = [lockedMain, ...6 subs]\n                // Skip first element (locked main) when creating subs array\n                bestPreset = {\n                    main: lockedMain.companionKey,\n                    subs: fullSelection.slice(1).map(c => c.companionKey) as [\n                        CompanionKey | null,\n                        CompanionKey | null,\n                        CompanionKey | null,\n                        CompanionKey | null,\n                        CompanionKey | null,\n                        CompanionKey | null\n                    ]\n                };\n            } else {\n                // First companion is main, rest are subs\n                bestPreset = {\n                    main: fullSelection[0].companionKey,\n                    subs: fullSelection.slice(1).map(c => c.companionKey) as [\n                        CompanionKey | null,\n                        CompanionKey | null,\n                        CompanionKey | null,\n                        CompanionKey | null,\n                        CompanionKey | null,\n                        CompanionKey | null\n                    ]\n                };\n            }\n        }\n    }\n\n    const totalGainPercent = ((bestDps - baselineDps) / baselineDps * 100);\n\n    return bestPreset;\n}\n\n// ============================================================================\n// PRESET SWAP HELPER\n// ============================================================================\n\n/**\n * Swap companion preset effects using StatCalculationService\n *\n * This function calculates new base stats by removing current companion effects\n * and adding new companion effects, using the proper StatCalculationService methods\n * to handle stat-specific logic (weapon bonuses, diminishing returns, etc.)\n *\n * @param currentEffects - Currently equipped companion effects (to remove)\n * @param newEffects - New preset effects (to add)\n * @returns New base stats object to persist via loadoutStore.updateBaseStats()\n *\n * @example\n * // When switching presets with user confirmation that stats are incorporated\n * const newStats = swapCompanionPresetEffects(currentPresetEffects, newPresetEffects);\n * loadoutStore.updateBaseStats(newStats);\n */\nexport function swapCompanionPresetEffects(\n    currentEffects: Record<string, number>,\n    newEffects: Record<string, number>\n): BaseStats {\n    // 1. Get current base stats from loadoutStore\n    const baseStats = loadoutStore.getBaseStats();\n\n    // 2. Create StatCalculationService instance with fresh stats\n    const service = new StatCalculationService(baseStats, null);\n\n    // 3. Subtract current effects\n    Object.entries(currentEffects).forEach(([statKey, value]) => {\n        if (value === 0 || value === undefined || value === null) return;\n\n        const mappedId = COMPANION_STAT_KEY_TO_STAT_ID[statKey];\n        if (!mappedId) {\n            console.warn(`[swapCompanionPresetEffects] Unknown companion stat key: ${statKey}, skipping removal`);\n            return;\n        }\n\n        service.subtract(mappedId, value);\n    });\n\n    // 4. Add new effects\n    Object.entries(newEffects).forEach(([statKey, value]) => {\n        if (value === 0 || value === undefined || value === null) return;\n\n        const mappedId = COMPANION_STAT_KEY_TO_STAT_ID[statKey];\n        if (!mappedId) {\n            console.warn(`[swapCompanionPresetEffects] Unknown companion stat key: ${statKey}, skipping addition`);\n            return;\n        }\n\n        service.add(mappedId, value);\n    });\n\n    // 5. Return the modified stats\n    return service.getStats();\n}\n"],
  "mappings": "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",
  "names": ["service"]
}
