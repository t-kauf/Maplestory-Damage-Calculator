{
  "version": 3,
  "sources": ["cube-potential.ts"],
  "sourcesContent": ["/**\r\n * Cube Potential - Core Logic\r\n * Business logic and orchestrator functions for the cube potential system\r\n */\r\n\r\nimport { StatCalculationService } from '@ts/services/stat-calculation-service.js';\r\nimport { loadoutStore } from '@ts/store/loadout.store';\r\nimport { STAT } from '@ts/types/constants';\r\nimport {\r\n    CLASS_MAIN_STAT_MAP,\r\n    SLOT_SPECIFIC_POTENTIALS,\r\n    EQUIPMENT_POTENTIAL_DATA,\r\n    SLOT_NAMES,\r\n    NON_COMBAT_POTENTIAL_STATS,\r\n    POTENTIAL_STAT_TO_STAT_ID\r\n} from '@ts/page/cube-potential/cube-potential-data.js';\r\nimport type {\r\n    CubeSlotId,\r\n    PotentialType,\r\n    PotentialLine,\r\n    PotentialSet,\r\n    Rarity,\r\n    AllCubeSlotData,\r\n    PotentialLineEntry\r\n} from '@ts/types/page/gear-lab/gear-lab.types';\r\nimport type { BaseStats } from '@ts/types/loadout.js';\r\n\r\n// ============================================================================\r\n// STATE\r\n// ============================================================================\r\n\r\n/**\r\n * Current cube slot selection\r\n */\r\nexport let currentCubeSlot: CubeSlotId = 'helm';\r\n\r\n/**\r\n * Current potential type selection\r\n */\r\nexport let currentPotentialType: PotentialType = 'regular';\r\n\r\n/**\r\n * Rankings cache - stores calculated rankings by slot and rarity\r\n * Structure: rankingsCache[slotId][rarity] = RankingEntry[]\r\n */\r\nexport const rankingsCache: Record<CubeSlotId, Record<Rarity, RankingEntry[]>> = {} as any;\r\n\r\n/**\r\n * Track which slot+rarity combinations are currently calculating\r\n */\r\nexport const rankingsInProgress: Record<string, boolean> = {};\r\n\r\n/**\r\n * Ranking entry interface\r\n */\r\nexport interface RankingEntry {\r\n    line1: PotentialLineEntry;\r\n    line2: PotentialLineEntry;\r\n    line3: PotentialLineEntry;\r\n    dpsGain: number;\r\n}\r\n\r\n/**\r\n * Comparison result interface\r\n */\r\nexport interface ComparisonResult {\r\n    setAGain: number;\r\n    setBGain: number;\r\n    setBAbsoluteGain: number;\r\n    deltaGain: number;\r\n    setAStats: any;\r\n    setBStats: any;\r\n    slotId: CubeSlotId;\r\n    rarity: Rarity;\r\n}\r\n\r\n// ============================================================================\r\n// UTILITY FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Get rarity color for slot button borders\r\n */\r\nexport function getRarityColor(rarity: Rarity): string {\r\n    const colors: Record<Rarity, string> = {\r\n        'normal': '#9ca3af',      // Gray\r\n        'rare': '#60a5fa',        // Blue\r\n        'epic': '#a78bfa',        // Purple\r\n        'unique': '#fbbf24',      // Yellow/Gold\r\n        'legendary': '#33ce85',   // Green\r\n        'mystic': '#ff3f42'       // Red\r\n    };\r\n    return colors[rarity] || colors['normal'];\r\n}\r\n\r\n/**\r\n * Get main stat for current class\r\n */\r\nexport function getMainStatForClass(): string | null {\r\n    const selectedClass = loadoutStore.getSelectedClass();\r\n    if (!selectedClass) return null;\r\n    return CLASS_MAIN_STAT_MAP[selectedClass] || null;\r\n}\r\n\r\n/**\r\n * Get stat ID from potential stat name\r\n * Returns null if stat has no combat impact or cannot be mapped\r\n */\r\nexport function getStatIdFromPotentialStat(\r\n    potentialStat: string,\r\n    mainStat: string | null\r\n): string | null {\r\n    // Skip non-combat stats\r\n    if (NON_COMBAT_POTENTIAL_STATS.includes(potentialStat as any)) {\r\n        return null;\r\n    }\r\n\r\n    // Main stat % maps to statDamage\r\n    if (mainStat && potentialStat === `${mainStat} %`) {\r\n        return STAT.MAIN_STAT_PCT.id;\r\n    }\r\n\r\n    // Flat main stat (Str, Dex, Int, Luk without %) - signal to use addMainStat\r\n    if (mainStat && potentialStat === mainStat) {\r\n        return STAT.PRIMARY_MAIN_STAT.id; // Special marker for flat main stat\r\n    }\r\n\r\n    // Use the mapping table\r\n    return POTENTIAL_STAT_TO_STAT_ID[potentialStat] || null;\r\n}\r\n\r\n/**\r\n * Result of mapping a potential stat to damage stat\r\n */\r\nexport interface PotentialStatMappingResult {\r\n    stat: string | null;\r\n    value: number;\r\n    isMainStatPct: boolean;\r\n}\r\n\r\n/**\r\n * Convert potential stat to damage stat for simulation\r\n * This is a simplified version for simulation purposes that doesn't use DOM\r\n */\r\nexport function potentialStatToDamageStat(\r\n    potentialStat: string,\r\n    value: number,\r\n    accumulatedMainStatPct: number = 0\r\n): PotentialStatMappingResult {\r\n    const mainStat = getMainStatForClass();\r\n    if (!mainStat) return { stat: null, value: 0, isMainStatPct: false };\r\n\r\n    // Map potential stat to damage calculation stat\r\n    const statMap: Record<string, string> = {\r\n        'Critical Rate %': STAT.CRIT_RATE.id,\r\n        'Critical Damage %': STAT.CRIT_DAMAGE.id,\r\n        'Attack Speed %': STAT.ATTACK_SPEED.id,\r\n        'Damage %': STAT.DAMAGE.id,\r\n        'Final Damage %': STAT.FINAL_DAMAGE.id,\r\n        'Min Damage Multiplier %': STAT.MIN_DAMAGE.id,\r\n        'Max Damage Multiplier %': STAT.MAX_DAMAGE.id,\r\n        'Defense %': STAT.DEFENSE.id,\r\n        'Defense Penetration': STAT.DEF_PEN.id,\r\n        // Max HP % and Max MP % are non-combat stats, skip them\r\n    };\r\n\r\n    // Check if it's a main stat percentage\r\n    if (potentialStat === `${mainStat} %`) {\r\n        return { stat: STAT.STAT_DAMAGE.id, value: value / 100, isMainStatPct: true };\r\n    }\r\n\r\n    // Check if it's a flat main stat\r\n    if (potentialStat === mainStat) {\r\n        return { stat: STAT.STAT_DAMAGE.id, value: value / 100, isMainStatPct: false };\r\n    }\r\n\r\n    // Return mapped stat or null if not relevant\r\n    const statId = statMap[potentialStat];\r\n    return {\r\n        stat: statId || null,\r\n        value: statId ? value : 0,\r\n        isMainStatPct: false\r\n    };\r\n}\r\n\r\n/**\r\n * Check if a potential line exists in a given rarity for a given slot and line number\r\n */\r\nexport function lineExistsInRarity(\r\n    slotId: CubeSlotId,\r\n    rarity: Rarity,\r\n    lineNum: number,\r\n    lineStat: string,\r\n    lineValue: number,\r\n    linePrime: boolean\r\n): boolean {\r\n    if (!lineStat) return false;\r\n\r\n    const potentialData = EQUIPMENT_POTENTIAL_DATA[rarity];\r\n    if (!potentialData) return false;\r\n\r\n    // Get base potential lines for this line number\r\n    const lineKey = `line${lineNum}` as keyof typeof potentialData;\r\n    let availableLines: PotentialLineEntry[] = [...(potentialData[lineKey] || [])];\r\n\r\n    // Add slot-specific lines if available\r\n    if (SLOT_SPECIFIC_POTENTIALS[slotId] && SLOT_SPECIFIC_POTENTIALS[slotId][rarity]) {\r\n        const slotSpecificLines = SLOT_SPECIFIC_POTENTIALS[slotId][rarity][lineKey];\r\n        if (slotSpecificLines) {\r\n            availableLines = [...slotSpecificLines, ...availableLines];\r\n        }\r\n    }\r\n\r\n    // Check if this exact line exists\r\n    return availableLines.some(line =>\r\n        line.stat === lineStat &&\r\n        line.value === lineValue &&\r\n        line.prime === linePrime\r\n    );\r\n}\r\n\r\n/**\r\n * Calculate DPS gain for a specific slot's potential set\r\n */\r\nexport function calculateSlotSetGain(\r\n    slotId: CubeSlotId,\r\n    rarity: Rarity,\r\n    setData: PotentialSet,\r\n    currentStats: BaseStats\r\n): { gain: number; stats: BaseStats; baselineStats: BaseStats } {\r\n    const mainStat = getMainStatForClass();\r\n\r\n    // Step 1: Calculate baseline by removing this set's contribution from current stats\r\n    const baselineService = new StatCalculationService(currentStats);\r\n\r\n    for (let lineNum = 1; lineNum <= 3; lineNum++) {\r\n        const lineKey = `line${lineNum}` as keyof PotentialSet;\r\n        const line = setData[lineKey];\r\n        if (!line || !line.stat) continue;\r\n\r\n        // Only process line if it exists in the current rarity for this slot\r\n        if (!lineExistsInRarity(slotId, rarity, lineNum, line.stat, line.value, line.prime)) continue;\r\n\r\n        // Map potential stat to damage stat ID\r\n        const statId = getStatIdFromPotentialStat(line.stat, mainStat);\r\n\r\n        // Skip if no combat impact\r\n        if (!statId) continue;\r\n\r\n        baselineService.subtract(statId, line.value);\r\n    }\r\n\r\n    const baselineDPS = baselineService.computeDPS('boss');\r\n\r\n    // Step 2: Calculate stats with this set applied to baseline\r\n    const setService = new StatCalculationService(baselineService.getStats());\r\n\r\n    for (let lineNum = 1; lineNum <= 3; lineNum++) {\r\n        const lineKey = `line${lineNum}` as keyof PotentialSet;\r\n        const line = setData[lineKey];\r\n        if (!line || !line.stat) continue;\r\n\r\n        if (!lineExistsInRarity(slotId, rarity, lineNum, line.stat, line.value, line.prime)) continue;\r\n\r\n        // Map potential stat to damage stat ID\r\n        const statId = getStatIdFromPotentialStat(line.stat, mainStat);\r\n\r\n        // Skip if no combat impact\r\n        if (!statId) continue;\r\n\r\n        setService.add(statId, line.value);\r\n    }\r\n\r\n    const setDPS = setService.computeDPS('boss');\r\n    const gain = ((setDPS - baselineDPS) / baselineDPS * 100);\r\n\r\n    return { gain, stats: setService.getStats(), baselineStats: baselineService.getStats() };\r\n}\r\n\r\n/**\r\n * Calculate comparison between Set A and Set B\r\n */\r\nexport function calculateComparison(\r\n    cubeSlotData: AllCubeSlotData,\r\n    currentCubeSlot: CubeSlotId,\r\n    currentPotentialType: PotentialType\r\n): ComparisonResult | null {\r\n    const selectedClass = loadoutStore.getSelectedClass();\r\n    if (!selectedClass) {\r\n        return null;\r\n    }\r\n\r\n    if (Object.keys(cubeSlotData).length === 0) {\r\n        return null;\r\n    }\r\n\r\n    const slotData = cubeSlotData[currentCubeSlot][currentPotentialType];\r\n    const currentStats = loadoutStore.getBaseStats();\r\n    const rarity = slotData.rarity;\r\n\r\n    // Use shared function to calculate Set A\r\n    const setAResult = calculateSlotSetGain(currentCubeSlot, rarity, slotData.setA, currentStats);\r\n    const setAGain = setAResult.gain;\r\n    const setAStats = setAResult.stats;\r\n    const baselineStats = setAResult.baselineStats;\r\n\r\n    // Calculate Set B using the same baseline\r\n    const setBResult = calculateSlotSetGain(currentCubeSlot, rarity, slotData.setB, baselineStats);\r\n    const setBStats = setBResult.stats;\r\n\r\n    const baselineDPS = new StatCalculationService(baselineStats).computeDPS('boss');\r\n    const setADPS = new StatCalculationService(setAStats).computeDPS('boss');\r\n    const setBDPS = new StatCalculationService(setBStats).computeDPS('boss');\r\n\r\n    // Calculate gains\r\n    // Set B Absolute Gain: compared to baseline (for ranking comparison)\r\n    const setBAbsoluteGain = ((setBDPS - baselineDPS) / baselineDPS * 100);\r\n    // Set B Relative Gain: compared to Set A (shows the delta when swapping from A to B)\r\n    const setBGain = ((setBDPS - setADPS) / setADPS * 100);\r\n    const deltaGain = setBGain - setAGain;\r\n\r\n    return {\r\n        setAGain,\r\n        setBGain,\r\n        setBAbsoluteGain, // For ranking comparison\r\n        deltaGain,\r\n        setAStats,\r\n        setBStats,\r\n        slotId: currentCubeSlot,\r\n        rarity: cubeSlotData[currentCubeSlot][currentPotentialType].rarity\r\n    };\r\n}\r\n\r\n/**\r\n * Get percentile for a given DPS gain (helper for summary)\r\n */\r\nexport function getPercentileForGain(\r\n    slotId: CubeSlotId,\r\n    rarity: Rarity,\r\n    dpsGain: number,\r\n    rankingsCache: Record<CubeSlotId, Record<Rarity, RankingEntry[]>>,\r\n    rankingsInProgress: Record<string, boolean>\r\n): string {\r\n    const key = `${slotId}-${rarity}`;\r\n    const rankings = rankingsCache[slotId]?.[rarity];\r\n\r\n    // Check if currently loading\r\n    if (rankingsInProgress[key]) {\r\n        return '<span style=\"color: var(--text-secondary); font-style: italic;\">Loading...</span>';\r\n    }\r\n\r\n    if (!rankings || rankings.length === 0) {\r\n        return '<span style=\"color: var(--text-secondary);\">\u2014</span>';\r\n    }\r\n\r\n    // Find percentile\r\n    let percentileValue = 0;\r\n    for (let i = 0; i < rankings.length; i++) {\r\n        if (rankings[i].dpsGain <= dpsGain) {\r\n            percentileValue = ((i / rankings.length) * 100);\r\n            break;\r\n        }\r\n    }\r\n    if (percentileValue === 0 && dpsGain >= rankings[0].dpsGain) percentileValue = 0;\r\n    if (percentileValue === 0 && dpsGain < rankings[rankings.length - 1].dpsGain) percentileValue = 100;\r\n\r\n    const percentile = percentileValue.toFixed(1);\r\n    return `<span style=\"color: var(--accent-primary);\">Top ${percentile}%</span>`;\r\n}\r\n\r\n// ============================================================================\r\n// ORCHESTRATOR FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Initialize cube potential system\r\n */\r\nexport async function initializeCubePotential(): Promise<void> {\r\n    // Initial setup is handled by gear-lab-store initialization\r\n}\r\n\r\n/**\r\n * Clear rankings cache and recalculate if needed\r\n */\r\nexport function clearCubeRankingsCache(): void {\r\n    // Clear all cached rankings\r\n    for (const slotId of SLOT_NAMES) {\r\n        if (rankingsCache[slotId.id]) {\r\n            rankingsCache[slotId.id] = {} as any;\r\n        }\r\n    }\r\n\r\n    // Clear in-progress trackers\r\n    for (const key in rankingsInProgress) {\r\n        delete rankingsInProgress[key];\r\n    }\r\n}\r\n\r\n/**\r\n * Switch between regular and bonus potential\r\n */\r\nexport function switchPotentialType(type: PotentialType): void {\r\n    currentPotentialType = type;\r\n}\r\n\r\n/**\r\n * Select a cube slot\r\n */\r\nexport function selectCubeSlot(slotId: CubeSlotId): void {\r\n    currentCubeSlot = slotId;\r\n}\r\n"],
  "mappings": "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",
  "names": ["currentCubeSlot", "currentPotentialType", "rankingsCache", "rankingsInProgress"]
}
