{
  "version": 3,
  "sources": ["cube-potential.ts"],
  "sourcesContent": ["/**\n * Cube Potential - Core Logic\n * Business logic and orchestrator functions for the cube potential system\n */\n\nimport { StatCalculationService } from '@ts/services/stat-calculation-service.js';\nimport { loadoutStore } from '@ts/store/loadout.store';\nimport { STAT } from '@ts/types/constants';\nimport {\n    CLASS_MAIN_STAT_MAP,\n    SLOT_SPECIFIC_POTENTIALS,\n    EQUIPMENT_POTENTIAL_DATA,\n    SLOT_NAMES,\n    NON_COMBAT_POTENTIAL_STATS,\n    POTENTIAL_STAT_TO_STAT_ID\n} from '@ts/page/cube-potential/cube-potential-data.js';\nimport type {\n    CubeSlotId,\n    PotentialType,\n    PotentialLine,\n    PotentialSet,\n    Rarity,\n    AllCubeSlotData,\n    PotentialLineEntry\n} from '@ts/types/page/gear-lab/gear-lab.types';\nimport type { BaseStats } from '@ts/types/loadout.js';\n\n// ============================================================================\n// STATE\n// ============================================================================\n\n/**\n * Current cube slot selection\n */\nexport let currentCubeSlot: CubeSlotId = 'helm';\n\n/**\n * Current potential type selection\n */\nexport let currentPotentialType: PotentialType = 'regular';\n\n/**\n * Rankings cache - stores calculated rankings by slot and rarity\n * Structure: rankingsCache[slotId][rarity] = RankingEntry[]\n */\nexport const rankingsCache: Record<CubeSlotId, Record<Rarity, RankingEntry[]>> = {} as any;\n\n/**\n * Track which slot+rarity combinations are currently calculating\n */\nexport const rankingsInProgress: Record<string, boolean> = {};\n\n/**\n * Ranking entry interface\n */\nexport interface RankingEntry {\n    line1: PotentialLineEntry;\n    line2: PotentialLineEntry;\n    line3: PotentialLineEntry;\n    dpsGain: number;\n}\n\n/**\n * Comparison result interface\n */\nexport interface ComparisonResult {\n    setAGain: number;\n    setBGain: number;\n    setBAbsoluteGain: number;\n    deltaGain: number;\n    slotId: CubeSlotId;\n    rarity: Rarity;\n}\n\n// ============================================================================\n// UTILITY FUNCTIONS\n// ============================================================================\n\n/**\n * Get rarity color for slot button borders\n */\nexport function getRarityColor(rarity: Rarity): string {\n    const colors: Record<Rarity, string> = {\n        'normal': '#9ca3af',      // Gray\n        'rare': '#60a5fa',        // Blue\n        'epic': '#a78bfa',        // Purple\n        'unique': '#fbbf24',      // Yellow/Gold\n        'legendary': '#33ce85',   // Green\n        'mystic': '#ff3f42'       // Red\n    };\n    return colors[rarity] || colors['normal'];\n}\n\n/**\n * Get main stat for current class\n */\nexport function getMainStatForClass(): string | null {\n    const selectedClass = loadoutStore.getSelectedClass();\n    if (!selectedClass) return null;\n    return CLASS_MAIN_STAT_MAP[selectedClass] || null;\n}\n\n/**\n * Get stat ID from potential stat name\n * Returns null if stat has no combat impact or cannot be mapped\n */\nexport function getStatIdFromPotentialStat(\n    potentialStat: string,\n    mainStat: string | null\n): string | null {\n    // Skip non-combat stats\n    if (NON_COMBAT_POTENTIAL_STATS.includes(potentialStat as any)) {\n        return null;\n    }\n\n    // Normalize for case-insensitive comparison\n    const normalizedPotentialStat = potentialStat.toLowerCase();\n    const normalizedMainStat = mainStat?.toLowerCase() || null;\n\n    // Main stat % maps to MAIN_STAT_PCT\n    if (normalizedMainStat && normalizedPotentialStat === `${normalizedMainStat} %`) {\n        return STAT.MAIN_STAT_PCT.id;\n    }\n\n    // Flat main stat - signal to use PRIMARY_MAIN_STAT\n    if (normalizedMainStat && normalizedPotentialStat === normalizedMainStat) {\n        return STAT.PRIMARY_MAIN_STAT.id;\n    }\n\n    // Use the mapping table (keys are already in consistent case)\n    return POTENTIAL_STAT_TO_STAT_ID[potentialStat] || null;\n}\n\n/**\n * Result of mapping a potential stat to damage stat\n */\nexport interface PotentialStatMappingResult {\n    stat: string | null;\n    value: number;\n    isMainStatPct: boolean;\n}\n\n/**\n * Convert potential stat to damage stat for simulation\n * This is a simplified version for simulation purposes that doesn't use DOM\n */\nexport function potentialStatToDamageStat(\n    potentialStat: string,\n    value: number,\n    accumulatedMainStatPct: number = 0\n): PotentialStatMappingResult {\n    const mainStat = getMainStatForClass();\n    if (!mainStat) return { stat: null, value: 0, isMainStatPct: false };\n\n    // Normalize for case-insensitive comparison\n    const normalizedPotentialStat = potentialStat.toLowerCase();\n    const normalizedMainStat = mainStat.toLowerCase();\n\n    // Map potential stat to damage calculation stat\n    const statMap: Record<string, string> = {\n        'Critical Rate %': STAT.CRIT_RATE.id,\n        'Critical Damage %': STAT.CRIT_DAMAGE.id,\n        'Attack Speed %': STAT.ATTACK_SPEED.id,\n        'Damage %': STAT.DAMAGE.id,\n        'Final Damage %': STAT.FINAL_DAMAGE.id,\n        'Min Damage Multiplier %': STAT.MIN_DAMAGE.id,\n        'Max Damage Multiplier %': STAT.MAX_DAMAGE.id,\n        'Defense %': STAT.DEFENSE.id,\n        'Defense Penetration': STAT.DEF_PEN.id,\n        // Max HP % and Max MP % are non-combat stats, skip them\n    };\n\n    // Check if it's a main stat percentage\n    if (normalizedPotentialStat === `${normalizedMainStat} %`) {\n        return { stat: STAT.MAIN_STAT_PCT.id, value: value / 100, isMainStatPct: true };\n    }\n\n    // Check if it's a flat main stat\n    if (normalizedPotentialStat === normalizedMainStat) {\n        return { stat: STAT.PRIMARY_MAIN_STAT.id, value: value / 100, isMainStatPct: false };\n    }\n\n    // Return mapped stat or null if not relevant\n    // Note: statMap keys use exact case matching (non-main stats)\n    const statId = statMap[potentialStat];\n    return {\n        stat: statId || null,\n        value: statId ? value : 0,\n        isMainStatPct: false\n    };\n}\n\n/**\n * Check if a potential line exists in a given rarity for a given slot and line number\n */\nexport function lineExistsInRarity(\n    slotId: CubeSlotId,\n    rarity: Rarity,\n    lineNum: number,\n    lineStat: string,\n    lineValue: number,\n    linePrime: boolean\n): boolean {\n    if (!lineStat) return false;\n\n    const potentialData = EQUIPMENT_POTENTIAL_DATA[rarity];\n    if (!potentialData) return false;\n\n    // Get base potential lines for this line number\n    const lineKey = `line${lineNum}` as keyof typeof potentialData;\n    let availableLines: PotentialLineEntry[] = [...(potentialData[lineKey] || [])];\n\n    // Add slot-specific lines if available\n    if (SLOT_SPECIFIC_POTENTIALS[slotId] && SLOT_SPECIFIC_POTENTIALS[slotId][rarity]) {\n        const slotSpecificLines = SLOT_SPECIFIC_POTENTIALS[slotId][rarity][lineKey];\n        if (slotSpecificLines) {\n            availableLines = [...slotSpecificLines, ...availableLines];\n        }\n    }\n\n    // Check if this exact line exists\n    return availableLines.some(line =>\n        line.stat === lineStat &&\n        line.value === lineValue &&\n        line.prime === linePrime\n    );\n}\n\n/**\n * Calculate DPS gain for a specific slot's potential set\n */\nexport function calculateSlotSetGain(\n    slotId: CubeSlotId,\n    rarity: Rarity,\n    setToRemoveData: PotentialSet,\n    setToAddData: PotentialSet,\n    currentStats: BaseStats\n): { gain: number; bossDPS: number } {\n    const mainStat = getMainStatForClass();\n\n    // Step 1: Calculate baseline by removing this set's contribution from current stats\n    const baselineService = new StatCalculationService(currentStats);\n\n    for (let lineNum = 1; lineNum <= 3; lineNum++) {\n        const lineKey = `line${lineNum}` as keyof PotentialSet;\n        const line = setToRemoveData[lineKey];\n        if (!line || !line.stat) continue;\n\n        // Only process line if it exists in the current rarity for this slot\n        if (!lineExistsInRarity(slotId, rarity, lineNum, line.stat, line.value, line.prime)) continue;\n\n        // Map potential stat to damage stat ID\n        const statId = getStatIdFromPotentialStat(line.stat, mainStat);\n\n        // Skip if no combat impact\n        if (!statId) continue;\n\n        baselineService.subtract(statId, line.value);\n    }\n\n    const baselineDPS = baselineService.computeDPS('boss');\n\n    // Step 2: Calculate stats with this set applied to baseline\n    const setService = new StatCalculationService(baselineService.getStats());\n\n    for (let lineNum = 1; lineNum <= 3; lineNum++) {\n        const lineKey = `line${lineNum}` as keyof PotentialSet;\n        const line = setToAddData[lineKey];\n        if (!line || !line.stat) continue;\n\n        if (!lineExistsInRarity(slotId, rarity, lineNum, line.stat, line.value, line.prime)) continue;\n\n        // Map potential stat to damage stat ID\n        const statId = getStatIdFromPotentialStat(line.stat, mainStat);\n\n        // Skip if no combat impact\n        if (!statId) continue;\n\n        setService.add(statId, line.value);\n    }\n\n    const setDPS = setService.computeDPS('boss');\n    const gain = ((setDPS - baselineDPS) / baselineDPS * 100);\n\n    return { gain, bossDPS: setDPS };\n}\n\n/**\n * Calculate comparison between Set A and Set B\n */\nexport function calculateComparison(\n    cubeSlotData: AllCubeSlotData,\n    currentCubeSlot: CubeSlotId,\n    currentPotentialType: PotentialType\n): ComparisonResult | null {\n    const selectedClass = loadoutStore.getSelectedClass();\n    if (!selectedClass) {\n        return null;\n    }\n\n    if (Object.keys(cubeSlotData).length === 0) {\n        return null;\n    }\n\n    const slotData = cubeSlotData[currentCubeSlot][currentPotentialType];\n    const currentStats = loadoutStore.getBaseStats();\n    const rarity = slotData.rarity;\n\n    // Use shared function to calculate Set A\n    const setAResult = calculateSlotSetGain(currentCubeSlot, rarity, slotData.setA, slotData.setA, currentStats);\n    const setAGain = setAResult.gain;\n\n    // Calculate Set B using the same baseline\n    const setBResult = calculateSlotSetGain(currentCubeSlot, rarity, slotData.setA, slotData.setB, currentStats);\n    const setBStats = setBResult.gain;\n\n    const baselineDPS = new StatCalculationService(loadoutStore.getBaseStats()).computeDPS('boss');\n\n    // Calculate gains\n    // Set B Absolute Gain: compared to baseline (for ranking comparison)\n    const setBAbsoluteGain = ((setBResult.bossDPS - baselineDPS) / baselineDPS * 100);\n    // Set B Relative Gain: compared to Set A (shows the delta when swapping from A to B)\n    const setBGain = ((setBResult.bossDPS - setAResult.bossDPS) / setAResult.bossDPS * 100);\n    const deltaGain = setBGain - setAGain;\n\n    return {\n        setAGain,\n        setBGain,\n        setBAbsoluteGain, // For ranking comparison\n        deltaGain,\n        slotId: currentCubeSlot,\n        rarity: cubeSlotData[currentCubeSlot][currentPotentialType].rarity\n    };\n}\n\n/**\n * Get percentile for a given DPS gain (helper for summary)\n */\nexport function getPercentileForGain(\n    slotId: CubeSlotId,\n    rarity: Rarity,\n    dpsGain: number,\n    rankingsCache: Record<CubeSlotId, Record<Rarity, RankingEntry[]>>,\n    rankingsInProgress: Record<string, boolean>\n): string {\n    const key = `${slotId}-${rarity}`;\n    const rankings = rankingsCache[slotId]?.[rarity];\n\n    // Check if currently loading\n    if (rankingsInProgress[key]) {\n        return '<span style=\"color: var(--text-secondary); font-style: italic;\">Loading...</span>';\n    }\n\n    if (!rankings || rankings.length === 0) {\n        return '<span style=\"color: var(--text-secondary);\">\u2014</span>';\n    }\n\n    // Find percentile\n    let percentileValue = 0;\n    for (let i = 0; i < rankings.length; i++) {\n        if (rankings[i].dpsGain <= dpsGain) {\n            percentileValue = ((i / rankings.length) * 100);\n            break;\n        }\n    }\n    if (percentileValue === 0 && dpsGain >= rankings[0].dpsGain) percentileValue = 0;\n    if (percentileValue === 0 && dpsGain < rankings[rankings.length - 1].dpsGain) percentileValue = 100;\n\n    const percentile = percentileValue.toFixed(1);\n    return `<span style=\"color: var(--accent-primary);\">Top ${percentile}%</span>`;\n}\n\n// ============================================================================\n// ORCHESTRATOR FUNCTIONS\n// ============================================================================\n\n/**\n * Initialize cube potential system\n */\nexport async function initializeCubePotential(): Promise<void> {\n    // Initial setup is handled by gear-lab-store initialization\n}\n\n/**\n * Clear rankings cache and recalculate if needed\n */\nexport function clearCubeRankingsCache(): void {\n    // Clear all cached rankings\n    for (const slotId of SLOT_NAMES) {\n        if (rankingsCache[slotId.id]) {\n            rankingsCache[slotId.id] = {} as any;\n        }\n    }\n\n    // Clear in-progress trackers\n    for (const key in rankingsInProgress) {\n        delete rankingsInProgress[key];\n    }\n}\n\n/**\n * Switch between regular and bonus potential\n */\nexport function switchPotentialType(type: PotentialType): void {\n    currentPotentialType = type;\n}\n\n/**\n * Select a cube slot\n */\nexport function selectCubeSlot(slotId: CubeSlotId): void {\n    currentCubeSlot = slotId;\n}\n"],
  "mappings": "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",
  "names": ["currentCubeSlot", "currentPotentialType", "rankingsCache", "rankingsInProgress"]
}
