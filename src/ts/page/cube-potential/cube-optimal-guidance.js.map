{
  "version": 3,
  "sources": ["cube-optimal-guidance.ts"],
  "sourcesContent": ["/**\n * Cube Optimal Guidance - Recommendation Engine and Optimal Strategy Display\n * Provides recommendations for optimal cube usage based on expected value\n */\n\nimport { StatCalculationService } from '@ts/services/stat-calculation-service.js';\nimport {\n    RARITY_UPGRADE_RATES,\n    SLOT_NAMES\n} from '@ts/page/cube-potential/cube-potential-data.js';\nimport { loadoutStore } from '@ts/store/loadout.store.js';\nimport { potentialStatToDamageStat } from '@ts/page/cube-potential/cube-potential.js';\nimport { findOptimalSlotToCube, sampleExpectedDPSGain } from './cube-expected-value.js';\nimport type { SlotState } from './cube-expected-value.js';\nimport type { BaseStats } from '@ts/types/loadout.js';\nimport type { CubeSlotId, Rarity, PotentialSet } from '@ts/types/page/gear-lab/gear-lab.types';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface GuidanceState {\n    potentialType: 'regular' | 'bonus';\n    cubeBudget: number;\n}\n\nexport interface OptimalSequenceStep {\n    slotId: CubeSlotId;\n    slotName: string;\n    cubes: number;\n    cumulativeDPS: number;\n}\n\nexport interface GuidanceData {\n    recommendedSlot: SlotState | null;\n    marginalGain: number;\n    optimalSequence: OptimalSequenceStep[];\n}\n\n// ============================================================================\n// STATE\n// ============================================================================\n\nlet guidanceState: GuidanceState = {\n    potentialType: 'regular',\n    cubeBudget: 100\n};\n\n// ============================================================================\n// OPTIMAL GUIDANCE FUNCTIONS\n// ============================================================================\n\n/**\n * Initialize optimal guidance system\n */\nexport function initOptimalGuidance(): void {\n    loadGuidanceBudget();\n}\n\n/**\n * Load saved cube budget from localStorage\n */\nfunction loadGuidanceBudget(): void {\n    const saved = localStorage.getItem('optimalGuidanceBudget');\n    if (saved) {\n        guidanceState.cubeBudget = parseInt(saved) || 100;\n        const budgetInput = document.getElementById('optimal-cube-budget') as HTMLInputElement;\n        if (budgetInput) {\n            budgetInput.value = guidanceState.cubeBudget.toString();\n        }\n    }\n}\n\n/**\n * Calculate current slot DPS gain\n */\nfunction calculateCurrentSlotDPSGain(slotId: CubeSlotId, slotData: { rarity: Rarity; setA: PotentialSet }): number {\n    const baseStats = loadoutStore.getBaseStats();\n    const baseDPS = new StatCalculationService(baseStats).computeDPS('boss');\n\n    const slotService = new StatCalculationService(baseStats);\n    let accumulatedMainStatPct = 0;\n\n    const lines = [\n        slotData.setA.line1,\n        slotData.setA.line2,\n        slotData.setA.line3\n    ];\n\n    lines.forEach(line => {\n        if (!line || !line.stat) return;\n        const mapped = potentialStatToDamageStat(line.stat, line.value, accumulatedMainStatPct);\n        if (mapped.stat) {\n            if (mapped.isMainStatPct) {\n                slotService.add(mapped.stat, mapped.value);\n                accumulatedMainStatPct += line.value;\n            } else {\n                slotService.add(mapped.stat, mapped.value);\n            }\n        }\n    });\n\n    const slotDPS = slotService.computeDPS('boss');\n    return ((slotDPS - baseDPS) / baseDPS * 100);\n}\n\n/**\n * Calculate and display current recommendation\n */\nexport function calculateAndDisplayRecommendation(\n    cubeSlotData: Record<string, any>\n): GuidanceData | null {\n    const potentialType = guidanceState.potentialType;\n\n    // Get base stats for calculations\n    const baseStats = loadoutStore.getBaseStats();\n    const baseDPS = new StatCalculationService(baseStats).computeDPS('boss');\n\n    // Build current slots state from user data\n    const slots: SlotState[] = SLOT_NAMES.map(slotDef => {\n        const slotData = cubeSlotData[slotDef.id][potentialType];\n        return {\n            id: slotDef.id,\n            name: slotDef.name,\n            rarity: slotData.rarity,\n            rollCount: slotData.rollCount || 0,\n            dpsGain: calculateCurrentSlotDPSGain(slotDef.id, slotData)\n        };\n    });\n\n    // Find optimal slot\n    const { slot: recommendedSlot, marginalGain } = findOptimalSlotToCube(\n        slots,\n        baseStats,\n        baseDPS,\n        100 // Higher sample size for user-facing guidance\n    );\n\n    if (!recommendedSlot) {\n        displayNoRecommendation();\n        return null;\n    }\n\n    // Calculate full optimal sequence\n    const optimalSequence = calculateOptimalSequence(slots, baseStats, baseDPS);\n\n    // Display\n    displayRecommendation(recommendedSlot, marginalGain);\n    displayOptimalSequence(optimalSequence);\n\n    return {\n        recommendedSlot,\n        marginalGain,\n        optimalSequence\n    };\n}\n\n/**\n * Calculate optimal sequence for entire budget\n */\nfunction calculateOptimalSequence(\n    initialSlots: SlotState[],\n    baseStats: BaseStats,\n    baseDPS: number\n): OptimalSequenceStep[] {\n    const sequence: OptimalSequenceStep[] = [];\n    const simSlots: SlotState[] = JSON.parse(JSON.stringify(initialSlots)); // Deep copy\n\n    let currentSlotId: CubeSlotId | null = null;\n    let cubesOnCurrentSlot = 0;\n\n    for (let i = 0; i < guidanceState.cubeBudget; i++) {\n        const { slot } = findOptimalSlotToCube(simSlots, baseStats, baseDPS, 30);\n        if (!slot) break;\n\n        if (slot.id !== currentSlotId) {\n            if (currentSlotId !== null) {\n                const cumulativeDPS = simSlots.reduce((sum, s) => sum + s.dpsGain, 0);\n                sequence.push({\n                    slotId: currentSlotId,\n                    slotName: simSlots.find(s => s.id === currentSlotId)!.name,\n                    cubes: cubesOnCurrentSlot,\n                    cumulativeDPS\n                });\n            }\n            currentSlotId = slot.id;\n            cubesOnCurrentSlot = 0;\n        }\n\n        cubesOnCurrentSlot++;\n\n        // Simulate cube use\n        slot.rollCount = (slot.rollCount || 0) + 1;\n\n        const upgradeData = RARITY_UPGRADE_RATES[slot.rarity];\n        if (upgradeData) {\n            if (slot.rollCount >= upgradeData.max) {\n                slot.rarity = upgradeData.next;\n                slot.rollCount = 0;\n            } else if (Math.random() < upgradeData.rate) {\n                slot.rarity = upgradeData.next;\n                slot.rollCount = 0;\n            }\n        }\n\n        // Update dpsGain with expected value at new rarity\n        const sampledDPS = sampleExpectedDPSGain(slot.id, slot.rarity, baseStats, baseDPS);\n        slot.dpsGain = sampledDPS;\n    }\n\n    // Add final slot\n    if (currentSlotId !== null) {\n        const cumulativeDPS = simSlots.reduce((sum, s) => sum + s.dpsGain, 0);\n        sequence.push({\n            slotId: currentSlotId,\n            slotName: simSlots.find(s => s.id === currentSlotId)!.name,\n            cubes: cubesOnCurrentSlot,\n            cumulativeDPS\n        });\n    }\n\n    return sequence;\n}\n\n/**\n * Display no recommendation message\n */\nfunction displayNoRecommendation(): void {\n    const panel = document.getElementById('optimal-recommendation');\n    if (!panel) return;\n\n    panel.innerHTML = `\n        <div class=\"optimal-no-recommendation-card\">\n            <div style=\"font-size: 1.2em; color: var(--text-secondary);\">No recommendation available</div>\n            <div style=\"font-size: 0.9em; color: var(--text-secondary); margin-top: 8px;\">Please select a class first</div>\n        </div>\n    `;\n}\n\n/**\n * Display recommendation panel\n */\nfunction displayRecommendation(slot: SlotState, marginalGain: number): void {\n    const panel = document.getElementById('optimal-recommendation');\n    if (!panel) return;\n\n    const upgradeData = RARITY_UPGRADE_RATES[slot.rarity];\n    const rollsUntilPity = upgradeData ? (upgradeData.max - slot.rollCount) : 'N/A';\n\n    panel.innerHTML = `\n        <div class=\"optimal-recommendation-card\">\n            <div style=\"display: flex; justify-content: space-between; align-items: start;\">\n                <div>\n                    <div style=\"font-size: 0.85em; color: var(--text-secondary); margin-bottom: 4px;\">\n                        Recommended Next Slot\n                    </div>\n                    <div style=\"font-size: 1.8em; font-weight: 700; color: var(--accent-success);\">\n                        ${slot.name}\n                    </div>\n                    <div style=\"font-size: 0.9em; color: var(--text-secondary); margin-top: 8px;\">\n                        ${slot.rarity.charAt(0).toUpperCase() + slot.rarity.slice(1)} \u2022\n                        ${slot.rollCount} rolls \u2022\n                        ${typeof rollsUntilPity === 'number' ? rollsUntilPity : rollsUntilPity} until pity\n                    </div>\n                </div>\n                <div style=\"text-align: right;\">\n                    <div style=\"font-size: 0.85em; color: var(--text-secondary);\">Expected Gain</div>\n                    <div style=\"font-size: 1.5em; font-weight: 700; color: var(--accent-primary);\">\n                        +${marginalGain.toFixed(3)}%\n                    </div>\n                </div>\n            </div>\n        </div>\n    `;\n}\n\n/**\n * Display optimal sequence table\n */\nfunction displayOptimalSequence(sequence: OptimalSequenceStep[]): void {\n    const container = document.getElementById('optimal-sequence');\n    if (!container) return;\n\n    const totalCubes = sequence.reduce((sum, s) => sum + s.cubes, 0);\n\n    let html = `\n        <h4 style=\"color: var(--accent-primary); margin: 20px 0 15px;\">\n            Optimal Sequence (${totalCubes} cubes)\n        </h4>\n        <table class=\"stat-weight-table\">\n            <thead>\n                <tr>\n                    <th>Priority</th>\n                    <th>Slot</th>\n                    <th>Cubes</th>\n                    <th>Cumulative DPS</th>\n                </tr>\n            </thead>\n            <tbody>\n    `;\n\n    sequence.forEach((step, idx) => {\n        html += `\n            <tr>\n                <td style=\"font-weight: 600;\">${idx + 1}</td>\n                <td>${step.slotName}</td>\n                <td>${step.cubes}</td>\n                <td>+${step.cumulativeDPS.toFixed(2)}%</td>\n            </tr>\n        `;\n    });\n\n    html += '</tbody></table>';\n    container.innerHTML = html;\n}\n\n/**\n * Setup event listeners for optimal guidance tab\n */\nexport function setupOptimalGuidanceEventListeners(): void {\n    // Potential type selector\n    const potentialTypeSelect = document.getElementById('optimal-potential-type') as HTMLSelectElement;\n    if (potentialTypeSelect) {\n        potentialTypeSelect.addEventListener('change', (e) => {\n            guidanceState.potentialType = (e.target as HTMLSelectElement).value as 'regular' | 'bonus';\n            // Trigger recalculation via callback\n            const cubeSlotData = (window as any).cubeSlotData;\n            if (cubeSlotData) {\n                calculateAndDisplayRecommendation(cubeSlotData);\n            }\n        });\n    }\n\n    // Cube budget input\n    const budgetInput = document.getElementById('optimal-cube-budget') as HTMLInputElement;\n    if (budgetInput) {\n        budgetInput.addEventListener('change', (e) => {\n            const value = parseInt((e.target as HTMLInputElement).value) || 100;\n            guidanceState.cubeBudget = Math.max(1, Math.min(9999, value));\n            budgetInput.value = guidanceState.cubeBudget.toString();\n            localStorage.setItem('optimalGuidanceBudget', guidanceState.cubeBudget.toString());\n\n            // Trigger recalculation via callback\n            const cubeSlotData = (window as any).cubeSlotData;\n            if (cubeSlotData) {\n                calculateAndDisplayRecommendation(cubeSlotData);\n            }\n        });\n    }\n}\n\n/**\n * Get current guidance state\n */\nexport function getGuidanceState(): GuidanceState {\n    return { ...guidanceState };\n}\n\n/**\n * Update guidance state\n */\nexport function updateGuidanceState(updates: Partial<GuidanceState>): void {\n    guidanceState = { ...guidanceState, ...updates };\n}\n"],
  "mappings": "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",
  "names": []
}
