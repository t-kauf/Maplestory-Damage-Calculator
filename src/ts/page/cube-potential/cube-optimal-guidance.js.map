{
  "version": 3,
  "sources": ["cube-optimal-guidance.ts"],
  "sourcesContent": ["/**\r\n * Cube Optimal Guidance - Recommendation Engine and Optimal Strategy Display\r\n * Provides recommendations for optimal cube usage based on expected value\r\n */\r\n\r\nimport { StatCalculationService } from '@ts/services/stat-calculation-service.js';\r\nimport {\r\n    RARITY_UPGRADE_RATES,\r\n    SLOT_NAMES\r\n} from '@ts/page/cube-potential/cube-potential-data.js';\r\nimport { loadoutStore } from '@ts/store/loadout.store.js';\r\nimport { potentialStatToDamageStat } from '@ts/page/cube-potential/cube-potential.js';\r\nimport { findOptimalSlotToCube, sampleExpectedDPSGain } from './cube-expected-value.js';\r\nimport type { SlotState } from './cube-expected-value.js';\r\nimport type { BaseStats } from '@ts/types/loadout.js';\r\nimport type { CubeSlotId, Rarity, PotentialSet } from '@ts/types/page/gear-lab/gear-lab.types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface GuidanceState {\r\n    potentialType: 'regular' | 'bonus';\r\n    cubeBudget: number;\r\n}\r\n\r\nexport interface OptimalSequenceStep {\r\n    slotId: CubeSlotId;\r\n    slotName: string;\r\n    cubes: number;\r\n    cumulativeDPS: number;\r\n}\r\n\r\nexport interface GuidanceData {\r\n    recommendedSlot: SlotState | null;\r\n    marginalGain: number;\r\n    optimalSequence: OptimalSequenceStep[];\r\n}\r\n\r\n// ============================================================================\r\n// STATE\r\n// ============================================================================\r\n\r\nlet guidanceState: GuidanceState = {\r\n    potentialType: 'regular',\r\n    cubeBudget: 100\r\n};\r\n\r\n// ============================================================================\r\n// OPTIMAL GUIDANCE FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Initialize optimal guidance system\r\n */\r\nexport function initOptimalGuidance(): void {\r\n    loadGuidanceBudget();\r\n}\r\n\r\n/**\r\n * Load saved cube budget from localStorage\r\n */\r\nfunction loadGuidanceBudget(): void {\r\n    const saved = localStorage.getItem('optimalGuidanceBudget');\r\n    if (saved) {\r\n        guidanceState.cubeBudget = parseInt(saved) || 100;\r\n        const budgetInput = document.getElementById('optimal-cube-budget') as HTMLInputElement;\r\n        if (budgetInput) {\r\n            budgetInput.value = guidanceState.cubeBudget.toString();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Calculate current slot DPS gain\r\n */\r\nfunction calculateCurrentSlotDPSGain(slotId: CubeSlotId, slotData: { rarity: Rarity; setA: PotentialSet }): number {\r\n    const baseStats = loadoutStore.getBaseStats();\r\n    const baseDPS = new StatCalculationService(baseStats).computeDPS('boss');\r\n\r\n    const slotService = new StatCalculationService(baseStats);\r\n    let accumulatedMainStatPct = 0;\r\n\r\n    const lines = [\r\n        slotData.setA.line1,\r\n        slotData.setA.line2,\r\n        slotData.setA.line3\r\n    ];\r\n\r\n    lines.forEach(line => {\r\n        if (!line || !line.stat) return;\r\n        const mapped = potentialStatToDamageStat(line.stat, line.value, accumulatedMainStatPct);\r\n        if (mapped.stat) {\r\n            if (mapped.isMainStatPct) {\r\n                slotService.add(mapped.stat, mapped.value);\r\n                accumulatedMainStatPct += line.value;\r\n            } else {\r\n                slotService.add(mapped.stat, mapped.value);\r\n            }\r\n        }\r\n    });\r\n\r\n    const slotDPS = slotService.computeDPS('boss');\r\n    return ((slotDPS - baseDPS) / baseDPS * 100);\r\n}\r\n\r\n/**\r\n * Calculate and display current recommendation\r\n */\r\nexport function calculateAndDisplayRecommendation(\r\n    cubeSlotData: Record<string, any>\r\n): GuidanceData | null {\r\n    const potentialType = guidanceState.potentialType;\r\n\r\n    // Get base stats for calculations\r\n    const baseStats = loadoutStore.getBaseStats();\r\n    const baseDPS = new StatCalculationService(baseStats).computeDPS('boss');\r\n\r\n    // Build current slots state from user data\r\n    const slots: SlotState[] = SLOT_NAMES.map(slotDef => {\r\n        const slotData = cubeSlotData[slotDef.id][potentialType];\r\n        return {\r\n            id: slotDef.id,\r\n            name: slotDef.name,\r\n            rarity: slotData.rarity,\r\n            rollCount: slotData.rollCount || 0,\r\n            dpsGain: calculateCurrentSlotDPSGain(slotDef.id, slotData)\r\n        };\r\n    });\r\n\r\n    // Find optimal slot\r\n    const { slot: recommendedSlot, marginalGain } = findOptimalSlotToCube(\r\n        slots,\r\n        baseStats,\r\n        baseDPS,\r\n        100 // Higher sample size for user-facing guidance\r\n    );\r\n\r\n    if (!recommendedSlot) {\r\n        displayNoRecommendation();\r\n        return null;\r\n    }\r\n\r\n    // Calculate full optimal sequence\r\n    const optimalSequence = calculateOptimalSequence(slots, baseStats, baseDPS);\r\n\r\n    // Display\r\n    displayRecommendation(recommendedSlot, marginalGain);\r\n    displayOptimalSequence(optimalSequence);\r\n\r\n    return {\r\n        recommendedSlot,\r\n        marginalGain,\r\n        optimalSequence\r\n    };\r\n}\r\n\r\n/**\r\n * Calculate optimal sequence for entire budget\r\n */\r\nfunction calculateOptimalSequence(\r\n    initialSlots: SlotState[],\r\n    baseStats: BaseStats,\r\n    baseDPS: number\r\n): OptimalSequenceStep[] {\r\n    const sequence: OptimalSequenceStep[] = [];\r\n    const simSlots: SlotState[] = JSON.parse(JSON.stringify(initialSlots)); // Deep copy\r\n\r\n    let currentSlotId: CubeSlotId | null = null;\r\n    let cubesOnCurrentSlot = 0;\r\n\r\n    for (let i = 0; i < guidanceState.cubeBudget; i++) {\r\n        const { slot } = findOptimalSlotToCube(simSlots, baseStats, baseDPS, 30);\r\n        if (!slot) break;\r\n\r\n        if (slot.id !== currentSlotId) {\r\n            if (currentSlotId !== null) {\r\n                const cumulativeDPS = simSlots.reduce((sum, s) => sum + s.dpsGain, 0);\r\n                sequence.push({\r\n                    slotId: currentSlotId,\r\n                    slotName: simSlots.find(s => s.id === currentSlotId)!.name,\r\n                    cubes: cubesOnCurrentSlot,\r\n                    cumulativeDPS\r\n                });\r\n            }\r\n            currentSlotId = slot.id;\r\n            cubesOnCurrentSlot = 0;\r\n        }\r\n\r\n        cubesOnCurrentSlot++;\r\n\r\n        // Simulate cube use\r\n        slot.rollCount = (slot.rollCount || 0) + 1;\r\n\r\n        const upgradeData = RARITY_UPGRADE_RATES[slot.rarity];\r\n        if (upgradeData) {\r\n            if (slot.rollCount >= upgradeData.max) {\r\n                slot.rarity = upgradeData.next;\r\n                slot.rollCount = 0;\r\n            } else if (Math.random() < upgradeData.rate) {\r\n                slot.rarity = upgradeData.next;\r\n                slot.rollCount = 0;\r\n            }\r\n        }\r\n\r\n        // Update dpsGain with expected value at new rarity\r\n        const sampledDPS = sampleExpectedDPSGain(slot.id, slot.rarity, baseStats, baseDPS);\r\n        slot.dpsGain = sampledDPS;\r\n    }\r\n\r\n    // Add final slot\r\n    if (currentSlotId !== null) {\r\n        const cumulativeDPS = simSlots.reduce((sum, s) => sum + s.dpsGain, 0);\r\n        sequence.push({\r\n            slotId: currentSlotId,\r\n            slotName: simSlots.find(s => s.id === currentSlotId)!.name,\r\n            cubes: cubesOnCurrentSlot,\r\n            cumulativeDPS\r\n        });\r\n    }\r\n\r\n    return sequence;\r\n}\r\n\r\n/**\r\n * Display no recommendation message\r\n */\r\nfunction displayNoRecommendation(): void {\r\n    const panel = document.getElementById('optimal-recommendation');\r\n    if (!panel) return;\r\n\r\n    panel.innerHTML = `\r\n        <div class=\"optimal-no-recommendation-card\">\r\n            <div style=\"font-size: 1.2em; color: var(--text-secondary);\">No recommendation available</div>\r\n            <div style=\"font-size: 0.9em; color: var(--text-secondary); margin-top: 8px;\">Please select a class first</div>\r\n        </div>\r\n    `;\r\n}\r\n\r\n/**\r\n * Display recommendation panel\r\n */\r\nfunction displayRecommendation(slot: SlotState, marginalGain: number): void {\r\n    const panel = document.getElementById('optimal-recommendation');\r\n    if (!panel) return;\r\n\r\n    const upgradeData = RARITY_UPGRADE_RATES[slot.rarity];\r\n    const rollsUntilPity = upgradeData ? (upgradeData.max - slot.rollCount) : 'N/A';\r\n\r\n    panel.innerHTML = `\r\n        <div class=\"optimal-recommendation-card\">\r\n            <div style=\"display: flex; justify-content: space-between; align-items: start;\">\r\n                <div>\r\n                    <div style=\"font-size: 0.85em; color: var(--text-secondary); margin-bottom: 4px;\">\r\n                        Recommended Next Slot\r\n                    </div>\r\n                    <div style=\"font-size: 1.8em; font-weight: 700; color: var(--accent-success);\">\r\n                        ${slot.name}\r\n                    </div>\r\n                    <div style=\"font-size: 0.9em; color: var(--text-secondary); margin-top: 8px;\">\r\n                        ${slot.rarity.charAt(0).toUpperCase() + slot.rarity.slice(1)} \u2022\r\n                        ${slot.rollCount} rolls \u2022\r\n                        ${typeof rollsUntilPity === 'number' ? rollsUntilPity : rollsUntilPity} until pity\r\n                    </div>\r\n                </div>\r\n                <div style=\"text-align: right;\">\r\n                    <div style=\"font-size: 0.85em; color: var(--text-secondary);\">Expected Gain</div>\r\n                    <div style=\"font-size: 1.5em; font-weight: 700; color: var(--accent-primary);\">\r\n                        +${marginalGain.toFixed(3)}%\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    `;\r\n}\r\n\r\n/**\r\n * Display optimal sequence table\r\n */\r\nfunction displayOptimalSequence(sequence: OptimalSequenceStep[]): void {\r\n    const container = document.getElementById('optimal-sequence');\r\n    if (!container) return;\r\n\r\n    const totalCubes = sequence.reduce((sum, s) => sum + s.cubes, 0);\r\n\r\n    let html = `\r\n        <h4 style=\"color: var(--accent-primary); margin: 20px 0 15px;\">\r\n            Optimal Sequence (${totalCubes} cubes)\r\n        </h4>\r\n        <table class=\"stat-weight-table\">\r\n            <thead>\r\n                <tr>\r\n                    <th>Priority</th>\r\n                    <th>Slot</th>\r\n                    <th>Cubes</th>\r\n                    <th>Cumulative DPS</th>\r\n                </tr>\r\n            </thead>\r\n            <tbody>\r\n    `;\r\n\r\n    sequence.forEach((step, idx) => {\r\n        html += `\r\n            <tr>\r\n                <td style=\"font-weight: 600;\">${idx + 1}</td>\r\n                <td>${step.slotName}</td>\r\n                <td>${step.cubes}</td>\r\n                <td>+${step.cumulativeDPS.toFixed(2)}%</td>\r\n            </tr>\r\n        `;\r\n    });\r\n\r\n    html += '</tbody></table>';\r\n    container.innerHTML = html;\r\n}\r\n\r\n/**\r\n * Setup event listeners for optimal guidance tab\r\n */\r\nexport function setupOptimalGuidanceEventListeners(): void {\r\n    // Potential type selector\r\n    const potentialTypeSelect = document.getElementById('optimal-potential-type') as HTMLSelectElement;\r\n    if (potentialTypeSelect) {\r\n        potentialTypeSelect.addEventListener('change', (e) => {\r\n            guidanceState.potentialType = (e.target as HTMLSelectElement).value as 'regular' | 'bonus';\r\n            // Trigger recalculation via callback\r\n            const cubeSlotData = (window as any).cubeSlotData;\r\n            if (cubeSlotData) {\r\n                calculateAndDisplayRecommendation(cubeSlotData);\r\n            }\r\n        });\r\n    }\r\n\r\n    // Cube budget input\r\n    const budgetInput = document.getElementById('optimal-cube-budget') as HTMLInputElement;\r\n    if (budgetInput) {\r\n        budgetInput.addEventListener('change', (e) => {\r\n            const value = parseInt((e.target as HTMLInputElement).value) || 100;\r\n            guidanceState.cubeBudget = Math.max(1, Math.min(9999, value));\r\n            budgetInput.value = guidanceState.cubeBudget.toString();\r\n            localStorage.setItem('optimalGuidanceBudget', guidanceState.cubeBudget.toString());\r\n\r\n            // Trigger recalculation via callback\r\n            const cubeSlotData = (window as any).cubeSlotData;\r\n            if (cubeSlotData) {\r\n                calculateAndDisplayRecommendation(cubeSlotData);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Get current guidance state\r\n */\r\nexport function getGuidanceState(): GuidanceState {\r\n    return { ...guidanceState };\r\n}\r\n\r\n/**\r\n * Update guidance state\r\n */\r\nexport function updateGuidanceState(updates: Partial<GuidanceState>): void {\r\n    guidanceState = { ...guidanceState, ...updates };\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
