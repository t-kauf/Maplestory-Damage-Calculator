{
  "version": 3,
  "sources": ["cube-simulation.ts"],
  "sourcesContent": ["/**\r\n * Cube Simulation - Monte Carlo Simulation and Strategy Implementations\r\n * Simulates cube usage strategies to compare effectiveness\r\n */\r\n\r\nimport { StatCalculationService } from '@ts/services/stat-calculation-service.js';\r\nimport { loadoutStore } from '@ts/store/loadout.store.js';\r\nimport {\r\n    RARITY_UPGRADE_RATES,\r\n    EQUIPMENT_POTENTIAL_DATA,\r\n    SLOT_SPECIFIC_POTENTIALS,\r\n    SLOT_NAMES,\r\n    RARITIES\r\n} from '@ts/page/cube-potential/cube-potential-data.js';\r\nimport {\r\n    potentialStatToDamageStat,\r\n    rankingsCache,\r\n    rankingsInProgress,\r\n    type RankingEntry\r\n} from '@ts/page/cube-potential/cube-potential.js';\r\nimport { findOptimalSlotToCube, sampleExpectedDPSGain } from './cube-expected-value.js';\r\nimport type { CubeSlotId, Rarity, PotentialLineEntry, PotentialSet } from '@ts/types/page/gear-lab/gear-lab.types';\r\nimport type { BaseStats } from '@ts/types/loadout.js';\r\nimport type { SlotState } from './cube-expected-value.js';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface SimulationSlotState extends SlotState {\r\n    lines: (PotentialLineEntry | null)[];\r\n}\r\n\r\nexport interface SimulationResult {\r\n    totalGains: number[];\r\n    simulations: SimulationRunResult[];\r\n    avgGain: number;\r\n    slotDistribution: Record<string, number>;\r\n}\r\n\r\nexport interface SimulationRunResult {\r\n    slots: SimulationSlotState[];\r\n    totalGain: number;\r\n    decisionLog?: DecisionLogEntry[];\r\n    simulations?: SimulationRunResult[]; // For nested results in DP Optimal\r\n}\r\n\r\nexport interface DecisionLogEntry {\r\n    cubeNum: number;\r\n    slotId: CubeSlotId;\r\n    slotName: string;\r\n    marginalGain: number;\r\n    rarity: Rarity;\r\n    rollCount: number;\r\n    dpsBeforeCube: number;\r\n}\r\n\r\n// ============================================================================\r\n// STATE\r\n// ============================================================================\r\n\r\n/**\r\n * Batch size for progress updates during ranking calculation\r\n * Updates UI every N combinations processed\r\n */\r\nconst PROGRESS_UPDATE_BATCH_SIZE = 50;\r\n\r\n/**\r\n * Minimum DPS gain threshold (in %) for a combination to be included in rankings\r\n * Filters out negligible gains that don't meaningfully impact damage\r\n */\r\nconst MIN_GAIN_THRESHOLD = 0.01;\r\n\r\n/**\r\n * Simulation cache for performance optimization\r\n */\r\ninterface SimulationCache {\r\n    baseStats: BaseStats | null;\r\n    baseDPS: number | null;\r\n    lineOptionsCache: Record<string, LineOptionsCacheEntry>;\r\n    weightCache: Record<string, number>;\r\n}\r\n\r\ninterface LineOptionsCacheEntry {\r\n    line1: PotentialLineEntry[];\r\n    line2: PotentialLineEntry[];\r\n    line3: PotentialLineEntry[];\r\n}\r\n\r\nconst simCache: SimulationCache = {\r\n    baseStats: null,\r\n    baseDPS: null,\r\n    lineOptionsCache: {},\r\n    weightCache: {}\r\n};\r\n\r\n// ============================================================================\r\n// SIMULATION CORE\r\n// ============================================================================\r\n\r\n/**\r\n * Initialize simulation cache for performance\r\n */\r\nexport function initSimulationCache(baseStats: BaseStats): void {\r\n    simCache.baseStats = baseStats;\r\n    simCache.baseDPS = new StatCalculationService(baseStats).computeDPS('boss');\r\n    simCache.lineOptionsCache = {};\r\n    simCache.weightCache = {};\r\n\r\n    // Pre-calculate line options and weights for all slot+rarity combinations\r\n    SLOT_NAMES.forEach(slotDef => {\r\n        const slotId = slotDef.id;\r\n        RARITIES.forEach(rarity => {\r\n            const potentialData = EQUIPMENT_POTENTIAL_DATA[rarity as Rarity];\r\n            if (!potentialData) return;\r\n\r\n            const key = `${slotId}-${rarity}`;\r\n            const cached: LineOptionsCacheEntry = {\r\n                line1: [...(potentialData.line1 || [])],\r\n                line2: [...(potentialData.line2 || [])],\r\n                line3: [...(potentialData.line3 || [])]\r\n            };\r\n\r\n            // Add slot-specific lines\r\n            const slotSpecific = SLOT_SPECIFIC_POTENTIALS[slotId]?.[rarity as Rarity];\r\n            if (slotSpecific) {\r\n                if (slotSpecific.line1) cached.line1 = [...cached.line1, ...slotSpecific.line1];\r\n                if (slotSpecific.line2) cached.line2 = [...cached.line2, ...slotSpecific.line2];\r\n                if (slotSpecific.line3) cached.line3 = [...cached.line3, ...slotSpecific.line3];\r\n            }\r\n\r\n            simCache.lineOptionsCache[key] = cached;\r\n\r\n            // Pre-calculate total weights\r\n            simCache.weightCache[`${key}-1`] = cached.line1.reduce((sum, opt) => sum + opt.weight, 0);\r\n            simCache.weightCache[`${key}-2`] = cached.line2.reduce((sum, opt) => sum + opt.weight, 0);\r\n            simCache.weightCache[`${key}-3`] = cached.line3.reduce((sum, opt) => sum + opt.weight, 0);\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Helper function to get initial slot state\r\n * Either starts from user's current equipment data or from scratch\r\n */\r\nfunction getInitialSlotState(\r\n    useUserData: boolean,\r\n    potentialType: 'regular' | 'bonus',\r\n    cubeSlotData: Record<string, any>\r\n): SimulationSlotState[] {\r\n    if (useUserData) {\r\n        return SLOT_NAMES.map(slotDef => {\r\n            const slotData = cubeSlotData[slotDef.id][potentialType];\r\n            // Extract lines from setA\r\n            const lines = [\r\n                slotData.setA.line1?.stat ? slotData.setA.line1 : null,\r\n                slotData.setA.line2?.stat ? slotData.setA.line2 : null,\r\n                slotData.setA.line3?.stat ? slotData.setA.line3 : null\r\n            ];\r\n            return {\r\n                id: slotDef.id,\r\n                name: slotDef.name,\r\n                rarity: slotData.rarity,\r\n                rollCount: slotData.rollCount || 0,\r\n                lines: lines,\r\n                dpsGain: calculateExistingSlotDPSGain(slotDef.id, slotData)\r\n            };\r\n        });\r\n    } else {\r\n        return SLOT_NAMES.map(slotDef => ({\r\n            id: slotDef.id,\r\n            name: slotDef.name,\r\n            rarity: 'normal',\r\n            rollCount: 0,\r\n            lines: [null, null, null],\r\n            dpsGain: 0\r\n        }));\r\n    }\r\n}\r\n\r\n/**\r\n * Calculate DPS gain for existing slot data\r\n */\r\nfunction calculateExistingSlotDPSGain(slotId: CubeSlotId, slotData: { rarity: Rarity; setA: PotentialSet }): number {\r\n    if (!simCache.baseStats || simCache.baseDPS === null) {\r\n        throw new Error('Simulation cache not initialized');\r\n    }\r\n\r\n    const slotService = new StatCalculationService(simCache.baseStats);\r\n    let accumulatedMainStatPct = 0;\r\n\r\n    const lines = [\r\n        slotData.setA.line1,\r\n        slotData.setA.line2,\r\n        slotData.setA.line3\r\n    ];\r\n\r\n    lines.forEach(line => {\r\n        if (!line || !line.stat) return;\r\n        const mapped = potentialStatToDamageStat(line.stat, line.value, accumulatedMainStatPct);\r\n        if (mapped.stat) {\r\n            if (mapped.isMainStatPct) {\r\n                slotService.add(mapped.stat, mapped.value);\r\n                accumulatedMainStatPct += line.value;\r\n            } else {\r\n                slotService.add(mapped.stat, mapped.value);\r\n            }\r\n        }\r\n    });\r\n\r\n    const slotDPS = slotService.computeDPS('boss');\r\n    return ((slotDPS - simCache.baseDPS) / simCache.baseDPS * 100);\r\n}\r\n\r\n/**\r\n * Simulate using a single cube on a slot\r\n */\r\nexport function simulateCubeOnSlot(slot: SimulationSlotState): void {\r\n    if (!simCache.baseStats || simCache.baseDPS === null) {\r\n        throw new Error('Simulation cache not initialized');\r\n    }\r\n\r\n    // Increment roll count\r\n    slot.rollCount = (slot.rollCount || 0) + 1;\r\n\r\n    // Check for rarity upgrade with pity mechanics\r\n    const upgradeData = RARITY_UPGRADE_RATES[slot.rarity];\r\n    if (upgradeData) {\r\n        // Check pity first (guaranteed upgrade at max rolls)\r\n        if (slot.rollCount >= upgradeData.max) {\r\n            slot.rarity = upgradeData.next;\r\n            slot.rollCount = 0;\r\n        }\r\n        // Then check random upgrade\r\n        else if (Math.random() < upgradeData.rate) {\r\n            slot.rarity = upgradeData.next;\r\n            slot.rollCount = 0;\r\n        }\r\n    }\r\n\r\n    // Get cached line options\r\n    const key = `${slot.id}-${slot.rarity}`;\r\n    const lineOptions = simCache.lineOptionsCache[key];\r\n    if (!lineOptions) return;\r\n\r\n    // Roll each line based on weight using cached options\r\n    slot.lines = [\r\n        rollPotentialLineCached(lineOptions.line1, simCache.weightCache[`${key}-1`]),\r\n        rollPotentialLineCached(lineOptions.line2, simCache.weightCache[`${key}-2`]),\r\n        rollPotentialLineCached(lineOptions.line3, simCache.weightCache[`${key}-3`])\r\n    ];\r\n\r\n    // Calculate DPS gain for this slot\r\n    slot.dpsGain = calculateSlotDPSGainCached(slot);\r\n}\r\n\r\n/**\r\n * Roll a single potential line based on weights (optimized with cached total weight)\r\n */\r\nexport function rollPotentialLineCached(\r\n    options: PotentialLineEntry[],\r\n    totalWeight: number\r\n): PotentialLineEntry | null {\r\n    if (!options || options.length === 0) return null;\r\n\r\n    let random = Math.random() * totalWeight;\r\n\r\n    for (const option of options) {\r\n        random -= option.weight;\r\n        if (random <= 0) {\r\n            return option;\r\n        }\r\n    }\r\n\r\n    return options[options.length - 1];\r\n}\r\n\r\n/**\r\n * Calculate DPS gain for a single slot (optimized with cached base stats)\r\n */\r\nexport function calculateSlotDPSGainCached(slot: SimulationSlotState): number {\r\n    if (!simCache.baseStats || simCache.baseDPS === null) {\r\n        throw new Error('Simulation cache not initialized');\r\n    }\r\n\r\n    const slotService = new StatCalculationService(simCache.baseStats);\r\n    let accumulatedMainStatPct = 0;\r\n\r\n    if (slot.lines) {\r\n        for (const line of slot.lines) {\r\n            if (!line) continue;\r\n            const mapped = potentialStatToDamageStat(line.stat, line.value, accumulatedMainStatPct);\r\n            if (mapped.stat) {\r\n                if (mapped.isMainStatPct) {\r\n                    slotService.add(mapped.stat, mapped.value);\r\n                    accumulatedMainStatPct += line.value;\r\n                } else {\r\n                    slotService.add(mapped.stat, mapped.value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const slotDPS = slotService.computeDPS('boss');\r\n    return ((slotDPS - simCache.baseDPS) / simCache.baseDPS * 100);\r\n}\r\n\r\n/**\r\n * Calculate total DPS gain from all slots (optimized with cached base stats)\r\n */\r\nexport function calculateTotalDPSGain(slots: SimulationSlotState[]): number {\r\n    if (!simCache.baseStats || simCache.baseDPS === null) {\r\n        throw new Error('Simulation cache not initialized');\r\n    }\r\n\r\n    const totalService = new StatCalculationService(simCache.baseStats);\r\n    let accumulatedMainStatPct = 0;\r\n\r\n    for (const slot of slots) {\r\n        if (!slot.lines) continue;\r\n\r\n        for (const line of slot.lines) {\r\n            if (!line) continue;\r\n            const mapped = potentialStatToDamageStat(line.stat, line.value, accumulatedMainStatPct);\r\n            if (mapped.stat) {\r\n                if (mapped.isMainStatPct) {\r\n                    totalService.add(mapped.stat, mapped.value);\r\n                    accumulatedMainStatPct += line.value;\r\n                } else {\r\n                    totalService.add(mapped.stat, mapped.value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const totalDPS = totalService.computeDPS('boss');\r\n    return ((totalDPS - simCache.baseDPS) / simCache.baseDPS * 100);\r\n}\r\n\r\n/**\r\n * Calculate rankings for a specific slot and rarity\r\n * This function computes all possible combinations and ranks them by DPS gain\r\n */\r\nexport async function calculateRankingsForRarity(\r\n    rarity: Rarity,\r\n    slotId: CubeSlotId\r\n): Promise<void> {\r\n    const key = `${slotId}-${rarity}`;\r\n\r\n    try {\r\n        // Initialize slot cache if needed\r\n        if (!rankingsCache[slotId]) {\r\n            rankingsCache[slotId] = {} as any;\r\n        }\r\n\r\n        // Check if already calculated for this slot and rarity\r\n        if (rankingsCache[slotId][rarity]) {\r\n            return;\r\n        }\r\n\r\n        // Check if already calculating this combination\r\n        if (rankingsInProgress[key]) {\r\n            return; // Already calculating, skip\r\n        }\r\n\r\n        // Mark as in progress\r\n        rankingsInProgress[key] = true;\r\n\r\n        // Check if class is selected\r\n        if (!loadoutStore.getSelectedClass()) {\r\n            delete rankingsInProgress[key];\r\n            return;\r\n        }\r\n\r\n        const progressBar = document.getElementById('cube-rankings-progress') as HTMLElement;\r\n        const progressFill = document.getElementById('cube-rankings-progress-fill') as HTMLElement;\r\n        const progressText = document.getElementById('cube-rankings-progress-text') as HTMLElement;\r\n\r\n        // Show progress bar\r\n        if (progressBar) progressBar.style.display = 'block';\r\n        if (progressFill) progressFill.style.width = '0%';\r\n        if (progressText) progressText.textContent = 'Calculating... 0%';\r\n\r\n        const potentialData = EQUIPMENT_POTENTIAL_DATA[rarity];\r\n        if (!potentialData) {\r\n            if (progressBar) progressBar.style.display = 'none';\r\n            delete rankingsInProgress[key];\r\n            return;\r\n        }\r\n\r\n        // Get base potential lines\r\n        let line1Options = [...(potentialData.line1 || [])];\r\n        let line2Options = [...(potentialData.line2 || [])];\r\n        let line3Options = [...(potentialData.line3 || [])];\r\n\r\n        // Add slot-specific lines if available for current slot\r\n        if (SLOT_SPECIFIC_POTENTIALS[slotId] && SLOT_SPECIFIC_POTENTIALS[slotId][rarity]) {\r\n            const slotSpecific = SLOT_SPECIFIC_POTENTIALS[slotId][rarity];\r\n            if (slotSpecific.line1) {\r\n                line1Options = [...line1Options, ...slotSpecific.line1];\r\n            }\r\n            if (slotSpecific.line2) {\r\n                line2Options = [...line2Options, ...slotSpecific.line2];\r\n            }\r\n            if (slotSpecific.line3) {\r\n                line3Options = [...line3Options, ...slotSpecific.line3];\r\n            }\r\n        }\r\n\r\n        const totalCombinations = line1Options.length * line2Options.length * line3Options.length;\r\n        const rankings: RankingEntry[] = [];\r\n        const baseStats = loadoutStore.getBaseStats();\r\n        const baseService = new StatCalculationService(baseStats);\r\n        const baseDPS = baseService.computeDPS('boss');\r\n\r\n        // Reuse service instance to avoid redundant calculations\r\n        const comboService = new StatCalculationService(baseStats);\r\n\r\n        let processedCount = 0;\r\n\r\n        // Process in batches\r\n        for (let i = 0; i < line1Options.length; i++) {\r\n            for (let j = 0; j < line2Options.length; j++) {\r\n                for (let k = 0; k < line3Options.length; k++) {\r\n                    const combo = {\r\n                        line1: line1Options[i],\r\n                        line2: line2Options[j],\r\n                        line3: line3Options[k]\r\n                    };\r\n\r\n                    // Calculate stats for this combination using StatCalculationService\r\n                    comboService.reset();\r\n                    let accumulatedMainStatPct = 0;\r\n\r\n                    [combo.line1, combo.line2, combo.line3].forEach(line => {\r\n                        const mapped = potentialStatToDamageStat(line.stat, line.value, accumulatedMainStatPct);\r\n                        if (mapped.stat) {\r\n                            if (mapped.isMainStatPct) {\r\n                                comboService.add(mapped.stat, mapped.value);\r\n                                accumulatedMainStatPct += line.value;\r\n                            } else {\r\n                                comboService.add(mapped.stat, mapped.value);\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    const comboDPS = comboService.computeDPS('boss');\r\n                    const gain = ((comboDPS - baseDPS) / baseDPS * 100);\r\n\r\n                    rankings.push({\r\n                        line1: combo.line1,\r\n                        line2: combo.line2,\r\n                        line3: combo.line3,\r\n                        dpsGain: gain\r\n                    });\r\n\r\n                    processedCount++;\r\n\r\n                    // Update progress periodically\r\n                    if (processedCount % PROGRESS_UPDATE_BATCH_SIZE === 0) {\r\n                        const progress = (processedCount / totalCombinations * 100);\r\n\r\n                        if (progressFill) progressFill.style.width = `${progress}%`;\r\n                        if (progressText) progressText.textContent = `Calculating... ${Math.round(progress)}%`;\r\n\r\n                        // Allow UI to update\r\n                        await new Promise(resolve => setTimeout(resolve, 0));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Sort by DPS gain descending\r\n        rankings.sort((a, b) => b.dpsGain - a.dpsGain);\r\n\r\n        // Deduplicate: keep only unique combinations of lines (order doesn't matter)\r\n        // This ensures that [LineA, LineB, LineC] is treated the same as [LineC, LineA, LineB]\r\n        const seen = new Set<string>();\r\n        const deduplicatedRankings: RankingEntry[] = [];\r\n\r\n        for (const combo of rankings) {\r\n            // Create a canonical signature by sorting the 3 lines alphabetically\r\n            // This allows us to detect duplicate combinations regardless of order\r\n            const signature = [combo.line1, combo.line2, combo.line3]\r\n                .map(line => `${line.stat}|${line.value}|${line.prime}`)\r\n                .sort()\r\n                .join('||');\r\n\r\n            if (!seen.has(signature)) {\r\n                seen.add(signature);\r\n                deduplicatedRankings.push(combo);\r\n            }\r\n        }\r\n\r\n        // Filter out combinations with negligible DPS gain (< 0.01%)\r\n        // This prevents showing combinations that have no meaningful impact on damage\r\n        const filteredRankings = deduplicatedRankings.filter(combo => combo.dpsGain > MIN_GAIN_THRESHOLD);\r\n\r\n        // Cache the filtered results for this slot and rarity\r\n        rankingsCache[slotId][rarity] = filteredRankings;\r\n\r\n        // Hide progress bar\r\n        if (progressBar) {\r\n            progressBar.style.display = 'none';\r\n        }\r\n    } catch (error) {\r\n        console.error(`[${key}] Error calculating rankings:`, error);\r\n        const progressBar = document.getElementById('cube-rankings-progress') as HTMLElement;\r\n        if (progressBar) {\r\n            progressBar.style.display = 'none';\r\n        }\r\n    } finally {\r\n        // Always mark as complete and remove from in-progress tracker\r\n        delete rankingsInProgress[key];\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// STRATEGIES\r\n// ============================================================================\r\n\r\n/**\r\n * Strategy: Worst First - always upgrade the slot with lowest DPS\r\n */\r\nexport function runWorstFirstStrategy(\r\n    cubeBudget: number,\r\n    useUserData: boolean = false,\r\n    potentialType: 'regular' | 'bonus' = 'regular',\r\n    cubeSlotData: Record<string, any> = {}\r\n): SimulationSlotState[] {\r\n    const slots = getInitialSlotState(useUserData, potentialType, cubeSlotData);\r\n\r\n    // Use all cubes\r\n    for (let i = 0; i < cubeBudget; i++) {\r\n        // Find slot with lowest DPS gain\r\n        let worstSlot = slots[0];\r\n        for (const slot of slots) {\r\n            if (slot.dpsGain < worstSlot.dpsGain) {\r\n                worstSlot = slot;\r\n            }\r\n        }\r\n\r\n        // Use cube on worst slot\r\n        simulateCubeOnSlot(worstSlot);\r\n    }\r\n\r\n    return slots;\r\n}\r\n\r\n/**\r\n * Strategy: Balanced Threshold - keep all slots within a certain range of each other\r\n */\r\nexport function runBalancedThresholdStrategy(\r\n    cubeBudget: number,\r\n    useUserData: boolean = false,\r\n    potentialType: 'regular' | 'bonus' = 'regular',\r\n    cubeSlotData: Record<string, any> = {}\r\n): SimulationSlotState[] {\r\n    const slots = getInitialSlotState(useUserData, potentialType, cubeSlotData);\r\n\r\n    // Use all cubes\r\n    for (let i = 0; i < cubeBudget; i++) {\r\n        // Find the average DPS gain\r\n        const avgDPS = slots.reduce((sum, slot) => sum + slot.dpsGain, 0) / slots.length;\r\n\r\n        // Find slot that is furthest below average\r\n        let targetSlot = slots[0];\r\n        let maxDeficit = avgDPS - targetSlot.dpsGain;\r\n\r\n        for (const slot of slots) {\r\n            const deficit = avgDPS - slot.dpsGain;\r\n            if (deficit > maxDeficit) {\r\n                maxDeficit = deficit;\r\n                targetSlot = slot;\r\n            }\r\n        }\r\n\r\n        // Use cube on target slot\r\n        simulateCubeOnSlot(targetSlot);\r\n    }\r\n\r\n    return slots;\r\n}\r\n\r\n/**\r\n * Strategy: Rarity-Weighted Worst First - considers proximity to rarity upgrades\r\n */\r\nexport function runRarityWeightedWorstFirstStrategy(\r\n    cubeBudget: number,\r\n    useUserData: boolean = false,\r\n    potentialType: 'regular' | 'bonus' = 'regular',\r\n    cubeSlotData: Record<string, any> = {}\r\n): SimulationSlotState[] {\r\n    const slots = getInitialSlotState(useUserData, potentialType, cubeSlotData);\r\n\r\n    // Initialize cubesAtCurrentRarity from rollCount for each slot\r\n    slots.forEach(slot => {\r\n        slot.cubesAtCurrentRarity = slot.rollCount || 0;\r\n    });\r\n\r\n    const expectedCubesForUpgrade: Record<string, number> = {\r\n        'normal': 1 / 0.06,      // ~16.7 cubes\r\n        'rare': 1 / 0.03333,     // ~30 cubes\r\n        'epic': 1 / 0.0167,      // ~60 cubes\r\n        'unique': 1 / 0.006,     // ~167 cubes\r\n        'legendary': 1 / 0.0021  // ~476 cubes\r\n    };\r\n\r\n    // Use all cubes\r\n    for (let i = 0; i < cubeBudget; i++) {\r\n        // Calculate weighted score for each slot\r\n        let bestSlot = slots[0];\r\n        let bestScore = Infinity;\r\n\r\n        for (const slot of slots) {\r\n            // Lower DPS is worse (want to improve it)\r\n            let score = slot.dpsGain;\r\n\r\n            // If slot is close to upgrading, reduce its score (make it more attractive)\r\n            const expectedCubes = expectedCubesForUpgrade[slot.rarity];\r\n            if (expectedCubes) {\r\n                const upgradeProgress = (slot.cubesAtCurrentRarity || 0) / expectedCubes;\r\n                // Bonus for being close to upgrade (up to 50% reduction in score)\r\n                score = score * (1 - upgradeProgress * 0.5);\r\n            }\r\n\r\n            if (score < bestScore) {\r\n                bestScore = score;\r\n                bestSlot = slot;\r\n            }\r\n        }\r\n\r\n        // Track cubes used at current rarity\r\n        simulateCubeOnSlot(bestSlot);\r\n\r\n        // Update cubesAtCurrentRarity to match rollCount from simulateCubeOnSlot\r\n        bestSlot.cubesAtCurrentRarity = bestSlot.rollCount || 0;\r\n    }\r\n\r\n    return slots;\r\n}\r\n\r\n/**\r\n * Strategy: Hybrid Fast Rarity + Worst First\r\n */\r\nexport function runHybridFastRarityStrategy(\r\n    cubeBudget: number,\r\n    useUserData: boolean = false,\r\n    potentialType: 'regular' | 'bonus' = 'regular',\r\n    cubeSlotData: Record<string, any> = {}\r\n): SimulationSlotState[] {\r\n    const slots = getInitialSlotState(useUserData, potentialType, cubeSlotData);\r\n\r\n    let cubesUsed = 0;\r\n    const targetRarity: Rarity = 'epic'; // Get all slots to epic first\r\n    const rarityProgression: Rarity[] = ['rare', 'epic', 'unique', 'legendary', 'mystic'];\r\n\r\n    // Phase 1: Rush all slots to target rarity\r\n    for (const slot of slots) {\r\n        while (cubesUsed < cubeBudget && slot.rarity !== targetRarity) {\r\n            simulateCubeOnSlot(slot);\r\n            cubesUsed++;\r\n\r\n            // Check if we reached target\r\n            const currentIndex = rarityProgression.indexOf(slot.rarity);\r\n            const targetIndex = rarityProgression.indexOf(targetRarity);\r\n            if (currentIndex >= targetIndex) break;\r\n        }\r\n\r\n        if (cubesUsed >= cubeBudget) break;\r\n    }\r\n\r\n    // Phase 2: Use remaining cubes with Worst First strategy\r\n    while (cubesUsed < cubeBudget) {\r\n        // Find slot with lowest DPS gain\r\n        let worstSlot = slots[0];\r\n        for (const slot of slots) {\r\n            if (slot.dpsGain < worstSlot.dpsGain) {\r\n                worstSlot = slot;\r\n            }\r\n        }\r\n\r\n        simulateCubeOnSlot(worstSlot);\r\n        cubesUsed++;\r\n    }\r\n\r\n    return slots;\r\n}\r\n\r\n/**\r\n * DP Optimal Strategy\r\n * At each step, cubes the slot with highest expected marginal DPS gain\r\n * Uses Monte Carlo expected value with actual DPS calculations\r\n */\r\nexport function runDPOptimalStrategy(\r\n    cubeBudget: number,\r\n    useUserData: boolean = false,\r\n    potentialType: 'regular' | 'bonus' = 'regular',\r\n    cubeSlotData: Record<string, any> = {}\r\n): SimulationRunResult {\r\n    const slots = getInitialSlotState(useUserData, potentialType, cubeSlotData);\r\n    const decisionLog: DecisionLogEntry[] = [];\r\n\r\n    if (!simCache.baseStats || simCache.baseDPS === null) {\r\n        throw new Error('Simulation cache not initialized');\r\n    }\r\n\r\n    // Get base stats and DPS from cache\r\n    const baseStats = simCache.baseStats;\r\n    const baseDPS = simCache.baseDPS;\r\n\r\n    for (let cubeNum = 1; cubeNum <= cubeBudget; cubeNum++) {\r\n        // Find optimal slot using Monte Carlo expected value\r\n        const { slot: targetSlot, marginalGain } = findOptimalSlotToCube(\r\n            slots as SlotState[],\r\n            baseStats,\r\n            baseDPS,\r\n            30 // Sample size for simulation speed\r\n        );\r\n\r\n        if (!targetSlot) break;\r\n\r\n        // Log decision\r\n        decisionLog.push({\r\n            cubeNum,\r\n            slotId: targetSlot.id,\r\n            slotName: targetSlot.name,\r\n            marginalGain,\r\n            rarity: targetSlot.rarity,\r\n            rollCount: targetSlot.rollCount,\r\n            dpsBeforeCube: targetSlot.dpsGain\r\n        });\r\n\r\n        // Use cube on optimal slot\r\n        // simulateCubeOnSlot already updates slot.dpsGain\r\n        const simSlot = slots.find(s => s.id === targetSlot.id);\r\n        if (simSlot) {\r\n            simulateCubeOnSlot(simSlot);\r\n        }\r\n    }\r\n\r\n    return { slots, decisionLog, totalGain: 0, simulations: [] };\r\n}\r\n\r\n/**\r\n * Run complete simulation comparing all strategies\r\n */\r\nexport async function runCubeSimulation(\r\n    cubeBudget: number,\r\n    simulationCount: number,\r\n    potentialType: 'regular' | 'bonus',\r\n    useUserData: boolean,\r\n    cubeSlotData: Record<string, any>\r\n): Promise<Record<string, SimulationResult>> {\r\n    if (!loadoutStore.getSelectedClass()) {\r\n        throw new Error('Please select a class in the Character Setup section first.');\r\n    }\r\n\r\n    // Get base stats for initialization\r\n    const baseStats = cubeSlotData.baseStats;\r\n    if (!baseStats) {\r\n        throw new Error('Base stats not available');\r\n    }\r\n\r\n    // Initialize simulation cache\r\n    initSimulationCache(baseStats);\r\n\r\n    // Results storage\r\n    const results: Record<string, SimulationResult> = {\r\n        worstFirst: { totalGains: [], simulations: [], avgGain: 0, slotDistribution: {} },\r\n        balancedThreshold: { totalGains: [], simulations: [], avgGain: 0, slotDistribution: {} },\r\n        hybridFastRarity: { totalGains: [], simulations: [], avgGain: 0, slotDistribution: {} },\r\n        rarityWeightedWorstFirst: { totalGains: [], simulations: [], avgGain: 0, slotDistribution: {} },\r\n        dpOptimal: { totalGains: [], simulations: [], avgGain: 0, slotDistribution: {} }\r\n    };\r\n\r\n    // Run all simulations for all strategies\r\n    const allPromises: Promise<{ strategy: string; slots: SimulationSlotState[]; totalGain: number; decisionLog?: DecisionLogEntry[] }>[] = [];\r\n\r\n    for (let i = 0; i < simulationCount; i++) {\r\n        // Worst First\r\n        allPromises.push(\r\n            Promise.resolve({\r\n                strategy: 'worstFirst',\r\n                slots: runWorstFirstStrategy(cubeBudget, useUserData, potentialType, cubeSlotData),\r\n                totalGain: 0\r\n            }).then(result => ({\r\n                ...result,\r\n                totalGain: calculateTotalDPSGain(result.slots)\r\n            }))\r\n        );\r\n\r\n        // Balanced Threshold\r\n        allPromises.push(\r\n            Promise.resolve({\r\n                strategy: 'balancedThreshold',\r\n                slots: runBalancedThresholdStrategy(cubeBudget, useUserData, potentialType, cubeSlotData),\r\n                totalGain: 0\r\n            }).then(result => ({\r\n                ...result,\r\n                totalGain: calculateTotalDPSGain(result.slots)\r\n            }))\r\n        );\r\n\r\n        // Hybrid Fast Rarity\r\n        allPromises.push(\r\n            Promise.resolve({\r\n                strategy: 'hybridFastRarity',\r\n                slots: runHybridFastRarityStrategy(cubeBudget, useUserData, potentialType, cubeSlotData),\r\n                totalGain: 0\r\n            }).then(result => ({\r\n                ...result,\r\n                totalGain: calculateTotalDPSGain(result.slots)\r\n            }))\r\n        );\r\n\r\n        // Rarity-Weighted Worst First\r\n        allPromises.push(\r\n            Promise.resolve({\r\n                strategy: 'rarityWeightedWorstFirst',\r\n                slots: runRarityWeightedWorstFirstStrategy(cubeBudget, useUserData, potentialType, cubeSlotData),\r\n                totalGain: 0\r\n            }).then(result => ({\r\n                ...result,\r\n                totalGain: calculateTotalDPSGain(result.slots)\r\n            }))\r\n        );\r\n\r\n        // DP Optimal\r\n        const dpResult = runDPOptimalStrategy(cubeBudget, useUserData, potentialType, cubeSlotData);\r\n        allPromises.push(\r\n            Promise.resolve({\r\n                strategy: 'dpOptimal',\r\n                slots: dpResult.slots,\r\n                totalGain: calculateTotalDPSGain(dpResult.slots),\r\n                decisionLog: dpResult.decisionLog\r\n            })\r\n        );\r\n    }\r\n\r\n    // Process all promises\r\n    const batchSize = 50;\r\n    const totalSimulations = allPromises.length;\r\n    let completedSimulations = 0;\r\n\r\n    for (let i = 0; i < totalSimulations; i += batchSize) {\r\n        const batch = allPromises.slice(i, Math.min(i + batchSize, totalSimulations));\r\n        const batchResults = await Promise.all(batch);\r\n\r\n        // Distribute results to appropriate strategy\r\n        batchResults.forEach(result => {\r\n            const strategy = result.strategy;\r\n            if (results[strategy]) {\r\n                results[strategy].totalGains.push(result.totalGain);\r\n                results[strategy].simulations.push({\r\n                    slots: result.slots,\r\n                    totalGain: result.totalGain,\r\n                    decisionLog: result.decisionLog\r\n                });\r\n            }\r\n        });\r\n\r\n        completedSimulations += batch.length;\r\n    }\r\n\r\n    // Calculate averages for all strategies\r\n    Object.keys(results).forEach(strategy => {\r\n        results[strategy].avgGain = results[strategy].totalGains.reduce((a, b) => a + b, 0) / simulationCount;\r\n    });\r\n\r\n    return results;\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
