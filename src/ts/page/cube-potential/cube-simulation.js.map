{
  "version": 3,
  "sources": ["cube-simulation.ts"],
  "sourcesContent": ["/**\n * Cube Simulation - Monte Carlo Simulation and Strategy Implementations\n * Simulates cube usage strategies to compare effectiveness\n */\n\nimport { StatCalculationService } from '@ts/services/stat-calculation-service.js';\nimport { loadoutStore } from '@ts/store/loadout.store.js';\nimport {\n    RARITY_UPGRADE_RATES,\n    EQUIPMENT_POTENTIAL_DATA,\n    SLOT_SPECIFIC_POTENTIALS,\n    SLOT_NAMES,\n    RARITIES\n} from '@ts/page/cube-potential/cube-potential-data.js';\nimport {\n    potentialStatToDamageStat,\n    rankingsCache,\n    rankingsInProgress,\n    type RankingEntry\n} from '@ts/page/cube-potential/cube-potential.js';\nimport { findOptimalSlotToCube, sampleExpectedDPSGain } from './cube-expected-value.js';\nimport type { CubeSlotId, Rarity, PotentialLineEntry, PotentialSet } from '@ts/types/page/gear-lab/gear-lab.types';\nimport type { BaseStats } from '@ts/types/loadout.js';\nimport type { SlotState } from './cube-expected-value.js';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface SimulationSlotState extends SlotState {\n    lines: (PotentialLineEntry | null)[];\n}\n\nexport interface SimulationResult {\n    totalGains: number[];\n    simulations: SimulationRunResult[];\n    avgGain: number;\n    slotDistribution: Record<string, number>;\n}\n\nexport interface SimulationRunResult {\n    slots: SimulationSlotState[];\n    totalGain: number;\n    decisionLog?: DecisionLogEntry[];\n    simulations?: SimulationRunResult[]; // For nested results in DP Optimal\n}\n\nexport interface DecisionLogEntry {\n    cubeNum: number;\n    slotId: CubeSlotId;\n    slotName: string;\n    marginalGain: number;\n    rarity: Rarity;\n    rollCount: number;\n    dpsBeforeCube: number;\n}\n\n// ============================================================================\n// STATE\n// ============================================================================\n\n/**\n * Batch size for progress updates during ranking calculation\n * Updates UI every N combinations processed\n */\nconst PROGRESS_UPDATE_BATCH_SIZE = 50;\n\n/**\n * Minimum DPS gain threshold (in %) for a combination to be included in rankings\n * Filters out negligible gains that don't meaningfully impact damage\n */\nconst MIN_GAIN_THRESHOLD = 0.01;\n\n/**\n * Simulation cache for performance optimization\n */\ninterface SimulationCache {\n    baseStats: BaseStats | null;\n    baseDPS: number | null;\n    lineOptionsCache: Record<string, LineOptionsCacheEntry>;\n    weightCache: Record<string, number>;\n}\n\ninterface LineOptionsCacheEntry {\n    line1: PotentialLineEntry[];\n    line2: PotentialLineEntry[];\n    line3: PotentialLineEntry[];\n}\n\nconst simCache: SimulationCache = {\n    baseStats: null,\n    baseDPS: null,\n    lineOptionsCache: {},\n    weightCache: {}\n};\n\n// ============================================================================\n// SIMULATION CORE\n// ============================================================================\n\n/**\n * Initialize simulation cache for performance\n */\nexport function initSimulationCache(baseStats: BaseStats): void {\n    simCache.baseStats = baseStats;\n    simCache.baseDPS = new StatCalculationService(baseStats).computeDPS('boss');\n    simCache.lineOptionsCache = {};\n    simCache.weightCache = {};\n\n    // Pre-calculate line options and weights for all slot+rarity combinations\n    SLOT_NAMES.forEach(slotDef => {\n        const slotId = slotDef.id;\n        RARITIES.forEach(rarity => {\n            const potentialData = EQUIPMENT_POTENTIAL_DATA[rarity as Rarity];\n            if (!potentialData) return;\n\n            const key = `${slotId}-${rarity}`;\n            const cached: LineOptionsCacheEntry = {\n                line1: [...(potentialData.line1 || [])],\n                line2: [...(potentialData.line2 || [])],\n                line3: [...(potentialData.line3 || [])]\n            };\n\n            // Add slot-specific lines\n            const slotSpecific = SLOT_SPECIFIC_POTENTIALS[slotId]?.[rarity as Rarity];\n            if (slotSpecific) {\n                if (slotSpecific.line1) cached.line1 = [...cached.line1, ...slotSpecific.line1];\n                if (slotSpecific.line2) cached.line2 = [...cached.line2, ...slotSpecific.line2];\n                if (slotSpecific.line3) cached.line3 = [...cached.line3, ...slotSpecific.line3];\n            }\n\n            simCache.lineOptionsCache[key] = cached;\n\n            // Pre-calculate total weights\n            simCache.weightCache[`${key}-1`] = cached.line1.reduce((sum, opt) => sum + opt.weight, 0);\n            simCache.weightCache[`${key}-2`] = cached.line2.reduce((sum, opt) => sum + opt.weight, 0);\n            simCache.weightCache[`${key}-3`] = cached.line3.reduce((sum, opt) => sum + opt.weight, 0);\n        });\n    });\n}\n\n/**\n * Helper function to get initial slot state\n * Either starts from user's current equipment data or from scratch\n */\nfunction getInitialSlotState(\n    useUserData: boolean,\n    potentialType: 'regular' | 'bonus',\n    cubeSlotData: Record<string, any>\n): SimulationSlotState[] {\n    if (useUserData) {\n        return SLOT_NAMES.map(slotDef => {\n            const slotData = cubeSlotData[slotDef.id][potentialType];\n            // Extract lines from setA\n            const lines = [\n                slotData.setA.line1?.stat ? slotData.setA.line1 : null,\n                slotData.setA.line2?.stat ? slotData.setA.line2 : null,\n                slotData.setA.line3?.stat ? slotData.setA.line3 : null\n            ];\n            return {\n                id: slotDef.id,\n                name: slotDef.name,\n                rarity: slotData.rarity,\n                rollCount: slotData.rollCount || 0,\n                lines: lines,\n                dpsGain: calculateExistingSlotDPSGain(slotDef.id, slotData)\n            };\n        });\n    } else {\n        return SLOT_NAMES.map(slotDef => ({\n            id: slotDef.id,\n            name: slotDef.name,\n            rarity: 'normal',\n            rollCount: 0,\n            lines: [null, null, null],\n            dpsGain: 0\n        }));\n    }\n}\n\n/**\n * Calculate DPS gain for existing slot data\n */\nfunction calculateExistingSlotDPSGain(slotId: CubeSlotId, slotData: { rarity: Rarity; setA: PotentialSet }): number {\n    if (!simCache.baseStats || simCache.baseDPS === null) {\n        throw new Error('Simulation cache not initialized');\n    }\n\n    const slotService = new StatCalculationService(simCache.baseStats);\n    let accumulatedMainStatPct = 0;\n\n    const lines = [\n        slotData.setA.line1,\n        slotData.setA.line2,\n        slotData.setA.line3\n    ];\n\n    lines.forEach(line => {\n        if (!line || !line.stat) return;\n        const mapped = potentialStatToDamageStat(line.stat, line.value, accumulatedMainStatPct);\n        if (mapped.stat) {\n            if (mapped.isMainStatPct) {\n                slotService.add(mapped.stat, mapped.value);\n                accumulatedMainStatPct += line.value;\n            } else {\n                slotService.add(mapped.stat, mapped.value);\n            }\n        }\n    });\n\n    const slotDPS = slotService.computeDPS('boss');\n    return ((slotDPS - simCache.baseDPS) / simCache.baseDPS * 100);\n}\n\n/**\n * Simulate using a single cube on a slot\n */\nexport function simulateCubeOnSlot(slot: SimulationSlotState): void {\n    if (!simCache.baseStats || simCache.baseDPS === null) {\n        throw new Error('Simulation cache not initialized');\n    }\n\n    // Increment roll count\n    slot.rollCount = (slot.rollCount || 0) + 1;\n\n    // Check for rarity upgrade with pity mechanics\n    const upgradeData = RARITY_UPGRADE_RATES[slot.rarity];\n    if (upgradeData) {\n        // Check pity first (guaranteed upgrade at max rolls)\n        if (slot.rollCount >= upgradeData.max) {\n            slot.rarity = upgradeData.next;\n            slot.rollCount = 0;\n        }\n        // Then check random upgrade\n        else if (Math.random() < upgradeData.rate) {\n            slot.rarity = upgradeData.next;\n            slot.rollCount = 0;\n        }\n    }\n\n    // Get cached line options\n    const key = `${slot.id}-${slot.rarity}`;\n    const lineOptions = simCache.lineOptionsCache[key];\n    if (!lineOptions) return;\n\n    // Roll each line based on weight using cached options\n    slot.lines = [\n        rollPotentialLineCached(lineOptions.line1, simCache.weightCache[`${key}-1`]),\n        rollPotentialLineCached(lineOptions.line2, simCache.weightCache[`${key}-2`]),\n        rollPotentialLineCached(lineOptions.line3, simCache.weightCache[`${key}-3`])\n    ];\n\n    // Calculate DPS gain for this slot\n    slot.dpsGain = calculateSlotDPSGainCached(slot);\n}\n\n/**\n * Roll a single potential line based on weights (optimized with cached total weight)\n */\nexport function rollPotentialLineCached(\n    options: PotentialLineEntry[],\n    totalWeight: number\n): PotentialLineEntry | null {\n    if (!options || options.length === 0) return null;\n\n    let random = Math.random() * totalWeight;\n\n    for (const option of options) {\n        random -= option.weight;\n        if (random <= 0) {\n            return option;\n        }\n    }\n\n    return options[options.length - 1];\n}\n\n/**\n * Calculate DPS gain for a single slot (optimized with cached base stats)\n */\nexport function calculateSlotDPSGainCached(slot: SimulationSlotState): number {\n    if (!simCache.baseStats || simCache.baseDPS === null) {\n        throw new Error('Simulation cache not initialized');\n    }\n\n    const slotService = new StatCalculationService(simCache.baseStats);\n    let accumulatedMainStatPct = 0;\n\n    if (slot.lines) {\n        for (const line of slot.lines) {\n            if (!line) continue;\n            const mapped = potentialStatToDamageStat(line.stat, line.value, accumulatedMainStatPct);\n            if (mapped.stat) {\n                if (mapped.isMainStatPct) {\n                    slotService.add(mapped.stat, mapped.value);\n                    accumulatedMainStatPct += line.value;\n                } else {\n                    slotService.add(mapped.stat, mapped.value);\n                }\n            }\n        }\n    }\n\n    const slotDPS = slotService.computeDPS('boss');\n    return ((slotDPS - simCache.baseDPS) / simCache.baseDPS * 100);\n}\n\n/**\n * Calculate total DPS gain from all slots (optimized with cached base stats)\n */\nexport function calculateTotalDPSGain(slots: SimulationSlotState[]): number {\n    if (!simCache.baseStats || simCache.baseDPS === null) {\n        throw new Error('Simulation cache not initialized');\n    }\n\n    const totalService = new StatCalculationService(simCache.baseStats);\n    let accumulatedMainStatPct = 0;\n\n    for (const slot of slots) {\n        if (!slot.lines) continue;\n\n        for (const line of slot.lines) {\n            if (!line) continue;\n            const mapped = potentialStatToDamageStat(line.stat, line.value, accumulatedMainStatPct);\n            if (mapped.stat) {\n                if (mapped.isMainStatPct) {\n                    totalService.add(mapped.stat, mapped.value);\n                    accumulatedMainStatPct += line.value;\n                } else {\n                    totalService.add(mapped.stat, mapped.value);\n                }\n            }\n        }\n    }\n\n    const totalDPS = totalService.computeDPS('boss');\n    return ((totalDPS - simCache.baseDPS) / simCache.baseDPS * 100);\n}\n\n/**\n * Calculate rankings for a specific slot and rarity\n * This function computes all possible combinations and ranks them by DPS gain\n */\nexport async function calculateRankingsForRarity(\n    rarity: Rarity,\n    slotId: CubeSlotId\n): Promise<void> {\n    const key = `${slotId}-${rarity}`;\n\n    try {\n        // Initialize slot cache if needed\n        if (!rankingsCache[slotId]) {\n            rankingsCache[slotId] = {} as any;\n        }\n\n        // Check if already calculated for this slot and rarity\n        if (rankingsCache[slotId][rarity]) {\n            return;\n        }\n\n        // Check if already calculating this combination\n        if (rankingsInProgress[key]) {\n            return; // Already calculating, skip\n        }\n\n        // Mark as in progress\n        rankingsInProgress[key] = true;\n\n        // Check if class is selected\n        if (!loadoutStore.getSelectedClass()) {\n            delete rankingsInProgress[key];\n            return;\n        }\n\n        const progressBar = document.getElementById('cube-rankings-progress') as HTMLElement;\n        const progressFill = document.getElementById('cube-rankings-progress-fill') as HTMLElement;\n        const progressText = document.getElementById('cube-rankings-progress-text') as HTMLElement;\n\n        // Show progress bar\n        if (progressBar) progressBar.style.display = 'block';\n        if (progressFill) progressFill.style.width = '0%';\n        if (progressText) progressText.textContent = 'Calculating... 0%';\n\n        const potentialData = EQUIPMENT_POTENTIAL_DATA[rarity];\n        if (!potentialData) {\n            if (progressBar) progressBar.style.display = 'none';\n            delete rankingsInProgress[key];\n            return;\n        }\n\n        // Get base potential lines\n        let line1Options = [...(potentialData.line1 || [])];\n        let line2Options = [...(potentialData.line2 || [])];\n        let line3Options = [...(potentialData.line3 || [])];\n\n        // Add slot-specific lines if available for current slot\n        if (SLOT_SPECIFIC_POTENTIALS[slotId] && SLOT_SPECIFIC_POTENTIALS[slotId][rarity]) {\n            const slotSpecific = SLOT_SPECIFIC_POTENTIALS[slotId][rarity];\n            if (slotSpecific.line1) {\n                line1Options = [...line1Options, ...slotSpecific.line1];\n            }\n            if (slotSpecific.line2) {\n                line2Options = [...line2Options, ...slotSpecific.line2];\n            }\n            if (slotSpecific.line3) {\n                line3Options = [...line3Options, ...slotSpecific.line3];\n            }\n        }\n\n        const totalCombinations = line1Options.length * line2Options.length * line3Options.length;\n        const rankings: RankingEntry[] = [];\n        const baseStats = loadoutStore.getBaseStats();\n        const baseService = new StatCalculationService(baseStats);\n        const baseDPS = baseService.computeDPS('boss');\n\n        // Reuse service instance to avoid redundant calculations\n        const comboService = new StatCalculationService(baseStats);\n\n        let processedCount = 0;\n\n        // Process in batches\n        for (let i = 0; i < line1Options.length; i++) {\n            for (let j = 0; j < line2Options.length; j++) {\n                for (let k = 0; k < line3Options.length; k++) {\n                    const combo = {\n                        line1: line1Options[i],\n                        line2: line2Options[j],\n                        line3: line3Options[k]\n                    };\n\n                    // Calculate stats for this combination using StatCalculationService\n                    comboService.reset();\n                    let accumulatedMainStatPct = 0;\n\n                    [combo.line1, combo.line2, combo.line3].forEach(line => {\n                        const mapped = potentialStatToDamageStat(line.stat, line.value, accumulatedMainStatPct);\n                        if (mapped.stat) {\n                            if (mapped.isMainStatPct) {\n                                comboService.add(mapped.stat, mapped.value);\n                                accumulatedMainStatPct += line.value;\n                            } else {\n                                comboService.add(mapped.stat, mapped.value);\n                            }\n                        }\n                    });\n\n                    const comboDPS = comboService.computeDPS('boss');\n                    const gain = ((comboDPS - baseDPS) / baseDPS * 100);\n\n                    rankings.push({\n                        line1: combo.line1,\n                        line2: combo.line2,\n                        line3: combo.line3,\n                        dpsGain: gain\n                    });\n\n                    processedCount++;\n\n                    // Update progress periodically\n                    if (processedCount % PROGRESS_UPDATE_BATCH_SIZE === 0) {\n                        const progress = (processedCount / totalCombinations * 100);\n\n                        if (progressFill) progressFill.style.width = `${progress}%`;\n                        if (progressText) progressText.textContent = `Calculating... ${Math.round(progress)}%`;\n\n                        // Allow UI to update\n                        await new Promise(resolve => setTimeout(resolve, 0));\n                    }\n                }\n            }\n        }\n\n        // Sort by DPS gain descending\n        rankings.sort((a, b) => b.dpsGain - a.dpsGain);\n\n        // Deduplicate: keep only unique combinations of lines (order doesn't matter)\n        // This ensures that [LineA, LineB, LineC] is treated the same as [LineC, LineA, LineB]\n        const seen = new Set<string>();\n        const deduplicatedRankings: RankingEntry[] = [];\n\n        for (const combo of rankings) {\n            // Create a canonical signature by sorting the 3 lines alphabetically\n            // This allows us to detect duplicate combinations regardless of order\n            const signature = [combo.line1, combo.line2, combo.line3]\n                .map(line => `${line.stat}|${line.value}|${line.prime}`)\n                .sort()\n                .join('||');\n\n            if (!seen.has(signature)) {\n                seen.add(signature);\n                deduplicatedRankings.push(combo);\n            }\n        }\n\n        // Filter out combinations with negligible DPS gain (< 0.01%)\n        // This prevents showing combinations that have no meaningful impact on damage\n        const filteredRankings = deduplicatedRankings.filter(combo => combo.dpsGain > MIN_GAIN_THRESHOLD);\n\n        // Cache the filtered results for this slot and rarity\n        rankingsCache[slotId][rarity] = filteredRankings;\n\n        // Hide progress bar\n        if (progressBar) {\n            progressBar.style.display = 'none';\n        }\n    } catch (error) {\n        console.error(`[${key}] Error calculating rankings:`, error);\n        const progressBar = document.getElementById('cube-rankings-progress') as HTMLElement;\n        if (progressBar) {\n            progressBar.style.display = 'none';\n        }\n    } finally {\n        // Always mark as complete and remove from in-progress tracker\n        delete rankingsInProgress[key];\n    }\n}\n\n// ============================================================================\n// STRATEGIES\n// ============================================================================\n\n/**\n * Strategy: Worst First - always upgrade the slot with lowest DPS\n */\nexport function runWorstFirstStrategy(\n    cubeBudget: number,\n    useUserData: boolean = false,\n    potentialType: 'regular' | 'bonus' = 'regular',\n    cubeSlotData: Record<string, any> = {}\n): SimulationSlotState[] {\n    const slots = getInitialSlotState(useUserData, potentialType, cubeSlotData);\n\n    // Use all cubes\n    for (let i = 0; i < cubeBudget; i++) {\n        // Find slot with lowest DPS gain\n        let worstSlot = slots[0];\n        for (const slot of slots) {\n            if (slot.dpsGain < worstSlot.dpsGain) {\n                worstSlot = slot;\n            }\n        }\n\n        // Use cube on worst slot\n        simulateCubeOnSlot(worstSlot);\n    }\n\n    return slots;\n}\n\n/**\n * Strategy: Balanced Threshold - keep all slots within a certain range of each other\n */\nexport function runBalancedThresholdStrategy(\n    cubeBudget: number,\n    useUserData: boolean = false,\n    potentialType: 'regular' | 'bonus' = 'regular',\n    cubeSlotData: Record<string, any> = {}\n): SimulationSlotState[] {\n    const slots = getInitialSlotState(useUserData, potentialType, cubeSlotData);\n\n    // Use all cubes\n    for (let i = 0; i < cubeBudget; i++) {\n        // Find the average DPS gain\n        const avgDPS = slots.reduce((sum, slot) => sum + slot.dpsGain, 0) / slots.length;\n\n        // Find slot that is furthest below average\n        let targetSlot = slots[0];\n        let maxDeficit = avgDPS - targetSlot.dpsGain;\n\n        for (const slot of slots) {\n            const deficit = avgDPS - slot.dpsGain;\n            if (deficit > maxDeficit) {\n                maxDeficit = deficit;\n                targetSlot = slot;\n            }\n        }\n\n        // Use cube on target slot\n        simulateCubeOnSlot(targetSlot);\n    }\n\n    return slots;\n}\n\n/**\n * Strategy: Rarity-Weighted Worst First - considers proximity to rarity upgrades\n */\nexport function runRarityWeightedWorstFirstStrategy(\n    cubeBudget: number,\n    useUserData: boolean = false,\n    potentialType: 'regular' | 'bonus' = 'regular',\n    cubeSlotData: Record<string, any> = {}\n): SimulationSlotState[] {\n    const slots = getInitialSlotState(useUserData, potentialType, cubeSlotData);\n\n    // Initialize cubesAtCurrentRarity from rollCount for each slot\n    slots.forEach(slot => {\n        slot.cubesAtCurrentRarity = slot.rollCount || 0;\n    });\n\n    const expectedCubesForUpgrade: Record<string, number> = {\n        'normal': 1 / 0.06,      // ~16.7 cubes\n        'rare': 1 / 0.03333,     // ~30 cubes\n        'epic': 1 / 0.0167,      // ~60 cubes\n        'unique': 1 / 0.006,     // ~167 cubes\n        'legendary': 1 / 0.0021  // ~476 cubes\n    };\n\n    // Use all cubes\n    for (let i = 0; i < cubeBudget; i++) {\n        // Calculate weighted score for each slot\n        let bestSlot = slots[0];\n        let bestScore = Infinity;\n\n        for (const slot of slots) {\n            // Lower DPS is worse (want to improve it)\n            let score = slot.dpsGain;\n\n            // If slot is close to upgrading, reduce its score (make it more attractive)\n            const expectedCubes = expectedCubesForUpgrade[slot.rarity];\n            if (expectedCubes) {\n                const upgradeProgress = (slot.cubesAtCurrentRarity || 0) / expectedCubes;\n                // Bonus for being close to upgrade (up to 50% reduction in score)\n                score = score * (1 - upgradeProgress * 0.5);\n            }\n\n            if (score < bestScore) {\n                bestScore = score;\n                bestSlot = slot;\n            }\n        }\n\n        // Track cubes used at current rarity\n        simulateCubeOnSlot(bestSlot);\n\n        // Update cubesAtCurrentRarity to match rollCount from simulateCubeOnSlot\n        bestSlot.cubesAtCurrentRarity = bestSlot.rollCount || 0;\n    }\n\n    return slots;\n}\n\n/**\n * Strategy: Hybrid Fast Rarity + Worst First\n */\nexport function runHybridFastRarityStrategy(\n    cubeBudget: number,\n    useUserData: boolean = false,\n    potentialType: 'regular' | 'bonus' = 'regular',\n    cubeSlotData: Record<string, any> = {}\n): SimulationSlotState[] {\n    const slots = getInitialSlotState(useUserData, potentialType, cubeSlotData);\n\n    let cubesUsed = 0;\n    const targetRarity: Rarity = 'epic'; // Get all slots to epic first\n    const rarityProgression: Rarity[] = ['rare', 'epic', 'unique', 'legendary', 'mystic'];\n\n    // Phase 1: Rush all slots to target rarity\n    for (const slot of slots) {\n        while (cubesUsed < cubeBudget && slot.rarity !== targetRarity) {\n            simulateCubeOnSlot(slot);\n            cubesUsed++;\n\n            // Check if we reached target\n            const currentIndex = rarityProgression.indexOf(slot.rarity);\n            const targetIndex = rarityProgression.indexOf(targetRarity);\n            if (currentIndex >= targetIndex) break;\n        }\n\n        if (cubesUsed >= cubeBudget) break;\n    }\n\n    // Phase 2: Use remaining cubes with Worst First strategy\n    while (cubesUsed < cubeBudget) {\n        // Find slot with lowest DPS gain\n        let worstSlot = slots[0];\n        for (const slot of slots) {\n            if (slot.dpsGain < worstSlot.dpsGain) {\n                worstSlot = slot;\n            }\n        }\n\n        simulateCubeOnSlot(worstSlot);\n        cubesUsed++;\n    }\n\n    return slots;\n}\n\n/**\n * DP Optimal Strategy\n * At each step, cubes the slot with highest expected marginal DPS gain\n * Uses Monte Carlo expected value with actual DPS calculations\n */\nexport function runDPOptimalStrategy(\n    cubeBudget: number,\n    useUserData: boolean = false,\n    potentialType: 'regular' | 'bonus' = 'regular',\n    cubeSlotData: Record<string, any> = {}\n): SimulationRunResult {\n    const slots = getInitialSlotState(useUserData, potentialType, cubeSlotData);\n    const decisionLog: DecisionLogEntry[] = [];\n\n    if (!simCache.baseStats || simCache.baseDPS === null) {\n        throw new Error('Simulation cache not initialized');\n    }\n\n    // Get base stats and DPS from cache\n    const baseStats = simCache.baseStats;\n    const baseDPS = simCache.baseDPS;\n\n    for (let cubeNum = 1; cubeNum <= cubeBudget; cubeNum++) {\n        // Find optimal slot using Monte Carlo expected value\n        const { slot: targetSlot, marginalGain } = findOptimalSlotToCube(\n            slots as SlotState[],\n            baseStats,\n            baseDPS,\n            30 // Sample size for simulation speed\n        );\n\n        if (!targetSlot) break;\n\n        // Log decision\n        decisionLog.push({\n            cubeNum,\n            slotId: targetSlot.id,\n            slotName: targetSlot.name,\n            marginalGain,\n            rarity: targetSlot.rarity,\n            rollCount: targetSlot.rollCount,\n            dpsBeforeCube: targetSlot.dpsGain\n        });\n\n        // Use cube on optimal slot\n        // simulateCubeOnSlot already updates slot.dpsGain\n        const simSlot = slots.find(s => s.id === targetSlot.id);\n        if (simSlot) {\n            simulateCubeOnSlot(simSlot);\n        }\n    }\n\n    return { slots, decisionLog, totalGain: 0, simulations: [] };\n}\n\n/**\n * Run complete simulation comparing all strategies\n */\nexport async function runCubeSimulation(\n    cubeBudget: number,\n    simulationCount: number,\n    potentialType: 'regular' | 'bonus',\n    useUserData: boolean,\n    cubeSlotData: Record<string, any>\n): Promise<Record<string, SimulationResult>> {\n    if (!loadoutStore.getSelectedClass()) {\n        throw new Error('Please select a class in the Character Setup section first.');\n    }\n\n    // Get base stats for initialization\n    const baseStats = cubeSlotData.baseStats;\n    if (!baseStats) {\n        throw new Error('Base stats not available');\n    }\n\n    // Initialize simulation cache\n    initSimulationCache(baseStats);\n\n    // Results storage\n    const results: Record<string, SimulationResult> = {\n        worstFirst: { totalGains: [], simulations: [], avgGain: 0, slotDistribution: {} },\n        balancedThreshold: { totalGains: [], simulations: [], avgGain: 0, slotDistribution: {} },\n        hybridFastRarity: { totalGains: [], simulations: [], avgGain: 0, slotDistribution: {} },\n        rarityWeightedWorstFirst: { totalGains: [], simulations: [], avgGain: 0, slotDistribution: {} },\n        dpOptimal: { totalGains: [], simulations: [], avgGain: 0, slotDistribution: {} }\n    };\n\n    // Run all simulations for all strategies\n    const allPromises: Promise<{ strategy: string; slots: SimulationSlotState[]; totalGain: number; decisionLog?: DecisionLogEntry[] }>[] = [];\n\n    for (let i = 0; i < simulationCount; i++) {\n        // Worst First\n        allPromises.push(\n            Promise.resolve({\n                strategy: 'worstFirst',\n                slots: runWorstFirstStrategy(cubeBudget, useUserData, potentialType, cubeSlotData),\n                totalGain: 0\n            }).then(result => ({\n                ...result,\n                totalGain: calculateTotalDPSGain(result.slots)\n            }))\n        );\n\n        // Balanced Threshold\n        allPromises.push(\n            Promise.resolve({\n                strategy: 'balancedThreshold',\n                slots: runBalancedThresholdStrategy(cubeBudget, useUserData, potentialType, cubeSlotData),\n                totalGain: 0\n            }).then(result => ({\n                ...result,\n                totalGain: calculateTotalDPSGain(result.slots)\n            }))\n        );\n\n        // Hybrid Fast Rarity\n        allPromises.push(\n            Promise.resolve({\n                strategy: 'hybridFastRarity',\n                slots: runHybridFastRarityStrategy(cubeBudget, useUserData, potentialType, cubeSlotData),\n                totalGain: 0\n            }).then(result => ({\n                ...result,\n                totalGain: calculateTotalDPSGain(result.slots)\n            }))\n        );\n\n        // Rarity-Weighted Worst First\n        allPromises.push(\n            Promise.resolve({\n                strategy: 'rarityWeightedWorstFirst',\n                slots: runRarityWeightedWorstFirstStrategy(cubeBudget, useUserData, potentialType, cubeSlotData),\n                totalGain: 0\n            }).then(result => ({\n                ...result,\n                totalGain: calculateTotalDPSGain(result.slots)\n            }))\n        );\n\n        // DP Optimal\n        const dpResult = runDPOptimalStrategy(cubeBudget, useUserData, potentialType, cubeSlotData);\n        allPromises.push(\n            Promise.resolve({\n                strategy: 'dpOptimal',\n                slots: dpResult.slots,\n                totalGain: calculateTotalDPSGain(dpResult.slots),\n                decisionLog: dpResult.decisionLog\n            })\n        );\n    }\n\n    // Process all promises\n    const batchSize = 50;\n    const totalSimulations = allPromises.length;\n    let completedSimulations = 0;\n\n    for (let i = 0; i < totalSimulations; i += batchSize) {\n        const batch = allPromises.slice(i, Math.min(i + batchSize, totalSimulations));\n        const batchResults = await Promise.all(batch);\n\n        // Distribute results to appropriate strategy\n        batchResults.forEach(result => {\n            const strategy = result.strategy;\n            if (results[strategy]) {\n                results[strategy].totalGains.push(result.totalGain);\n                results[strategy].simulations.push({\n                    slots: result.slots,\n                    totalGain: result.totalGain,\n                    decisionLog: result.decisionLog\n                });\n            }\n        });\n\n        completedSimulations += batch.length;\n    }\n\n    // Calculate averages for all strategies\n    Object.keys(results).forEach(strategy => {\n        results[strategy].avgGain = results[strategy].totalGains.reduce((a, b) => a + b, 0) / simulationCount;\n    });\n\n    return results;\n}\n"],
  "mappings": "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",
  "names": []
}
