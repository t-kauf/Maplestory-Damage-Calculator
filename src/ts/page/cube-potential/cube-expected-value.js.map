{
  "version": 3,
  "sources": ["cube-expected-value.ts"],
  "sourcesContent": ["/**\r\n * Cube Expected Value - Monte Carlo Expected DPS Gain Calculations\r\n * Calculates expected value and marginal gain for cube usage decisions\r\n */\r\n\r\nimport { StatCalculationService } from '@ts/services/stat-calculation-service.js';\r\nimport {\r\n    RARITY_UPGRADE_RATES,\r\n    EQUIPMENT_POTENTIAL_DATA,\r\n    SLOT_SPECIFIC_POTENTIALS\r\n} from '@ts/page/cube-potential/cube-potential-data.js';\r\nimport { potentialStatToDamageStat } from '@ts/page/cube-potential/cube-potential.js';\r\nimport type { BaseStats } from '@ts/types/loadout.js';\r\nimport type { CubeSlotId, Rarity, PotentialLineEntry } from '@ts/types/page/gear-lab/gear-lab.types';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface ExpectedGainResult {\r\n    expectedDPSAfterCube: number;\r\n    marginalGain: number;\r\n    tierUpProb: number;\r\n    currentSlotDPSGain: number;\r\n}\r\n\r\nexport interface SlotState {\r\n    id: CubeSlotId;\r\n    name: string;\r\n    rarity: Rarity;\r\n    rollCount: number;\r\n    dpsGain: number;\r\n    cubesAtCurrentRarity?: number;\r\n}\r\n\r\nexport interface OptimalSlotResult {\r\n    slot: SlotState | null;\r\n    marginalGain: number;\r\n}\r\n\r\n// ============================================================================\r\n// STATE\r\n// ============================================================================\r\n\r\n/**\r\n * Cache for expected DPS values by slot+rarity\r\n */\r\nconst expectedDPSCache: Record<string, number> = {};\r\n\r\n// ============================================================================\r\n// EXPECTED VALUE CALCULATIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate expected MARGINAL DPS gain from using one cube on a slot.\r\n * Uses Monte Carlo sampling with actual DPS calculations.\r\n *\r\n * @param slotId - Equipment slot ID\r\n * @param currentRarity - Current rarity of the slot\r\n * @param currentRollCount - Rolls at current rarity (for pity)\r\n * @param currentSlotDPSGain - Current DPS% this slot provides\r\n * @param baseStats - Base character stats\r\n * @param baseDPS - Base DPS without any potential bonuses\r\n * @param sampleSize - Monte Carlo samples (default 100)\r\n */\r\nexport function calculateExpectedMarginalGain(\r\n    slotId: CubeSlotId,\r\n    currentRarity: Rarity,\r\n    currentRollCount: number,\r\n    currentSlotDPSGain: number,\r\n    baseStats: BaseStats,\r\n    baseDPS: number,\r\n    sampleSize: number = 100\r\n): ExpectedGainResult {\r\n    const upgradeData = RARITY_UPGRADE_RATES[currentRarity];\r\n\r\n    // Calculate tier-up probability\r\n    let tierUpProb = 0;\r\n    if (upgradeData) {\r\n        tierUpProb = (currentRollCount + 1 >= upgradeData.max) ? 1 : upgradeData.rate;\r\n    }\r\n\r\n    // Sample outcomes and compute average DPS gain\r\n    let totalSampledGain = 0;\r\n\r\n    for (let i = 0; i < sampleSize; i++) {\r\n        // Determine rarity for this sample\r\n        const didTierUp = Math.random() < tierUpProb;\r\n        const rollRarity = (didTierUp && upgradeData?.next) ? upgradeData.next : currentRarity;\r\n\r\n        // Roll lines at this rarity\r\n        const lines = samplePotentialLines(slotId, rollRarity);\r\n\r\n        // Calculate DPS gain from these lines using actual stat calculations\r\n        const dpsGain = calculateActualDPSGain(lines, baseStats, baseDPS);\r\n\r\n        totalSampledGain += dpsGain;\r\n    }\r\n\r\n    const expectedDPSAfterCube = totalSampledGain / sampleSize;\r\n\r\n    // Marginal gain = expected outcome - what we currently have\r\n    const marginalGain = expectedDPSAfterCube - currentSlotDPSGain;\r\n\r\n    return {\r\n        expectedDPSAfterCube,\r\n        marginalGain,\r\n        tierUpProb,\r\n        currentSlotDPSGain\r\n    };\r\n}\r\n\r\n/**\r\n * Sample a random set of 3 potential lines for a slot at given rarity\r\n */\r\nfunction samplePotentialLines(slotId: CubeSlotId, rarity: Rarity): (PotentialLineEntry | null)[] {\r\n    const potentialData = EQUIPMENT_POTENTIAL_DATA[rarity];\r\n    if (!potentialData) return [null, null, null];\r\n\r\n    // Get line options with slot-specific additions\r\n    let line1Options = [...(potentialData.line1 || [])];\r\n    let line2Options = [...(potentialData.line2 || [])];\r\n    let line3Options = [...(potentialData.line3 || [])];\r\n\r\n    const slotSpecific = SLOT_SPECIFIC_POTENTIALS[slotId]?.[rarity];\r\n    if (slotSpecific) {\r\n        if (slotSpecific.line1) line1Options = [...line1Options, ...slotSpecific.line1];\r\n        if (slotSpecific.line2) line2Options = [...line2Options, ...slotSpecific.line2];\r\n        if (slotSpecific.line3) line3Options = [...line3Options, ...slotSpecific.line3];\r\n    }\r\n\r\n    return [\r\n        rollWeightedLine(line1Options),\r\n        rollWeightedLine(line2Options),\r\n        rollWeightedLine(line3Options)\r\n    ];\r\n}\r\n\r\n/**\r\n * Roll a single line based on weights\r\n */\r\nfunction rollWeightedLine(options: PotentialLineEntry[]): PotentialLineEntry | null {\r\n    if (!options || options.length === 0) return null;\r\n\r\n    const totalWeight = options.reduce((sum, opt) => sum + opt.weight, 0);\r\n    let random = Math.random() * totalWeight;\r\n\r\n    for (const option of options) {\r\n        random -= option.weight;\r\n        if (random <= 0) return option;\r\n    }\r\n\r\n    return options[options.length - 1];\r\n}\r\n\r\n/**\r\n * Calculate actual DPS gain from a set of potential lines\r\n * Uses StatCalculationService for accurate calculations\r\n */\r\nfunction calculateActualDPSGain(\r\n    lines: (PotentialLineEntry | null)[],\r\n    baseStats: BaseStats,\r\n    baseDPS: number\r\n): number {\r\n    const slotService = new StatCalculationService(baseStats);\r\n    let accumulatedMainStatPct = 0;\r\n\r\n    for (const line of lines) {\r\n        if (!line || !line.stat) continue;\r\n\r\n        const mapped = potentialStatToDamageStat(line.stat, line.value, accumulatedMainStatPct);\r\n        if (mapped.stat) {\r\n            if (mapped.isMainStatPct) {\r\n                slotService.add(mapped.stat, mapped.value);\r\n                accumulatedMainStatPct += line.value;\r\n            } else {\r\n                slotService.add(mapped.stat, mapped.value);\r\n            }\r\n        }\r\n    }\r\n\r\n    const slotDPS = slotService.computeDPS('boss');\r\n    return ((slotDPS - baseDPS) / baseDPS * 100);\r\n}\r\n\r\n/**\r\n * Sample expected DPS gain for a slot at given rarity\r\n * Takes average of multiple samples\r\n */\r\nexport function sampleExpectedDPSGain(\r\n    slotId: CubeSlotId,\r\n    rarity: Rarity,\r\n    baseStats: BaseStats,\r\n    baseDPS: number,\r\n    samples: number = 20\r\n): number {\r\n    let total = 0;\r\n    for (let i = 0; i < samples; i++) {\r\n        const lines = samplePotentialLines(slotId, rarity);\r\n        total += calculateActualDPSGain(lines, baseStats, baseDPS);\r\n    }\r\n    return total / samples;\r\n}\r\n\r\n/**\r\n * Get cached expected DPS value for a slot+rarity combination\r\n */\r\nfunction getCachedExpectedDPS(\r\n    slotId: CubeSlotId,\r\n    rarity: Rarity,\r\n    baseStats: BaseStats,\r\n    baseDPS: number\r\n): number {\r\n    const key = `${slotId}-${rarity}`;\r\n    if (!expectedDPSCache[key]) {\r\n        expectedDPSCache[key] = sampleExpectedDPSGain(slotId, rarity, baseStats, baseDPS, 200);\r\n    }\r\n    return expectedDPSCache[key];\r\n}\r\n\r\n/**\r\n * Clear the expected DPS cache\r\n * Call this when stats change significantly\r\n */\r\nexport function clearExpectedDPSCache(): void {\r\n    Object.keys(expectedDPSCache).forEach(k => delete expectedDPSCache[k]);\r\n}\r\n\r\n/**\r\n * Find the optimal slot to cube given current states\r\n * Uses Monte Carlo expected value to find highest marginal gain\r\n *\r\n * @param slots - Array of slot objects with id, rarity, rollCount, dpsGain\r\n * @param baseStats - Base character stats\r\n * @param baseDPS - Base DPS without potential bonuses\r\n * @param sampleSize - Monte Carlo sample size (default 50)\r\n */\r\nexport function findOptimalSlotToCube(\r\n    slots: SlotState[],\r\n    baseStats: BaseStats,\r\n    baseDPS: number,\r\n    sampleSize: number = 50\r\n): OptimalSlotResult {\r\n    let bestSlot: SlotState | null = null;\r\n    let bestMarginalGain = -Infinity;\r\n\r\n    for (const slot of slots) {\r\n        const ev = calculateExpectedMarginalGain(\r\n            slot.id,\r\n            slot.rarity,\r\n            slot.rollCount || 0,\r\n            slot.dpsGain || 0,\r\n            baseStats,\r\n            baseDPS,\r\n            sampleSize\r\n        );\r\n\r\n        // Compare marginal gains across slots\r\n        // A slot at 0% DPS with expected 2% gain beats a slot at 5% with expected 5.3% gain\r\n        // because marginalGain = 2 - 0 = 2 vs 5.3 - 5 = 0.3\r\n        if (ev.marginalGain > bestMarginalGain) {\r\n            bestMarginalGain = ev.marginalGain;\r\n            bestSlot = slot;\r\n        }\r\n    }\r\n\r\n    return {\r\n        slot: bestSlot,\r\n        marginalGain: bestMarginalGain\r\n    };\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
