{
  "version": 3,
  "sources": ["cube-expected-value.ts"],
  "sourcesContent": ["/**\n * Cube Expected Value - Monte Carlo Expected DPS Gain Calculations\n * Calculates expected value and marginal gain for cube usage decisions\n */\n\nimport { StatCalculationService } from '@ts/services/stat-calculation-service.js';\nimport {\n    RARITY_UPGRADE_RATES,\n    EQUIPMENT_POTENTIAL_DATA,\n    SLOT_SPECIFIC_POTENTIALS\n} from '@ts/page/cube-potential/cube-potential-data.js';\nimport { potentialStatToDamageStat } from '@ts/page/cube-potential/cube-potential.js';\nimport type { BaseStats } from '@ts/types/loadout.js';\nimport type { CubeSlotId, Rarity, PotentialLineEntry } from '@ts/types/page/gear-lab/gear-lab.types';\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\nexport interface ExpectedGainResult {\n    expectedDPSAfterCube: number;\n    marginalGain: number;\n    tierUpProb: number;\n    currentSlotDPSGain: number;\n}\n\nexport interface SlotState {\n    id: CubeSlotId;\n    name: string;\n    rarity: Rarity;\n    rollCount: number;\n    dpsGain: number;\n    cubesAtCurrentRarity?: number;\n}\n\nexport interface OptimalSlotResult {\n    slot: SlotState | null;\n    marginalGain: number;\n}\n\n// ============================================================================\n// STATE\n// ============================================================================\n\n/**\n * Cache for expected DPS values by slot+rarity\n */\nconst expectedDPSCache: Record<string, number> = {};\n\n// ============================================================================\n// EXPECTED VALUE CALCULATIONS\n// ============================================================================\n\n/**\n * Calculate expected MARGINAL DPS gain from using one cube on a slot.\n * Uses Monte Carlo sampling with actual DPS calculations.\n *\n * @param slotId - Equipment slot ID\n * @param currentRarity - Current rarity of the slot\n * @param currentRollCount - Rolls at current rarity (for pity)\n * @param currentSlotDPSGain - Current DPS% this slot provides\n * @param baseStats - Base character stats\n * @param baseDPS - Base DPS without any potential bonuses\n * @param sampleSize - Monte Carlo samples (default 100)\n */\nexport function calculateExpectedMarginalGain(\n    slotId: CubeSlotId,\n    currentRarity: Rarity,\n    currentRollCount: number,\n    currentSlotDPSGain: number,\n    baseStats: BaseStats,\n    baseDPS: number,\n    sampleSize: number = 100\n): ExpectedGainResult {\n    const upgradeData = RARITY_UPGRADE_RATES[currentRarity];\n\n    // Calculate tier-up probability\n    let tierUpProb = 0;\n    if (upgradeData) {\n        tierUpProb = (currentRollCount + 1 >= upgradeData.max) ? 1 : upgradeData.rate;\n    }\n\n    // Sample outcomes and compute average DPS gain\n    let totalSampledGain = 0;\n\n    for (let i = 0; i < sampleSize; i++) {\n        // Determine rarity for this sample\n        const didTierUp = Math.random() < tierUpProb;\n        const rollRarity = (didTierUp && upgradeData?.next) ? upgradeData.next : currentRarity;\n\n        // Roll lines at this rarity\n        const lines = samplePotentialLines(slotId, rollRarity);\n\n        // Calculate DPS gain from these lines using actual stat calculations\n        const dpsGain = calculateActualDPSGain(lines, baseStats, baseDPS);\n\n        totalSampledGain += dpsGain;\n    }\n\n    const expectedDPSAfterCube = totalSampledGain / sampleSize;\n\n    // Marginal gain = expected outcome - what we currently have\n    const marginalGain = expectedDPSAfterCube - currentSlotDPSGain;\n\n    return {\n        expectedDPSAfterCube,\n        marginalGain,\n        tierUpProb,\n        currentSlotDPSGain\n    };\n}\n\n/**\n * Sample a random set of 3 potential lines for a slot at given rarity\n */\nfunction samplePotentialLines(slotId: CubeSlotId, rarity: Rarity): (PotentialLineEntry | null)[] {\n    const potentialData = EQUIPMENT_POTENTIAL_DATA[rarity];\n    if (!potentialData) return [null, null, null];\n\n    // Get line options with slot-specific additions\n    let line1Options = [...(potentialData.line1 || [])];\n    let line2Options = [...(potentialData.line2 || [])];\n    let line3Options = [...(potentialData.line3 || [])];\n\n    const slotSpecific = SLOT_SPECIFIC_POTENTIALS[slotId]?.[rarity];\n    if (slotSpecific) {\n        if (slotSpecific.line1) line1Options = [...line1Options, ...slotSpecific.line1];\n        if (slotSpecific.line2) line2Options = [...line2Options, ...slotSpecific.line2];\n        if (slotSpecific.line3) line3Options = [...line3Options, ...slotSpecific.line3];\n    }\n\n    return [\n        rollWeightedLine(line1Options),\n        rollWeightedLine(line2Options),\n        rollWeightedLine(line3Options)\n    ];\n}\n\n/**\n * Roll a single line based on weights\n */\nfunction rollWeightedLine(options: PotentialLineEntry[]): PotentialLineEntry | null {\n    if (!options || options.length === 0) return null;\n\n    const totalWeight = options.reduce((sum, opt) => sum + opt.weight, 0);\n    let random = Math.random() * totalWeight;\n\n    for (const option of options) {\n        random -= option.weight;\n        if (random <= 0) return option;\n    }\n\n    return options[options.length - 1];\n}\n\n/**\n * Calculate actual DPS gain from a set of potential lines\n * Uses StatCalculationService for accurate calculations\n */\nfunction calculateActualDPSGain(\n    lines: (PotentialLineEntry | null)[],\n    baseStats: BaseStats,\n    baseDPS: number\n): number {\n    const slotService = new StatCalculationService(baseStats);\n    let accumulatedMainStatPct = 0;\n\n    for (const line of lines) {\n        if (!line || !line.stat) continue;\n\n        const mapped = potentialStatToDamageStat(line.stat, line.value, accumulatedMainStatPct);\n        if (mapped.stat) {\n            if (mapped.isMainStatPct) {\n                slotService.add(mapped.stat, mapped.value);\n                accumulatedMainStatPct += line.value;\n            } else {\n                slotService.add(mapped.stat, mapped.value);\n            }\n        }\n    }\n\n    const slotDPS = slotService.computeDPS('boss');\n    return ((slotDPS - baseDPS) / baseDPS * 100);\n}\n\n/**\n * Sample expected DPS gain for a slot at given rarity\n * Takes average of multiple samples\n */\nexport function sampleExpectedDPSGain(\n    slotId: CubeSlotId,\n    rarity: Rarity,\n    baseStats: BaseStats,\n    baseDPS: number,\n    samples: number = 20\n): number {\n    let total = 0;\n    for (let i = 0; i < samples; i++) {\n        const lines = samplePotentialLines(slotId, rarity);\n        total += calculateActualDPSGain(lines, baseStats, baseDPS);\n    }\n    return total / samples;\n}\n\n/**\n * Get cached expected DPS value for a slot+rarity combination\n */\nfunction getCachedExpectedDPS(\n    slotId: CubeSlotId,\n    rarity: Rarity,\n    baseStats: BaseStats,\n    baseDPS: number\n): number {\n    const key = `${slotId}-${rarity}`;\n    if (!expectedDPSCache[key]) {\n        expectedDPSCache[key] = sampleExpectedDPSGain(slotId, rarity, baseStats, baseDPS, 200);\n    }\n    return expectedDPSCache[key];\n}\n\n/**\n * Clear the expected DPS cache\n * Call this when stats change significantly\n */\nexport function clearExpectedDPSCache(): void {\n    Object.keys(expectedDPSCache).forEach(k => delete expectedDPSCache[k]);\n}\n\n/**\n * Find the optimal slot to cube given current states\n * Uses Monte Carlo expected value to find highest marginal gain\n *\n * @param slots - Array of slot objects with id, rarity, rollCount, dpsGain\n * @param baseStats - Base character stats\n * @param baseDPS - Base DPS without potential bonuses\n * @param sampleSize - Monte Carlo sample size (default 50)\n */\nexport function findOptimalSlotToCube(\n    slots: SlotState[],\n    baseStats: BaseStats,\n    baseDPS: number,\n    sampleSize: number = 50\n): OptimalSlotResult {\n    let bestSlot: SlotState | null = null;\n    let bestMarginalGain = -Infinity;\n\n    for (const slot of slots) {\n        const ev = calculateExpectedMarginalGain(\n            slot.id,\n            slot.rarity,\n            slot.rollCount || 0,\n            slot.dpsGain || 0,\n            baseStats,\n            baseDPS,\n            sampleSize\n        );\n\n        // Compare marginal gains across slots\n        // A slot at 0% DPS with expected 2% gain beats a slot at 5% with expected 5.3% gain\n        // because marginalGain = 2 - 0 = 2 vs 5.3 - 5 = 0.3\n        if (ev.marginalGain > bestMarginalGain) {\n            bestMarginalGain = ev.marginalGain;\n            bestSlot = slot;\n        }\n    }\n\n    return {\n        slot: bestSlot,\n        marginalGain: bestMarginalGain\n    };\n}\n"],
  "mappings": "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",
  "names": []
}
