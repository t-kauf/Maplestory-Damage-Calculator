{
  "version": 3,
  "sources": ["weapons.ts"],
  "sourcesContent": ["/**\r\n * Pure calculation logic for Weapon Levels system\r\n * All functions are pure and have no side effects or DOM dependencies\r\n */\r\n\r\nimport { WeaponRarity, WeaponTier } from '@ts/types';\r\nimport type {\r\n    WeaponLevel,\r\n    StarRating,\r\n    WeaponAttackResult,\r\n    UpgradeGainResult,\r\n    WeaponState,\r\n    UpgradePriorityItem,\r\n    GroupedUpgradeResult,\r\n    UpgradePriorityChainResult,\r\n    CurrencyUpgradeResult,\r\n    WeaponLevels,\r\n    WeaponKey\r\n} from '@ts/types';\r\nimport { weaponBaseAttackEquipped, weaponUpgradeCosts, MAX_LEVELS_BY_STARS } from '@ts/types';\r\nimport {\r\n    WEAPON_RARITY,\r\n    HIGH_TIER_RARITIES,\r\n    INVENTORY_DIVISOR_HIGH_TIER,\r\n    INVENTORY_DIVISOR_STANDARD,\r\n    MAX_WEAPON_UPGRADE_ITERATIONS\r\n} from '@ts/types/constants';\r\n\r\n/**\r\n * Get weapon level multiplier based on level\r\n * @param level - Current weapon level\r\n * @returns Level multiplier for attack calculation\r\n */\r\nexport function getWeaponLevelMultiplier(level: WeaponLevel): number {\r\n    if (!level || level <= 1) return 1.0;\r\n    if (level <= 100) return 1 + (0.3 * (level - 1)) / 100;\r\n    if (level <= 130) return 1 + (30.3 + 0.7 * (level - 101)) / 100;\r\n    if (level <= 155) return 1 + (51.4 + 0.8 * (level - 131)) / 100;\r\n    if (level <= 175) return 1 + (71.5 + 0.9 * (level - 156)) / 100;\r\n    if (level <= 200) return 1 + (89.6 + 1.0 * (level - 176)) / 100;\r\n    return 1 + 113.6 / 100; // Cap at level 200\r\n}\r\n\r\n/**\r\n * Get inventory divisor based on rarity\r\n * @param rarity - Weapon rarity\r\n * @returns Divisor for inventory attack calculation\r\n */\r\nexport function getInventoryDivisor(rarity: WeaponRarity): number {\r\n    return HIGH_TIER_RARITIES.includes(rarity) ? INVENTORY_DIVISOR_HIGH_TIER : INVENTORY_DIVISOR_STANDARD;\r\n}\r\n\r\n/**\r\n * Calculate weapon attack percentages from level\r\n * @param rarity - Weapon rarity\r\n * @param tier - Weapon tier\r\n * @param level - Current weapon level\r\n * @returns Object with inventoryAttack and equippedAttack percentages\r\n */\r\nexport function calculateWeaponAttacks(\r\n    rarity: WeaponRarity,\r\n    tier: WeaponTier,\r\n    level: WeaponLevel\r\n): WeaponAttackResult {\r\n    const baseEquipped = weaponBaseAttackEquipped[rarity]?.[tier];\r\n\r\n    if (baseEquipped === null || baseEquipped === undefined || !level || level <= 0) {\r\n        return { inventoryAttack: 0, equippedAttack: 0 };\r\n    }\r\n\r\n    // Calculate equipped attack: base \u00D7 level multiplier\r\n    const levelMultiplier = getWeaponLevelMultiplier(level);\r\n    const equippedBeforeRound = baseEquipped * levelMultiplier;\r\n\r\n    // Round down to nearest 0.1% (as specified in formula image)\r\n    const equippedAttack = Math.floor(equippedBeforeRound * 10) / 10;\r\n\r\n    // Calculate inventory attack: equipped / divisor\r\n    const divisor = getInventoryDivisor(rarity);\r\n    const inventoryAttack = equippedAttack / divisor;\r\n\r\n    return { inventoryAttack, equippedAttack };\r\n}\r\n\r\n/**\r\n * Get max level based on star rating\r\n * @param stars - Star rating (0-5)\r\n * @returns Maximum weapon level for the given star rating\r\n */\r\nexport function getMaxLevelForStars(stars: StarRating): WeaponLevel {\r\n    return MAX_LEVELS_BY_STARS[stars] ?? 100;\r\n}\r\n\r\n/**\r\n * Calculate upgrade cost for a weapon at a specific level\r\n * @param rarity - Weapon rarity\r\n * @param tier - Weapon tier\r\n * @param level - Current weapon level\r\n * @returns Cost in shards to upgrade to the next level\r\n */\r\nexport function getUpgradeCost(\r\n    rarity: WeaponRarity,\r\n    tier: WeaponTier,\r\n    level: WeaponLevel\r\n): number {\r\n    const tierNum = parseInt(tier.replace('t', ''));\r\n    const cost = weaponUpgradeCosts[rarity]?.[tierNum]?.[level + 1];\r\n    return cost ?? 0;\r\n}\r\n\r\n/**\r\n * Calculate inventory attack gain from spending resources\r\n * @param rarity - Weapon rarity\r\n * @param tier - Weapon tier\r\n * @param currentLevel - Current weapon level\r\n * @param stars - Star rating (0-5)\r\n * @param resources - Available resources (shards)\r\n * @param isEquipped - Whether this weapon is equipped\r\n * @returns Upgrade gain calculation result\r\n */\r\nexport function calculateUpgradeGain(\r\n    rarity: WeaponRarity,\r\n    tier: WeaponTier,\r\n    currentLevel: WeaponLevel,\r\n    stars: StarRating,\r\n    resources: number,\r\n    isEquipped = false\r\n): UpgradeGainResult {\r\n    if (currentLevel <= 0) {\r\n        return {\r\n            levelsGained: 0,\r\n            newLevel: currentLevel,\r\n            attackGain: 0,\r\n            equippedAttackGain: 0,\r\n            resourcesUsed: 0,\r\n            efficiency: 0,\r\n            singleLevelCost: 0,\r\n            isUnaffordable: false\r\n        };\r\n    }\r\n\r\n    const maxLevel = getMaxLevelForStars(stars);\r\n\r\n    // Check the cost of the next level\r\n    const nextLevelCost = getUpgradeCost(rarity, tier, currentLevel);\r\n\r\n    // If the next level costs more than available resources, show gain for that level anyway\r\n    if (nextLevelCost > resources && currentLevel < maxLevel) {\r\n        const currentAttack = calculateWeaponAttacks(rarity, tier, currentLevel).inventoryAttack;\r\n        const nextLevelAttack = calculateWeaponAttacks(rarity, tier, currentLevel + 1).inventoryAttack;\r\n        const attackGain = nextLevelAttack - currentAttack;\r\n\r\n        // Calculate equipped attack gain if equipped\r\n        const currentEquippedAttack = calculateWeaponAttacks(rarity, tier, currentLevel).equippedAttack;\r\n        const nextEquippedAttack = calculateWeaponAttacks(rarity, tier, currentLevel + 1).equippedAttack;\r\n        const equippedAttackGain = isEquipped ? (nextEquippedAttack - currentEquippedAttack) : 0;\r\n\r\n        return {\r\n            levelsGained: 0,\r\n            newLevel: currentLevel,\r\n            attackGain,\r\n            equippedAttackGain,\r\n            resourcesUsed: 0,\r\n            efficiency: 0,\r\n            singleLevelCost: nextLevelCost,\r\n            isUnaffordable: true\r\n        };\r\n    }\r\n\r\n    let level = currentLevel;\r\n    let remainingResources = resources;\r\n    let totalCost = 0;\r\n    let iterations = 0;\r\n    const maxIterations = MAX_WEAPON_UPGRADE_ITERATIONS;\r\n\r\n    // Simulate upgrades until we run out of resources or hit max level\r\n    while (level < maxLevel && remainingResources > 0 && iterations < maxIterations) {\r\n        const cost = getUpgradeCost(rarity, tier, level);\r\n        if (cost <= 0 || cost > remainingResources) break;\r\n\r\n        remainingResources -= cost;\r\n        totalCost += cost;\r\n        level++;\r\n        iterations++;\r\n    }\r\n\r\n    // Calculate attack gain\r\n    const currentAttack = calculateWeaponAttacks(rarity, tier, currentLevel).inventoryAttack;\r\n    const newAttack = calculateWeaponAttacks(rarity, tier, level).inventoryAttack;\r\n    const attackGain = newAttack - currentAttack;\r\n\r\n    // Calculate equipped attack gain if equipped\r\n    const currentEquippedAttack = calculateWeaponAttacks(rarity, tier, currentLevel).equippedAttack;\r\n    const newEquippedAttack = calculateWeaponAttacks(rarity, tier, level).equippedAttack;\r\n    const equippedAttackGain = isEquipped ? (newEquippedAttack - currentEquippedAttack) : 0;\r\n\r\n    return {\r\n        levelsGained: level - currentLevel,\r\n        newLevel: level,\r\n        attackGain,\r\n        equippedAttackGain,\r\n        resourcesUsed: totalCost,\r\n        efficiency: totalCost > 0 ? attackGain / (totalCost / 1000) : 0,\r\n        singleLevelCost: 0,\r\n        isUnaffordable: false\r\n    };\r\n}\r\n\r\n/**\r\n * Calculate the upgrade priority chain\r\n * Determines the most efficient upgrade sequence for a given number of upgrades\r\n * @param weaponStates - Array of current weapon states\r\n * @param numUpgrades - Number of upgrades to simulate (default: 100)\r\n * @returns Priority chain calculation result\r\n */\r\nexport function calculateUpgradePriorityChain(\r\n    weaponStates: WeaponState[],\r\n    numUpgrades = 100\r\n): UpgradePriorityChainResult {\r\n    const upgradeSequence: UpgradePriorityItem[] = [];\r\n    const weaponLevels: Record<string, WeaponLevel> = {};\r\n    const weaponMaxLevels: Record<string, WeaponLevel> = {};\r\n    const weaponEquippedStates: Record<string, boolean> = {};\r\n\r\n    // Initialize current levels, max levels, and equipped states\r\n    weaponStates.forEach(ws => {\r\n        const key = `${ws.rarity}-${ws.tier}`;\r\n        weaponLevels[key] = ws.level;\r\n        weaponMaxLevels[key] = ws.maxLevel;\r\n        weaponEquippedStates[key] = ws.isEquipped ?? false;\r\n    });\r\n\r\n    for (let i = 0; i < numUpgrades; i++) {\r\n        let bestWeapon: UpgradePriorityItem | null = null;\r\n        let bestEfficiency = 0;\r\n\r\n        // Recalculate efficiency for ALL weapons at their current levels\r\n        weaponStates.forEach(ws => {\r\n            const key = `${ws.rarity}-${ws.tier}` as WeaponKey;\r\n            const currentLevel = weaponLevels[key];\r\n            const maxLevel = weaponMaxLevels[key];\r\n            const isEquipped = weaponEquippedStates[key];\r\n\r\n            // Skip if at max level\r\n            if (currentLevel >= maxLevel) return;\r\n\r\n            // Calculate multi-level efficiency (what 1k shards gets you from current level)\r\n            const upgradeGain = calculateUpgradeGain(\r\n                ws.rarity,\r\n                ws.tier,\r\n                currentLevel,\r\n                ws.stars,\r\n                1000,\r\n                isEquipped\r\n            );\r\n\r\n            let efficiency: number;\r\n            if (upgradeGain.isUnaffordable) {\r\n                // Normalize to per 1k when single level costs more than 1k\r\n                const inventoryEfficiency = (upgradeGain.attackGain / upgradeGain.singleLevelCost) * 1000;\r\n                const equippedEfficiency = (upgradeGain.equippedAttackGain / upgradeGain.singleLevelCost) * 1000;\r\n                efficiency = inventoryEfficiency + equippedEfficiency;\r\n            } else {\r\n                efficiency = upgradeGain.attackGain + upgradeGain.equippedAttackGain; // Already per 1k\r\n            }\r\n\r\n            if (efficiency > bestEfficiency) {\r\n                bestEfficiency = efficiency;\r\n                bestWeapon = {\r\n                    rarity: ws.rarity,\r\n                    tier: ws.tier,\r\n                    key,\r\n                    cost: getUpgradeCost(ws.rarity, ws.tier, currentLevel)\r\n                };\r\n            }\r\n        });\r\n\r\n        // If no weapon can be upgraded, stop\r\n        if (!bestWeapon) break;\r\n\r\n        // Record this upgrade and increment by 1 level\r\n        upgradeSequence.push(bestWeapon);\r\n        weaponLevels[bestWeapon.key]++;\r\n    }\r\n\r\n    // Group consecutive upgrades to the same weapon\r\n    const groupedUpgrades = groupUpgradesByWeapon(upgradeSequence);\r\n\r\n    return {\r\n        upgradeSequence,\r\n        groupedUpgrades,\r\n        finalWeaponLevels: weaponLevels\r\n    };\r\n}\r\n\r\n/**\r\n * Group consecutive upgrades by weapon\r\n * @param upgradeSequence - Array of individual upgrades\r\n * @returns Array of grouped upgrade results\r\n */\r\nexport function groupUpgradesByWeapon(\r\n    upgradeSequence: UpgradePriorityItem[]\r\n): GroupedUpgradeResult[] {\r\n    const groupedUpgrades: GroupedUpgradeResult[] = [];\r\n    let currentGroup: GroupedUpgradeResult | null = null;\r\n\r\n    upgradeSequence.forEach(upgrade => {\r\n        if (!currentGroup || currentGroup.rarity !== upgrade.rarity || currentGroup.tier !== upgrade.tier) {\r\n            if (currentGroup) {\r\n                groupedUpgrades.push(currentGroup);\r\n            }\r\n            currentGroup = {\r\n                rarity: upgrade.rarity,\r\n                tier: upgrade.tier,\r\n                count: 1\r\n            };\r\n        } else {\r\n            currentGroup.count++;\r\n        }\r\n    });\r\n\r\n    if (currentGroup) {\r\n        groupedUpgrades.push(currentGroup);\r\n    }\r\n\r\n    return groupedUpgrades;\r\n}\r\n\r\n/**\r\n * Calculate currency upgrade optimization\r\n * Simulates spending a given amount of currency on the most efficient upgrades\r\n * @param weaponStates - Array of current weapon states\r\n * @param currency - Available currency (shards)\r\n * @returns Currency upgrade calculation result\r\n */\r\nexport function calculateCurrencyUpgrades(\r\n    weaponStates: WeaponState[],\r\n    currency: number\r\n): CurrencyUpgradeResult | null {\r\n    if (!weaponStates.length || currency <= 0) {\r\n        return null;\r\n    }\r\n\r\n    const upgradeSequence: UpgradePriorityItem[] = [];\r\n    const weaponLevels: Record<string, WeaponLevel> = {};\r\n    const weaponMaxLevels: Record<string, WeaponLevel> = {};\r\n    const weaponEquippedStates: Record<string, boolean> = {};\r\n    let remainingCurrency = currency;\r\n\r\n    // Initialize current levels, max levels, and equipped states\r\n    weaponStates.forEach(ws => {\r\n        const key = `${ws.rarity}-${ws.tier}`;\r\n        weaponLevels[key] = ws.level;\r\n        weaponMaxLevels[key] = ws.maxLevel;\r\n        weaponEquippedStates[key] = ws.isEquipped ?? false;\r\n    });\r\n\r\n    // Keep upgrading until we run out of currency\r\n    while (remainingCurrency > 0) {\r\n        let bestWeapon: UpgradePriorityItem | null = null;\r\n        let bestEfficiency = 0;\r\n\r\n        // Find the most efficient upgrade based on 1k shard potential\r\n        weaponStates.forEach(ws => {\r\n            const key = `${ws.rarity}-${ws.tier}` as WeaponKey;\r\n            const currentLevel = weaponLevels[key];\r\n            const maxLevel = weaponMaxLevels[key];\r\n            const isEquipped = weaponEquippedStates[key];\r\n\r\n            if (currentLevel >= maxLevel) return;\r\n\r\n            // Calculate multi-level efficiency (what 1k shards gets you from current level)\r\n            const upgradeGain = calculateUpgradeGain(\r\n                ws.rarity,\r\n                ws.tier,\r\n                currentLevel,\r\n                ws.stars,\r\n                1000,\r\n                isEquipped\r\n            );\r\n\r\n            let efficiency: number;\r\n            if (upgradeGain.isUnaffordable) {\r\n                // Normalize to per 1k when single level costs more than 1k\r\n                const inventoryEfficiency = (upgradeGain.attackGain / upgradeGain.singleLevelCost) * 1000;\r\n                const equippedEfficiency = (upgradeGain.equippedAttackGain / upgradeGain.singleLevelCost) * 1000;\r\n                efficiency = inventoryEfficiency + equippedEfficiency;\r\n            } else {\r\n                efficiency = upgradeGain.attackGain + upgradeGain.equippedAttackGain; // Already per 1k\r\n            }\r\n\r\n            if (efficiency > bestEfficiency) {\r\n                bestEfficiency = efficiency;\r\n                bestWeapon = {\r\n                    rarity: ws.rarity,\r\n                    tier: ws.tier,\r\n                    key,\r\n                    cost: getUpgradeCost(ws.rarity, ws.tier, currentLevel)\r\n                };\r\n            }\r\n        });\r\n\r\n        // If no weapon can be upgraded, stop\r\n        if (!bestWeapon) break;\r\n\r\n        // Check if we can afford this upgrade\r\n        if (bestWeapon.cost > remainingCurrency) break;\r\n\r\n        // Apply this upgrade (1 level at a time)\r\n        upgradeSequence.push(bestWeapon);\r\n        weaponLevels[bestWeapon.key]++;\r\n        remainingCurrency -= bestWeapon.cost;\r\n    }\r\n\r\n    if (upgradeSequence.length === 0) {\r\n        return null;\r\n    }\r\n\r\n    // Calculate total attack gain\r\n    let totalAttackGain = 0;\r\n    upgradeSequence.forEach(upgrade => {\r\n        const prevLevel = weaponLevels[upgrade.key] - 1;\r\n        const currentAttack = calculateWeaponAttacks(upgrade.rarity, upgrade.tier, prevLevel).inventoryAttack;\r\n        const nextAttack = calculateWeaponAttacks(upgrade.rarity, upgrade.tier, weaponLevels[upgrade.key]).inventoryAttack;\r\n        totalAttackGain += nextAttack - currentAttack;\r\n    });\r\n\r\n    return {\r\n        totalAttackGain,\r\n        dpsGainPct: 0, // To be calculated by UI layer\r\n        upgradeSequence,\r\n        weaponLevels,\r\n        remainingCurrency\r\n    };\r\n}\r\n\r\n/**\r\n * Calculate total weapon attack bonus from weapon levels\r\n * @param weaponLevels - Object mapping rarity-tier keys to levels\r\n * @param equippedWeaponKey - Key of the currently equipped weapon (if any)\r\n * @returns Total weapon attack bonus (inventory + equipped)\r\n */\r\nexport function calculateTotalWeaponAttackBonus(\r\n    weaponLevels: WeaponLevels,\r\n    equippedWeaponKey: string | null\r\n): { inventoryAttack: number; equippedAttack: number; totalAttack: number } {\r\n    let totalInventory = 0;\r\n    let equippedAttack = 0;\r\n\r\n    Object.entries(weaponLevels).forEach(([key, level]) => {\r\n        if (level === 0) return;\r\n\r\n        const [rarity, tier] = key.split('-') as [WeaponRarity, WeaponTier];\r\n        const { inventoryAttack, equippedAttack: atk } = calculateWeaponAttacks(rarity, tier, level);\r\n\r\n        totalInventory += inventoryAttack;\r\n\r\n        // If this weapon is equipped, add its equipped attack\r\n        if (key === equippedWeaponKey) {\r\n            equippedAttack = atk;\r\n        }\r\n    });\r\n\r\n    return {\r\n        inventoryAttack: totalInventory,\r\n        equippedAttack,\r\n        totalAttack: totalInventory + equippedAttack\r\n    };\r\n}\r\n"],
  "mappings": "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",
  "names": ["currentAttack", "attackGain", "currentEquippedAttack", "equippedAttackGain"]
}
