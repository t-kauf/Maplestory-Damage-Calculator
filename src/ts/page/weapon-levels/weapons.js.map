{
  "version": 3,
  "sources": ["weapons.ts"],
  "sourcesContent": ["/**\n * Pure calculation logic for Weapon Levels system\n * All functions are pure and have no side effects or DOM dependencies\n */\n\nimport { WeaponRarity, WeaponTier } from '@ts/types';\nimport type {\n    WeaponLevel,\n    StarRating,\n    WeaponAttackResult,\n    UpgradeGainResult,\n    WeaponState,\n    UpgradePriorityItem,\n    GroupedUpgradeResult,\n    UpgradePriorityChainResult,\n    CurrencyUpgradeResult,\n    WeaponLevels,\n    WeaponKey\n} from '@ts/types';\nimport { weaponBaseAttackEquipped, weaponUpgradeCosts, MAX_LEVELS_BY_STARS } from '@ts/types';\nimport {\n    WEAPON_RARITY,\n    HIGH_TIER_RARITIES,\n    INVENTORY_DIVISOR_HIGH_TIER,\n    INVENTORY_DIVISOR_STANDARD,\n    MAX_WEAPON_UPGRADE_ITERATIONS\n} from '@ts/types/constants';\n\n/**\n * Get weapon level multiplier based on level\n * @param level - Current weapon level\n * @returns Level multiplier for attack calculation\n */\nexport function getWeaponLevelMultiplier(level: WeaponLevel): number {\n    if (!level || level <= 1) return 1.0;\n    if (level <= 100) return 1 + (0.3 * (level - 1)) / 100;\n    if (level <= 130) return 1 + (30.3 + 0.7 * (level - 101)) / 100;\n    if (level <= 155) return 1 + (51.4 + 0.8 * (level - 131)) / 100;\n    if (level <= 175) return 1 + (71.5 + 0.9 * (level - 156)) / 100;\n    if (level <= 200) return 1 + (89.6 + 1.0 * (level - 176)) / 100;\n    return 1 + 113.6 / 100; // Cap at level 200\n}\n\n/**\n * Get inventory divisor based on rarity\n * @param rarity - Weapon rarity\n * @returns Divisor for inventory attack calculation\n */\nexport function getInventoryDivisor(rarity: WeaponRarity): number {\n    return HIGH_TIER_RARITIES.includes(rarity) ? INVENTORY_DIVISOR_HIGH_TIER : INVENTORY_DIVISOR_STANDARD;\n}\n\n/**\n * Calculate weapon attack percentages from level\n * @param rarity - Weapon rarity\n * @param tier - Weapon tier\n * @param level - Current weapon level\n * @returns Object with inventoryAttack and equippedAttack percentages\n */\nexport function calculateWeaponAttacks(\n    rarity: WeaponRarity,\n    tier: WeaponTier,\n    level: WeaponLevel\n): WeaponAttackResult {\n    const baseEquipped = weaponBaseAttackEquipped[rarity]?.[tier];\n\n    if (baseEquipped === null || baseEquipped === undefined || !level || level <= 0) {\n        return { inventoryAttack: 0, equippedAttack: 0 };\n    }\n\n    // Calculate equipped attack: base \u00D7 level multiplier\n    const levelMultiplier = getWeaponLevelMultiplier(level);\n    const equippedBeforeRound = baseEquipped * levelMultiplier;\n\n    // Round down to nearest 0.1% (as specified in formula image)\n    const equippedAttack = Math.floor(equippedBeforeRound * 10) / 10;\n\n    // Calculate inventory attack: equipped / divisor\n    const divisor = getInventoryDivisor(rarity);\n    const inventoryAttack = equippedAttack / divisor;\n\n    return { inventoryAttack, equippedAttack };\n}\n\n/**\n * Get max level based on star rating\n * @param stars - Star rating (0-5)\n * @returns Maximum weapon level for the given star rating\n */\nexport function getMaxLevelForStars(stars: StarRating): WeaponLevel {\n    return MAX_LEVELS_BY_STARS[stars] ?? 100;\n}\n\n/**\n * Calculate upgrade cost for a weapon at a specific level\n * @param rarity - Weapon rarity\n * @param tier - Weapon tier\n * @param level - Current weapon level\n * @returns Cost in shards to upgrade to the next level\n */\nexport function getUpgradeCost(\n    rarity: WeaponRarity,\n    tier: WeaponTier,\n    level: WeaponLevel\n): number {\n    const tierNum = parseInt(tier.replace('t', ''));\n    const cost = weaponUpgradeCosts[rarity]?.[tierNum]?.[level + 1];\n    return cost ?? 0;\n}\n\n/**\n * Calculate inventory attack gain from spending resources\n * @param rarity - Weapon rarity\n * @param tier - Weapon tier\n * @param currentLevel - Current weapon level\n * @param stars - Star rating (0-5)\n * @param resources - Available resources (shards)\n * @param isEquipped - Whether this weapon is equipped\n * @returns Upgrade gain calculation result\n */\nexport function calculateUpgradeGain(\n    rarity: WeaponRarity,\n    tier: WeaponTier,\n    currentLevel: WeaponLevel,\n    stars: StarRating,\n    resources: number,\n    isEquipped = false\n): UpgradeGainResult {\n    if (currentLevel <= 0) {\n        return {\n            levelsGained: 0,\n            newLevel: currentLevel,\n            attackGain: 0,\n            equippedAttackGain: 0,\n            resourcesUsed: 0,\n            efficiency: 0,\n            singleLevelCost: 0,\n            isUnaffordable: false\n        };\n    }\n\n    const maxLevel = getMaxLevelForStars(stars);\n\n    // Check the cost of the next level\n    const nextLevelCost = getUpgradeCost(rarity, tier, currentLevel);\n\n    // If the next level costs more than available resources, show gain for that level anyway\n    if (nextLevelCost > resources && currentLevel < maxLevel) {\n        const currentAttack = calculateWeaponAttacks(rarity, tier, currentLevel).inventoryAttack;\n        const nextLevelAttack = calculateWeaponAttacks(rarity, tier, currentLevel + 1).inventoryAttack;\n        const attackGain = nextLevelAttack - currentAttack;\n\n        // Calculate equipped attack gain if equipped\n        const currentEquippedAttack = calculateWeaponAttacks(rarity, tier, currentLevel).equippedAttack;\n        const nextEquippedAttack = calculateWeaponAttacks(rarity, tier, currentLevel + 1).equippedAttack;\n        const equippedAttackGain = isEquipped ? (nextEquippedAttack - currentEquippedAttack) : 0;\n\n        return {\n            levelsGained: 0,\n            newLevel: currentLevel,\n            attackGain,\n            equippedAttackGain,\n            resourcesUsed: 0,\n            efficiency: 0,\n            singleLevelCost: nextLevelCost,\n            isUnaffordable: true\n        };\n    }\n\n    let level = currentLevel;\n    let remainingResources = resources;\n    let totalCost = 0;\n    let iterations = 0;\n    const maxIterations = MAX_WEAPON_UPGRADE_ITERATIONS;\n\n    // Simulate upgrades until we run out of resources or hit max level\n    while (level < maxLevel && remainingResources > 0 && iterations < maxIterations) {\n        const cost = getUpgradeCost(rarity, tier, level);\n        if (cost <= 0 || cost > remainingResources) break;\n\n        remainingResources -= cost;\n        totalCost += cost;\n        level++;\n        iterations++;\n    }\n\n    // Calculate attack gain\n    const currentAttack = calculateWeaponAttacks(rarity, tier, currentLevel).inventoryAttack;\n    const newAttack = calculateWeaponAttacks(rarity, tier, level).inventoryAttack;\n    const attackGain = newAttack - currentAttack;\n\n    // Calculate equipped attack gain if equipped\n    const currentEquippedAttack = calculateWeaponAttacks(rarity, tier, currentLevel).equippedAttack;\n    const newEquippedAttack = calculateWeaponAttacks(rarity, tier, level).equippedAttack;\n    const equippedAttackGain = isEquipped ? (newEquippedAttack - currentEquippedAttack) : 0;\n\n    return {\n        levelsGained: level - currentLevel,\n        newLevel: level,\n        attackGain,\n        equippedAttackGain,\n        resourcesUsed: totalCost,\n        efficiency: totalCost > 0 ? attackGain / (totalCost / 1000) : 0,\n        singleLevelCost: 0,\n        isUnaffordable: false\n    };\n}\n\n/**\n * Calculate the upgrade priority chain\n * Determines the most efficient upgrade sequence for a given number of upgrades\n * @param weaponStates - Array of current weapon states\n * @param numUpgrades - Number of upgrades to simulate (default: 100)\n * @returns Priority chain calculation result\n */\nexport function calculateUpgradePriorityChain(\n    weaponStates: WeaponState[],\n    numUpgrades = 100\n): UpgradePriorityChainResult {\n    const upgradeSequence: UpgradePriorityItem[] = [];\n    const weaponLevels: Record<string, WeaponLevel> = {};\n    const weaponMaxLevels: Record<string, WeaponLevel> = {};\n    const weaponEquippedStates: Record<string, boolean> = {};\n\n    // Initialize current levels, max levels, and equipped states\n    weaponStates.forEach(ws => {\n        const key = `${ws.rarity}-${ws.tier}`;\n        weaponLevels[key] = ws.level;\n        weaponMaxLevels[key] = ws.maxLevel;\n        weaponEquippedStates[key] = ws.isEquipped ?? false;\n    });\n\n    for (let i = 0; i < numUpgrades; i++) {\n        let bestWeapon: UpgradePriorityItem | null = null;\n        let bestEfficiency = 0;\n\n        // Recalculate efficiency for ALL weapons at their current levels\n        weaponStates.forEach(ws => {\n            const key = `${ws.rarity}-${ws.tier}` as WeaponKey;\n            const currentLevel = weaponLevels[key];\n            const maxLevel = weaponMaxLevels[key];\n            const isEquipped = weaponEquippedStates[key];\n\n            // Skip if at max level\n            if (currentLevel >= maxLevel) return;\n\n            // Calculate multi-level efficiency (what 1k shards gets you from current level)\n            const upgradeGain = calculateUpgradeGain(\n                ws.rarity,\n                ws.tier,\n                currentLevel,\n                ws.stars,\n                1000,\n                isEquipped\n            );\n\n            let efficiency: number;\n            if (upgradeGain.isUnaffordable) {\n                // Normalize to per 1k when single level costs more than 1k\n                const inventoryEfficiency = (upgradeGain.attackGain / upgradeGain.singleLevelCost) * 1000;\n                const equippedEfficiency = (upgradeGain.equippedAttackGain / upgradeGain.singleLevelCost) * 1000;\n                efficiency = inventoryEfficiency + equippedEfficiency;\n            } else {\n                efficiency = upgradeGain.attackGain + upgradeGain.equippedAttackGain; // Already per 1k\n            }\n\n            if (efficiency > bestEfficiency) {\n                bestEfficiency = efficiency;\n                bestWeapon = {\n                    rarity: ws.rarity,\n                    tier: ws.tier,\n                    key,\n                    cost: getUpgradeCost(ws.rarity, ws.tier, currentLevel)\n                };\n            }\n        });\n\n        // If no weapon can be upgraded, stop\n        if (!bestWeapon) break;\n\n        // Record this upgrade and increment by 1 level\n        upgradeSequence.push(bestWeapon);\n        weaponLevels[bestWeapon.key]++;\n    }\n\n    // Group consecutive upgrades to the same weapon\n    const groupedUpgrades = groupUpgradesByWeapon(upgradeSequence);\n\n    return {\n        upgradeSequence,\n        groupedUpgrades,\n        finalWeaponLevels: weaponLevels\n    };\n}\n\n/**\n * Group consecutive upgrades by weapon\n * @param upgradeSequence - Array of individual upgrades\n * @returns Array of grouped upgrade results\n */\nexport function groupUpgradesByWeapon(\n    upgradeSequence: UpgradePriorityItem[]\n): GroupedUpgradeResult[] {\n    const groupedUpgrades: GroupedUpgradeResult[] = [];\n    let currentGroup: GroupedUpgradeResult | null = null;\n\n    upgradeSequence.forEach(upgrade => {\n        if (!currentGroup || currentGroup.rarity !== upgrade.rarity || currentGroup.tier !== upgrade.tier) {\n            if (currentGroup) {\n                groupedUpgrades.push(currentGroup);\n            }\n            currentGroup = {\n                rarity: upgrade.rarity,\n                tier: upgrade.tier,\n                count: 1\n            };\n        } else {\n            currentGroup.count++;\n        }\n    });\n\n    if (currentGroup) {\n        groupedUpgrades.push(currentGroup);\n    }\n\n    return groupedUpgrades;\n}\n\n/**\n * Calculate currency upgrade optimization\n * Simulates spending a given amount of currency on the most efficient upgrades\n * @param weaponStates - Array of current weapon states\n * @param currency - Available currency (shards)\n * @returns Currency upgrade calculation result\n */\nexport function calculateCurrencyUpgrades(\n    weaponStates: WeaponState[],\n    currency: number\n): CurrencyUpgradeResult | null {\n    if (!weaponStates.length || currency <= 0) {\n        return null;\n    }\n\n    const upgradeSequence: UpgradePriorityItem[] = [];\n    const weaponLevels: Record<string, WeaponLevel> = {};\n    const weaponMaxLevels: Record<string, WeaponLevel> = {};\n    const weaponEquippedStates: Record<string, boolean> = {};\n    let remainingCurrency = currency;\n\n    // Initialize current levels, max levels, and equipped states\n    weaponStates.forEach(ws => {\n        const key = `${ws.rarity}-${ws.tier}`;\n        weaponLevels[key] = ws.level;\n        weaponMaxLevels[key] = ws.maxLevel;\n        weaponEquippedStates[key] = ws.isEquipped ?? false;\n    });\n\n    // Keep upgrading until we run out of currency\n    while (remainingCurrency > 0) {\n        let bestWeapon: UpgradePriorityItem | null = null;\n        let bestEfficiency = 0;\n\n        // Find the most efficient upgrade based on 1k shard potential\n        weaponStates.forEach(ws => {\n            const key = `${ws.rarity}-${ws.tier}` as WeaponKey;\n            const currentLevel = weaponLevels[key];\n            const maxLevel = weaponMaxLevels[key];\n            const isEquipped = weaponEquippedStates[key];\n\n            if (currentLevel >= maxLevel) return;\n\n            // Calculate multi-level efficiency (what 1k shards gets you from current level)\n            const upgradeGain = calculateUpgradeGain(\n                ws.rarity,\n                ws.tier,\n                currentLevel,\n                ws.stars,\n                1000,\n                isEquipped\n            );\n\n            let efficiency: number;\n            if (upgradeGain.isUnaffordable) {\n                // Normalize to per 1k when single level costs more than 1k\n                const inventoryEfficiency = (upgradeGain.attackGain / upgradeGain.singleLevelCost) * 1000;\n                const equippedEfficiency = (upgradeGain.equippedAttackGain / upgradeGain.singleLevelCost) * 1000;\n                efficiency = inventoryEfficiency + equippedEfficiency;\n            } else {\n                efficiency = upgradeGain.attackGain + upgradeGain.equippedAttackGain; // Already per 1k\n            }\n\n            if (efficiency > bestEfficiency) {\n                bestEfficiency = efficiency;\n                bestWeapon = {\n                    rarity: ws.rarity,\n                    tier: ws.tier,\n                    key,\n                    cost: getUpgradeCost(ws.rarity, ws.tier, currentLevel)\n                };\n            }\n        });\n\n        // If no weapon can be upgraded, stop\n        if (!bestWeapon) break;\n\n        // Check if we can afford this upgrade\n        if (bestWeapon.cost > remainingCurrency) break;\n\n        // Apply this upgrade (1 level at a time)\n        upgradeSequence.push(bestWeapon);\n        weaponLevels[bestWeapon.key]++;\n        remainingCurrency -= bestWeapon.cost;\n    }\n\n    if (upgradeSequence.length === 0) {\n        return null;\n    }\n\n    // Calculate total attack gain\n    let totalAttackGain = 0;\n    upgradeSequence.forEach(upgrade => {\n        const prevLevel = weaponLevels[upgrade.key] - 1;\n        const currentAttack = calculateWeaponAttacks(upgrade.rarity, upgrade.tier, prevLevel).inventoryAttack;\n        const nextAttack = calculateWeaponAttacks(upgrade.rarity, upgrade.tier, weaponLevels[upgrade.key]).inventoryAttack;\n        totalAttackGain += nextAttack - currentAttack;\n    });\n\n    return {\n        totalAttackGain,\n        dpsGainPct: 0, // To be calculated by UI layer\n        upgradeSequence,\n        weaponLevels,\n        remainingCurrency\n    };\n}\n\n/**\n * Calculate total weapon attack bonus from weapon levels\n * @param weaponLevels - Object mapping rarity-tier keys to levels\n * @param equippedWeaponKey - Key of the currently equipped weapon (if any)\n * @returns Total weapon attack bonus (inventory + equipped)\n */\nexport function calculateTotalWeaponAttackBonus(\n    weaponLevels: WeaponLevels,\n    equippedWeaponKey: string | null\n): { inventoryAttack: number; equippedAttack: number; totalAttack: number } {\n    let totalInventory = 0;\n    let equippedAttack = 0;\n\n    Object.entries(weaponLevels).forEach(([key, level]) => {\n        if (level === 0) return;\n\n        const [rarity, tier] = key.split('-') as [WeaponRarity, WeaponTier];\n        const { inventoryAttack, equippedAttack: atk } = calculateWeaponAttacks(rarity, tier, level);\n\n        totalInventory += inventoryAttack;\n\n        // If this weapon is equipped, add its equipped attack\n        if (key === equippedWeaponKey) {\n            equippedAttack = atk;\n        }\n    });\n\n    return {\n        inventoryAttack: totalInventory,\n        equippedAttack,\n        totalAttack: totalInventory + equippedAttack\n    };\n}\n"],
  "mappings": "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",
  "names": ["currentAttack", "attackGain", "currentEquippedAttack", "equippedAttackGain"]
}
