/**
 * Weapon Upgrade Priority UI - DOM manipulation for upgrade priority features
 * Handles the Upgrade Priority sub-tab and currency calculator
 */

import {
    calculateWeaponAttacks,
    getMaxLevelForStars,
    calculateUpgradePriorityChain,
    calculateUpgradeGain,
    getUpgradeCost
} from './weapons';
import type {
    WeaponRarity,
    WeaponTier,
    StarRating,
    UpgradePriorityItem,
    WeaponState,
    CurrencyUpgradeResult,
    WeaponLevel,
    WeaponKey
} from '@ts/types';
import { rarities, tiers } from '@ts/types';
import { MONSTER_TYPE, WEAPON_RARITY, WEAPON_TIER, EFFICIENCY_THRESHOLD } from '@ts/types/constants';
import { loadoutStore } from '@ts/store/loadout.store';
import { StatCalculationService } from '@ts/services/stat-calculation-service';

// Type for the updateWeaponBonuses callback function
type UpdateWeaponBonusesFn = (calculateDamage?: boolean) => void;

// Extend Window interface to include functions exported from weapon-ui.ts
declare global {
    interface Window {
        updateWeaponBonuses: UpdateWeaponBonusesFn;
    }
}

// Override calculateCurrencyUpgrades - use Object.defineProperty to bypass type checking
Object.defineProperty(window, 'calculateCurrencyUpgrades', {
    value: async () => {
        await calculateCurrencyUpgradesUI(window.updateWeaponBonuses);
    },
    writable: true,
    enumerable: true,
    configurable: true
});

// =======================
// Upgrade Priority UI HTML Generation
// =======================

/**
 * Generate the HTML for the upgrade priority sub-tab
 */
function generateUpgradePriorityHTML(): string {
    return `
        <!-- Upgrade Priority Chain -->
        <div id="upgrade-priority-container" class="wl-priority-container">
            <div class="wl-priority-header">
                Next 100 Upgrades Priority (Best Inventory Attack Gain)
            </div>
            <div id="upgrade-priority-chain" class="wl-priority-chain">
                <!-- Priority chain will be generated by JavaScript -->
            </div>

            <!-- Currency Calculator -->
            <div class="wl-currency-section">
                <div class="wl-currency-header">
                    Enter your current upgrade currency to see your optimal target weapon levels
                </div>
                <div class="wl-currency-input-group">
                    <label class="wl-currency-label" for="upgrade-currency-input">Upgrade Currency</label>
                    <input type="number" id="upgrade-currency-input" class="wl-currency-input"
                           placeholder="Enter amount" oninput="calculateCurrencyUpgrades()">
                </div>
                <div id="currency-upgrade-results" class="wl-currency-results">
                    <div class="wl-currency-metrics">
                        <div class="wl-currency-metric">
                            <span class="wl-currency-metric-label">Total Attack % Gain</span>
                            <div class="wl-currency-metric-value" id="currency-attack-gain">0%</div>
                        </div>
                        <div class="wl-currency-metric">
                            <span class="wl-currency-metric-label">DPS Gain %</span>
                            <div class="wl-currency-metric-value" id="currency-dps-gain">0%</div>
                        </div>
                    </div>
                    <div class="wl-currency-metric-label" style="text-align: center; margin-bottom: 8px;">Upgrade Path:</div>
                    <div id="currency-upgrade-path" class="wl-currency-path">
                        <!-- Path will be generated -->
                    </div>
                    <button id="apply-upgrade-path-btn" class="wl-apply-button">
                        Apply Upgrade Path
                    </button>
                </div>
            </div>
        </div>
    `;
}

/**
 * Initialize the weapon priority UI - generates HTML and attaches event listeners
 * This should be called after the DOM is fully populated
 */
export function initializeWeaponPriorityUI(): void {
    const container = document.getElementById('weapon-levels-upgrade-priority');
    if (!container) return;

    // Generate and populate the upgrade priority HTML
    container.innerHTML = generateUpgradePriorityHTML();
    // Priority UI is mostly event-driven via oninput handlers in HTML
    // Initial priority chain will be updated when weapons are loaded
}

// =======================
// Upgrade Priority Chain
// =======================

/**
 * Update the upgrade priority chain display
 */
export function updateUpgradePriorityChain(): void {
    const priorityChain = document.getElementById('upgrade-priority-chain');
    if (!priorityChain) return;

    // Collect current weapon states
    const weaponStates: Array<WeaponState> = [];

    rarities.forEach(rarity => {
        tiers.forEach(tier => {
            const levelInput = document.getElementById(`level-${rarity}-${tier}`) as HTMLInputElement;
            const starsInput = document.getElementById(`stars-${rarity}-${tier}`) as HTMLInputElement;
            if (levelInput) {
                const level = parseInt(levelInput.value) || 0;
                const stars: StarRating = (starsInput?.value !== undefined && starsInput?.value !== ''
                    ? parseInt(starsInput.value)
                    : 5) as StarRating;
                const maxLevel = getMaxLevelForStars(stars);

                // Only include weapons that can be upgraded (level > 0 and not at max)
                if (level > 0 && level <= maxLevel) {
                    // Check if this weapon is equipped
                    const equippedDisplay = document.getElementById(`equipped-display-${rarity}-${tier}`);
                    const isEquipped = equippedDisplay && equippedDisplay.style.display !== 'none';

                    weaponStates.push({
                        rarity,
                        tier,
                        level,
                        stars,
                        maxLevel,
                        isEquipped
                    });
                }
            }
        });
    });

    if (weaponStates.length === 0) {
        priorityChain.innerHTML = '<span style="color: var(--text-secondary);">No weapons available to upgrade</span>';
        return;
    }

    // Calculate priority chain using logic function
    const result = calculateUpgradePriorityChain(weaponStates, 100);

    // Build HTML for display
    let html = '';
    result.groupedUpgrades.forEach((group, index) => {
        const tierUpper = group.tier.toUpperCase();
        const rarityFirstLetter = group.rarity.charAt(0).toUpperCase();

        html += `<span class="wl-priority-item" data-rarity="${group.rarity}">${tierUpper} ${rarityFirstLetter} x${group.count}</span>`;

        if (index < result.groupedUpgrades.length - 1) {
            html += ' <span class="wl-priority-divider">→</span> ';
        }
    });

    priorityChain.innerHTML = html;
}

/**
 * Update upgrade color indicators based on efficiency
 */
export function updateWeaponUpgradeColors(): void {
    // Collect all gainPer1k values
    const gainValues: number[] = [];
    rarities.forEach(rarity => {
        tiers.forEach(tier => {
            const upgradeGainDisplay = document.getElementById(`upgrade-gain-${rarity}-${tier}`);
            if (upgradeGainDisplay && upgradeGainDisplay.dataset.gainPer1k) {
                const gainPer1k = parseFloat(upgradeGainDisplay.dataset.gainPer1k);
                if (!isNaN(gainPer1k) && gainPer1k > 0) {
                    gainValues.push(gainPer1k);
                }
            }
        });
    });

    if (gainValues.length === 0) return;

    // Find min and max
    const minGain = Math.min(...gainValues);
    const maxGain = Math.max(...gainValues);

    // Apply CSS classes to each upgrade display
    rarities.forEach(rarity => {
        tiers.forEach(tier => {
            const upgradeGainDisplay = document.getElementById(`upgrade-gain-${rarity}-${tier}`);
            if (upgradeGainDisplay && upgradeGainDisplay.dataset.gainPer1k) {
                const gainPer1k = parseFloat(upgradeGainDisplay.dataset.gainPer1k);
                if (!isNaN(gainPer1k) && gainPer1k > 0) {
                    // Normalize value between 0 (min) and 1 (max)
                    const normalized = maxGain === minGain ? 1 : (gainPer1k - minGain) / (maxGain - minGain);

                    // Apply CSS class based on efficiency tier
                    upgradeGainDisplay.classList.remove('high', 'medium', 'low');
                    if (normalized > EFFICIENCY_THRESHOLD.HIGH) {
                        upgradeGainDisplay.classList.add('high');
                    } else if (normalized > EFFICIENCY_THRESHOLD.MEDIUM) {
                        upgradeGainDisplay.classList.add('medium');
                    } else {
                        upgradeGainDisplay.classList.add('low');
                    }
                }
            }
        });
    });
}

// =======================
// Currency Upgrade Calculator
// =======================

/**
 * Calculate and display currency upgrade options
 * This is the UI layer wrapper that calls the pure logic function
 */
export async function calculateCurrencyUpgradesUI(updateWeaponBonuses: UpdateWeaponBonusesFn): Promise<void> {
    const currencyInput = document.getElementById('upgrade-currency-input') as HTMLInputElement;
    const resultsDiv = document.getElementById('currency-upgrade-results');
    const attackGainDisplay = document.getElementById('currency-attack-gain');
    const dpsGainDisplay = document.getElementById('currency-dps-gain');
    const pathDisplay = document.getElementById('currency-upgrade-path');

    if (!currencyInput || !resultsDiv) return;

    const currency = parseFloat(currencyInput.value) || 0;

    if (currency <= 0) {
        resultsDiv.classList.remove('visible');
        return;
    }

    // Collect current weapon states
    const weaponStates: Array<WeaponState> = [];

    rarities.forEach(rarity => {
        tiers.forEach(tier => {
            const levelInput = document.getElementById(`level-${rarity}-${tier}`) as HTMLInputElement;
            const starsInput = document.getElementById(`stars-${rarity}-${tier}`) as HTMLInputElement;
            if (levelInput) {
                const level = parseInt(levelInput.value) || 0;
                const stars: StarRating = (starsInput?.value !== undefined && starsInput?.value !== ''
                    ? parseInt(starsInput.value)
                    : 5) as StarRating;
                const maxLevel = getMaxLevelForStars(stars);

                if (level > 0 && level <= maxLevel) {
                    // Check if this weapon is equipped
                    const equippedDisplay = document.getElementById(`equipped-display-${rarity}-${tier}`);
                    const isEquipped = equippedDisplay && equippedDisplay.style.display !== 'none';

                    weaponStates.push({
                        rarity,
                        tier,
                        level,
                        stars,
                        maxLevel,
                        isEquipped
                    });
                }
            }
        });
    });

    if (weaponStates.length === 0) {
        resultsDiv.classList.remove('visible');
        return;
    }

    // Calculate initial DPS using StatCalculationService
    const baseStats = loadoutStore.getBaseStats();
    const initialStatService = new StatCalculationService(baseStats);
    const initialDPS = initialStatService.computeDPS(MONSTER_TYPE.BOSS);

    // Call the pure logic function (dynamic import to avoid circular type inference)
    const { calculateCurrencyUpgrades: calculateCurrencyUpgradesPure } = await import('./weapons.js');
    const result = calculateCurrencyUpgradesPure(weaponStates, currency);

    if (!result) {
        // If no upgrades could be bought with the entered currency, show a friendly message
        resultsDiv.classList.add('visible');
        if (attackGainDisplay) attackGainDisplay.textContent = `+0.00%`;
        if (dpsGainDisplay) dpsGainDisplay.textContent = `+0.00%`;
        if (pathDisplay) pathDisplay.innerHTML = `<span class="wl-currency-path-divider">Most impactful upgrade can't be afforded — save up!</span>`;
        // Hide the apply button since there is no path to apply
        const applyUpgradesBtn = document.getElementById('apply-upgrade-path-btn');
        if (applyUpgradesBtn) applyUpgradesBtn.style.display = 'none';
        return;
    }

    // Calculate weapon attack bonus with simulated upgraded levels
    const newWeaponAttackBonus = calculateTotalWeaponAttackBonusFromLevels(result.weaponLevels);

    // Apply the weapon attack bonus difference to attack
    const baseAttackWithoutWeaponBonus = baseStats.ATTACK / (1 + initialStatService.weaponAttackBonus / 100);
    const newStats = { ...baseStats, attack: baseAttackWithoutWeaponBonus * (1 + newWeaponAttackBonus / 100) };

    // Pass 0 for weaponAttackBonus since we've manually applied it to the attack stat
    const newStatService = new StatCalculationService(newStats, newWeaponAttackBonus);
    const newDPS = newStatService.computeDPS(MONSTER_TYPE.BOSS);
    const dpsGainPct = ((newDPS - initialDPS) / initialDPS * 100);
    result.dpsGainPct = dpsGainPct;

    // Collate all upgrades by weapon type (not just consecutive)
    const upgradeCounts: Record<string, UpgradePriorityItem & { count: number }> = {};

    result.upgradeSequence.forEach(upgrade => {
        const key = `${upgrade.rarity}-${upgrade.tier}`;
        if (!upgradeCounts[key]) {
            upgradeCounts[key] = {
                ...upgrade,
                count: 0
            };
        }
        upgradeCounts[key].count++;
    });

    // Convert to array and sort by count (descending) then by rarity/tier
    const collatedUpgrades = Object.values(upgradeCounts).sort((a, b) => {
        if (b.count !== a.count) return b.count - a.count;
        // Secondary sort: by rarity index then tier
        const rarityOrder: Record<string, number> = {
            [WEAPON_RARITY.NORMAL]: 0,
            [WEAPON_RARITY.RARE]: 1,
            [WEAPON_RARITY.EPIC]: 2,
            [WEAPON_RARITY.UNIQUE]: 3,
            [WEAPON_RARITY.LEGENDARY]: 4,
            [WEAPON_RARITY.MYSTIC]: 5,
            [WEAPON_RARITY.ANCIENT]: 6
        };
        if (rarityOrder[a.rarity] !== rarityOrder[b.rarity]) {
            return rarityOrder[a.rarity] - rarityOrder[b.rarity];
        }
        const tierOrder: Record<string, number> = {
            [WEAPON_TIER.T4]: 0,
            [WEAPON_TIER.T3]: 1,
            [WEAPON_TIER.T2]: 2,
            [WEAPON_TIER.T1]: 3
        };
        return tierOrder[a.tier] - tierOrder[b.tier];
    });

    // Build path HTML (horizontal list)
    let pathHTML = '';
    collatedUpgrades.forEach((group, index) => {
        const tierUpper = group.tier.toUpperCase();
        const rarityFirstLetter = group.rarity.charAt(0).toUpperCase();
        const weaponKey = `${group.rarity}-${group.tier}`;
        pathHTML += `<span class="wl-currency-path-item" data-rarity="${group.rarity}">${tierUpper} ${rarityFirstLetter} x${group.count} (${result.weaponLevels[weaponKey]})</span>`;

        if (index < collatedUpgrades.length - 1) {
            pathHTML += ' <span class="wl-currency-path-divider">,</span> ';
        }
    });

    // Display results
    if (attackGainDisplay) attackGainDisplay.textContent = `+${result.totalAttackGain.toFixed(2)}%`;
    if (dpsGainDisplay) dpsGainDisplay.textContent = `+${result.dpsGainPct.toFixed(2)}%`;
    if (pathDisplay) pathDisplay.innerHTML = pathHTML;
    resultsDiv.classList.add('visible');

    const applyUpgradesBtn = document.getElementById('apply-upgrade-path-btn');

    // Ensure the apply button is visible when there is a valid path
    if (applyUpgradesBtn) {
        applyUpgradesBtn.style.display = '';

        // Update weapon levels after user has leveled weapons accordingly
        applyUpgradesBtn.onclick = () => {
            for (const key in result.weaponLevels) {
                const levelInput = document.getElementById(`level-${key}`) as HTMLInputElement;
                if (levelInput) {
                    levelInput.value = result.weaponLevels[key].toString();
                }
            }

            // Reset currency input
            if (currencyInput) currencyInput.value = '0';

            // Update/save stats
            calculateCurrencyUpgradesUI(updateWeaponBonuses);
            // Save all weapon levels via store
            for (const key in result.weaponLevels) {
                const level = result.weaponLevels[key];
                const [rarity, tier] = key.split('-') as [WeaponRarity, WeaponTier];
                loadoutStore.updateWeapon(key, { level });
            }
            updateWeaponBonuses();
        };
    }
}

/**
 * Calculate currency upgrade optimization
 * Simulates spending a given amount of currency on the most efficient upgrades
 * @param weaponStates - Array of current weapon states
 * @param currency - Available currency (shards)
 * @returns Currency upgrade calculation result
 */
export function calculateCurrencyUpgrades(
    weaponStates: WeaponState[],
    currency: number
): CurrencyUpgradeResult | null {
    if (!weaponStates.length || currency <= 0) {
        return null;
    }

    const upgradeSequence: UpgradePriorityItem[] = [];
    const weaponLevels: Record<string, WeaponLevel> = {};
    const weaponMaxLevels: Record<string, WeaponLevel> = {};
    const weaponEquippedStates: Record<string, boolean> = {};
    let remainingCurrency = currency;

    // Initialize current levels, max levels, and equipped states
    weaponStates.forEach(ws => {
        const key = `${ws.rarity}-${ws.tier}`;
        weaponLevels[key] = ws.level;
        weaponMaxLevels[key] = ws.maxLevel;
        weaponEquippedStates[key] = ws.isEquipped ?? false;
    });

    // Keep upgrading until we run out of currency
    while (remainingCurrency > 0) {
        let bestWeapon: UpgradePriorityItem | null = null;
        let bestEfficiency = 0;

        // Find the most efficient upgrade based on 1k shard potential
        weaponStates.forEach(ws => {
            const key = `${ws.rarity}-${ws.tier}` as WeaponKey;
            const currentLevel = weaponLevels[key];
            const maxLevel = weaponMaxLevels[key];
            const isEquipped = weaponEquippedStates[key];

            if (currentLevel >= maxLevel) return;

            // Calculate multi-level efficiency (what 1k shards gets you from current level)
            const upgradeGain = calculateUpgradeGain(
                ws.rarity,
                ws.tier,
                currentLevel,
                ws.stars,
                1000,
                isEquipped
            );

            let efficiency: number;
            if (upgradeGain.isUnaffordable) {
                // Normalize to per 1k when single level costs more than 1k
                const inventoryEfficiency = (upgradeGain.attackGain / upgradeGain.singleLevelCost) * 1000;
                const equippedEfficiency = (upgradeGain.equippedAttackGain / upgradeGain.singleLevelCost) * 1000;
                efficiency = inventoryEfficiency + equippedEfficiency;
            } else {
                efficiency = upgradeGain.attackGain + upgradeGain.equippedAttackGain; // Already per 1k
            }

            if (efficiency > bestEfficiency) {
                bestEfficiency = efficiency;
                bestWeapon = {
                    rarity: ws.rarity,
                    tier: ws.tier,
                    key,
                    cost: getUpgradeCost(ws.rarity, ws.tier, currentLevel)
                };
            }
        });

        // If no weapon can be upgraded, stop
        if (!bestWeapon) break;

        // Check if we can afford this upgrade
        if (bestWeapon.cost > remainingCurrency) break;

        // Apply this upgrade (1 level at a time)
        upgradeSequence.push(bestWeapon);
        weaponLevels[bestWeapon.key]++;
        remainingCurrency -= bestWeapon.cost;
    }

    if (upgradeSequence.length === 0) {
        return null;
    }

    // Calculate total attack gain
    let totalAttackGain = 0;
    upgradeSequence.forEach(upgrade => {
        const prevLevel = weaponLevels[upgrade.key] - 1;
        const currentAttack = calculateWeaponAttacks(upgrade.rarity, upgrade.tier, prevLevel).inventoryAttack;
        const nextAttack = calculateWeaponAttacks(upgrade.rarity, upgrade.tier, weaponLevels[upgrade.key]).inventoryAttack;
        totalAttackGain += nextAttack - currentAttack;
    });

    return {
        totalAttackGain,
        dpsGainPct: 0, // To be calculated by UI layer
        upgradeSequence,
        weaponLevels,
        remainingCurrency
    };
}

/**
 * Helper function to calculate weapon attack bonus from weapon levels
 * @param weaponLevels - Object mapping rarity-tier keys to levels
 * @returns Total weapon attack bonus
 */
function calculateTotalWeaponAttackBonusFromLevels(weaponLevels: Record<string, number>): number {
    let totalBonus = 0;
    let equippedBonus = 0;

    rarities.forEach(rarity => {
        tiers.forEach(tier => {
            const key = `${rarity}-${tier}`;
            const level = weaponLevels[key] || 0;

            if (level === 0) return;

            const { inventoryAttack, equippedAttack } = calculateWeaponAttacks(rarity, tier, level);
            totalBonus += inventoryAttack;

            // Check if this weapon is equipped
            const equippedDisplay = document.getElementById(`equipped-label-${rarity}-${tier}`);
            if (equippedDisplay && (equippedDisplay as HTMLElement).style.display !== 'none') {
                equippedBonus = equippedAttack;
            }
        });
    });

    return totalBonus + equippedBonus;
}