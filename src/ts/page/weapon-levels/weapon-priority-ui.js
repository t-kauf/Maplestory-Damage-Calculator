import {
  calculateWeaponAttacks,
  getMaxLevelForStars,
  calculateUpgradePriorityChain,
  calculateUpgradeGain,
  getUpgradeCost
} from "./weapons.js";
import { rarities, tiers } from "@ts/types";
import { MONSTER_TYPE, WEAPON_RARITY, WEAPON_TIER, EFFICIENCY_THRESHOLD } from "@ts/types/constants.js";
import { loadoutStore } from "@ts/store/loadout.store.js";
import { StatCalculationService } from "@ts/services/stat-calculation-service.js";
Object.defineProperty(window, "calculateCurrencyUpgrades", {
  value: async () => {
    await calculateCurrencyUpgradesUI(window.updateWeaponBonuses);
  },
  writable: true,
  enumerable: true,
  configurable: true
});
function generateUpgradePriorityHTML() {
  return `
        <!-- Upgrade Priority Chain -->
        <div id="upgrade-priority-container" class="wl-priority-container">
            <div class="wl-priority-header">
                Next 100 Upgrades Priority (Best Inventory Attack Gain)
            </div>
            <div id="upgrade-priority-chain" class="wl-priority-chain">
                <!-- Priority chain will be generated by JavaScript -->
            </div>

            <!-- Currency Calculator -->
            <div class="wl-currency-section">
                <div class="wl-currency-header">
                    Enter your current upgrade currency to see your optimal target weapon levels
                </div>
                <div class="wl-currency-input-group">
                    <label class="wl-currency-label" for="upgrade-currency-input">Upgrade Currency</label>
                    <input type="number" id="upgrade-currency-input" class="wl-currency-input"
                           placeholder="Enter amount" oninput="calculateCurrencyUpgrades()">
                </div>
                <div id="currency-upgrade-results" class="wl-currency-results">
                    <div class="wl-currency-metrics">
                        <div class="wl-currency-metric">
                            <span class="wl-currency-metric-label">Total Attack % Gain</span>
                            <div class="wl-currency-metric-value" id="currency-attack-gain">0%</div>
                        </div>
                        <div class="wl-currency-metric">
                            <span class="wl-currency-metric-label">DPS Gain %</span>
                            <div class="wl-currency-metric-value" id="currency-dps-gain">0%</div>
                        </div>
                    </div>
                    <div class="wl-currency-metric-label" style="text-align: center; margin-bottom: 8px;">Upgrade Path:</div>
                    <div id="currency-upgrade-path" class="wl-currency-path">
                        <!-- Path will be generated -->
                    </div>
                    <button id="apply-upgrade-path-btn" class="wl-apply-button">
                        Apply Upgrade Path
                    </button>
                </div>
            </div>
        </div>
    `;
}
function initializeWeaponPriorityUI() {
  const container = document.getElementById("weapon-levels-upgrade-priority");
  if (!container) return;
  container.innerHTML = generateUpgradePriorityHTML();
}
function updateUpgradePriorityChain() {
  const priorityChain = document.getElementById("upgrade-priority-chain");
  if (!priorityChain) return;
  const weaponStates = [];
  rarities.forEach((rarity) => {
    tiers.forEach((tier) => {
      const levelInput = document.getElementById(`level-${rarity}-${tier}`);
      const starsInput = document.getElementById(`stars-${rarity}-${tier}`);
      if (levelInput) {
        const level = parseInt(levelInput.value) || 0;
        const stars = starsInput?.value !== void 0 && starsInput?.value !== "" ? parseInt(starsInput.value) : 5;
        const maxLevel = getMaxLevelForStars(stars);
        if (level > 0 && level <= maxLevel) {
          const equippedDisplay = document.getElementById(`equipped-display-${rarity}-${tier}`);
          const isEquipped = equippedDisplay && equippedDisplay.style.display !== "none";
          weaponStates.push({
            rarity,
            tier,
            level,
            stars,
            maxLevel,
            isEquipped
          });
        }
      }
    });
  });
  if (weaponStates.length === 0) {
    priorityChain.innerHTML = '<span style="color: var(--text-secondary);">No weapons available to upgrade</span>';
    return;
  }
  const result = calculateUpgradePriorityChain(weaponStates, 100);
  let html = "";
  result.groupedUpgrades.forEach((group, index) => {
    const tierUpper = group.tier.toUpperCase();
    const rarityFirstLetter = group.rarity.charAt(0).toUpperCase();
    html += `<span class="wl-priority-item" data-rarity="${group.rarity}">${tierUpper} ${rarityFirstLetter} x${group.count}</span>`;
    if (index < result.groupedUpgrades.length - 1) {
      html += ' <span class="wl-priority-divider">\u2192</span> ';
    }
  });
  priorityChain.innerHTML = html;
}
function updateWeaponUpgradeColors() {
  const gainValues = [];
  rarities.forEach((rarity) => {
    tiers.forEach((tier) => {
      const upgradeGainDisplay = document.getElementById(`upgrade-gain-${rarity}-${tier}`);
      if (upgradeGainDisplay && upgradeGainDisplay.dataset.gainPer1k) {
        const gainPer1k = parseFloat(upgradeGainDisplay.dataset.gainPer1k);
        if (!isNaN(gainPer1k) && gainPer1k > 0) {
          gainValues.push(gainPer1k);
        }
      }
    });
  });
  if (gainValues.length === 0) return;
  const minGain = Math.min(...gainValues);
  const maxGain = Math.max(...gainValues);
  rarities.forEach((rarity) => {
    tiers.forEach((tier) => {
      const upgradeGainDisplay = document.getElementById(`upgrade-gain-${rarity}-${tier}`);
      if (upgradeGainDisplay && upgradeGainDisplay.dataset.gainPer1k) {
        const gainPer1k = parseFloat(upgradeGainDisplay.dataset.gainPer1k);
        if (!isNaN(gainPer1k) && gainPer1k > 0) {
          const normalized = maxGain === minGain ? 1 : (gainPer1k - minGain) / (maxGain - minGain);
          upgradeGainDisplay.classList.remove("high", "medium", "low");
          if (normalized > EFFICIENCY_THRESHOLD.HIGH) {
            upgradeGainDisplay.classList.add("high");
          } else if (normalized > EFFICIENCY_THRESHOLD.MEDIUM) {
            upgradeGainDisplay.classList.add("medium");
          } else {
            upgradeGainDisplay.classList.add("low");
          }
        }
      }
    });
  });
}
async function calculateCurrencyUpgradesUI(updateWeaponBonuses) {
  const currencyInput = document.getElementById("upgrade-currency-input");
  const resultsDiv = document.getElementById("currency-upgrade-results");
  const attackGainDisplay = document.getElementById("currency-attack-gain");
  const dpsGainDisplay = document.getElementById("currency-dps-gain");
  const pathDisplay = document.getElementById("currency-upgrade-path");
  if (!currencyInput || !resultsDiv) return;
  const currency = parseFloat(currencyInput.value) || 0;
  if (currency <= 0) {
    resultsDiv.classList.remove("visible");
    return;
  }
  const weaponStates = [];
  rarities.forEach((rarity) => {
    tiers.forEach((tier) => {
      const levelInput = document.getElementById(`level-${rarity}-${tier}`);
      const starsInput = document.getElementById(`stars-${rarity}-${tier}`);
      if (levelInput) {
        const level = parseInt(levelInput.value) || 0;
        const stars = starsInput?.value !== void 0 && starsInput?.value !== "" ? parseInt(starsInput.value) : 5;
        const maxLevel = getMaxLevelForStars(stars);
        if (level > 0 && level <= maxLevel) {
          const equippedDisplay = document.getElementById(`equipped-display-${rarity}-${tier}`);
          const isEquipped = equippedDisplay && equippedDisplay.style.display !== "none";
          weaponStates.push({
            rarity,
            tier,
            level,
            stars,
            maxLevel,
            isEquipped
          });
        }
      }
    });
  });
  if (weaponStates.length === 0) {
    resultsDiv.classList.remove("visible");
    return;
  }
  const baseStats = loadoutStore.getBaseStats();
  const initialStatService = new StatCalculationService(baseStats);
  const initialDPS = initialStatService.computeDPS(MONSTER_TYPE.BOSS);
  const { calculateCurrencyUpgrades: calculateCurrencyUpgradesPure } = await import("./weapons.js");
  const result = calculateCurrencyUpgradesPure(weaponStates, currency);
  if (!result) {
    resultsDiv.classList.add("visible");
    if (attackGainDisplay) attackGainDisplay.textContent = `+0.00%`;
    if (dpsGainDisplay) dpsGainDisplay.textContent = `+0.00%`;
    if (pathDisplay) pathDisplay.innerHTML = `<span class="wl-currency-path-divider">Most impactful upgrade can't be afforded \u2014 save up!</span>`;
    const applyUpgradesBtn2 = document.getElementById("apply-upgrade-path-btn");
    if (applyUpgradesBtn2) applyUpgradesBtn2.style.display = "none";
    return;
  }
  const newWeaponAttackBonus = calculateTotalWeaponAttackBonusFromLevels(result.weaponLevels);
  const baseAttackWithoutWeaponBonus = baseStats.ATTACK / (1 + initialStatService.weaponAttackBonus / 100);
  const newStats = { ...baseStats, attack: baseAttackWithoutWeaponBonus * (1 + newWeaponAttackBonus / 100) };
  const newStatService = new StatCalculationService(newStats, newWeaponAttackBonus);
  const newDPS = newStatService.computeDPS(MONSTER_TYPE.BOSS);
  const dpsGainPct = (newDPS - initialDPS) / initialDPS * 100;
  result.dpsGainPct = dpsGainPct;
  const upgradeCounts = {};
  result.upgradeSequence.forEach((upgrade) => {
    const key = `${upgrade.rarity}-${upgrade.tier}`;
    if (!upgradeCounts[key]) {
      upgradeCounts[key] = {
        ...upgrade,
        count: 0
      };
    }
    upgradeCounts[key].count++;
  });
  const collatedUpgrades = Object.values(upgradeCounts).sort((a, b) => {
    if (b.count !== a.count) return b.count - a.count;
    const rarityOrder = {
      [WEAPON_RARITY.NORMAL]: 0,
      [WEAPON_RARITY.RARE]: 1,
      [WEAPON_RARITY.EPIC]: 2,
      [WEAPON_RARITY.UNIQUE]: 3,
      [WEAPON_RARITY.LEGENDARY]: 4,
      [WEAPON_RARITY.MYSTIC]: 5,
      [WEAPON_RARITY.ANCIENT]: 6
    };
    if (rarityOrder[a.rarity] !== rarityOrder[b.rarity]) {
      return rarityOrder[a.rarity] - rarityOrder[b.rarity];
    }
    const tierOrder = {
      [WEAPON_TIER.T4]: 0,
      [WEAPON_TIER.T3]: 1,
      [WEAPON_TIER.T2]: 2,
      [WEAPON_TIER.T1]: 3
    };
    return tierOrder[a.tier] - tierOrder[b.tier];
  });
  let pathHTML = "";
  collatedUpgrades.forEach((group, index) => {
    const tierUpper = group.tier.toUpperCase();
    const rarityFirstLetter = group.rarity.charAt(0).toUpperCase();
    const weaponKey = `${group.rarity}-${group.tier}`;
    pathHTML += `<span class="wl-currency-path-item" data-rarity="${group.rarity}">${tierUpper} ${rarityFirstLetter} x${group.count} (${result.weaponLevels[weaponKey]})</span>`;
    if (index < collatedUpgrades.length - 1) {
      pathHTML += ' <span class="wl-currency-path-divider">,</span> ';
    }
  });
  if (attackGainDisplay) attackGainDisplay.textContent = `+${result.totalAttackGain.toFixed(2)}%`;
  if (dpsGainDisplay) dpsGainDisplay.textContent = `+${result.dpsGainPct.toFixed(2)}%`;
  if (pathDisplay) pathDisplay.innerHTML = pathHTML;
  resultsDiv.classList.add("visible");
  const applyUpgradesBtn = document.getElementById("apply-upgrade-path-btn");
  if (applyUpgradesBtn) {
    applyUpgradesBtn.style.display = "";
    applyUpgradesBtn.onclick = () => {
      for (const key in result.weaponLevels) {
        const levelInput = document.getElementById(`level-${key}`);
        if (levelInput) {
          levelInput.value = result.weaponLevels[key].toString();
        }
      }
      if (currencyInput) currencyInput.value = "0";
      calculateCurrencyUpgradesUI(updateWeaponBonuses);
      for (const key in result.weaponLevels) {
        const level = result.weaponLevels[key];
        const [rarity, tier] = key.split("-");
        loadoutStore.updateWeapon(key, { level });
      }
      updateWeaponBonuses();
    };
  }
}
function calculateCurrencyUpgrades(weaponStates, currency) {
  if (!weaponStates.length || currency <= 0) {
    return null;
  }
  const upgradeSequence = [];
  const weaponLevels = {};
  const weaponMaxLevels = {};
  const weaponEquippedStates = {};
  let remainingCurrency = currency;
  weaponStates.forEach((ws) => {
    const key = `${ws.rarity}-${ws.tier}`;
    weaponLevels[key] = ws.level;
    weaponMaxLevels[key] = ws.maxLevel;
    weaponEquippedStates[key] = ws.isEquipped ?? false;
  });
  while (remainingCurrency > 0) {
    let bestWeapon = null;
    let bestEfficiency = 0;
    weaponStates.forEach((ws) => {
      const key = `${ws.rarity}-${ws.tier}`;
      const currentLevel = weaponLevels[key];
      const maxLevel = weaponMaxLevels[key];
      const isEquipped = weaponEquippedStates[key];
      if (currentLevel >= maxLevel) return;
      const upgradeGain = calculateUpgradeGain(
        ws.rarity,
        ws.tier,
        currentLevel,
        ws.stars,
        1e3,
        isEquipped
      );
      let efficiency;
      if (upgradeGain.isUnaffordable) {
        const inventoryEfficiency = upgradeGain.attackGain / upgradeGain.singleLevelCost * 1e3;
        const equippedEfficiency = upgradeGain.equippedAttackGain / upgradeGain.singleLevelCost * 1e3;
        efficiency = inventoryEfficiency + equippedEfficiency;
      } else {
        efficiency = upgradeGain.attackGain + upgradeGain.equippedAttackGain;
      }
      if (efficiency > bestEfficiency) {
        bestEfficiency = efficiency;
        bestWeapon = {
          rarity: ws.rarity,
          tier: ws.tier,
          key,
          cost: getUpgradeCost(ws.rarity, ws.tier, currentLevel)
        };
      }
    });
    if (!bestWeapon) break;
    if (bestWeapon.cost > remainingCurrency) break;
    upgradeSequence.push(bestWeapon);
    weaponLevels[bestWeapon.key]++;
    remainingCurrency -= bestWeapon.cost;
  }
  if (upgradeSequence.length === 0) {
    return null;
  }
  let totalAttackGain = 0;
  upgradeSequence.forEach((upgrade) => {
    const prevLevel = weaponLevels[upgrade.key] - 1;
    const currentAttack = calculateWeaponAttacks(upgrade.rarity, upgrade.tier, prevLevel).inventoryAttack;
    const nextAttack = calculateWeaponAttacks(upgrade.rarity, upgrade.tier, weaponLevels[upgrade.key]).inventoryAttack;
    totalAttackGain += nextAttack - currentAttack;
  });
  return {
    totalAttackGain,
    dpsGainPct: 0,
    // To be calculated by UI layer
    upgradeSequence,
    weaponLevels,
    remainingCurrency
  };
}
function calculateTotalWeaponAttackBonusFromLevels(weaponLevels) {
  let totalBonus = 0;
  let equippedBonus = 0;
  rarities.forEach((rarity) => {
    tiers.forEach((tier) => {
      const key = `${rarity}-${tier}`;
      const level = weaponLevels[key] || 0;
      if (level === 0) return;
      const { inventoryAttack, equippedAttack } = calculateWeaponAttacks(rarity, tier, level);
      totalBonus += inventoryAttack;
      const equippedDisplay = document.getElementById(`equipped-label-${rarity}-${tier}`);
      if (equippedDisplay && equippedDisplay.style.display !== "none") {
        equippedBonus = equippedAttack;
      }
    });
  });
  return totalBonus + equippedBonus;
}
export {
  calculateCurrencyUpgrades,
  calculateCurrencyUpgradesUI,
  initializeWeaponPriorityUI,
  updateUpgradePriorityChain,
  updateWeaponUpgradeColors
};
//# sourceMappingURL=weapon-priority-ui.js.map
