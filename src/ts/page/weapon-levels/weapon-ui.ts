/**
 * DOM manipulation layer for Weapon Levels system
 * All functions handle only DOM operations and delegate logic to weapons.ts
 */

import {
    calculateWeaponAttacks,
    getMaxLevelForStars,
    calculateUpgradeGain
} from './weapons';
import type { WeaponRarity, WeaponTier, StarRating } from '@ts/types';
import { rarities, tiers, weaponBaseAttackEquipped } from '@ts/types';
import { WEAPON_RARITY, WEAPON_TIER, HIGH_TIER_RARITIES } from '@ts/types/constants';
import { loadoutStore } from '@ts/store/loadout.store';

// Import and re-export upgrade priority UI functions for external use
import {
    updateUpgradePriorityChain,
    updateWeaponUpgradeColors
} from './weapon-priority-ui';

export { updateWeaponUpgradeColors, updateUpgradePriorityChain };

// =======================
// Weapon Levels Tab UI
// =======================

/**
 * Generate the complete HTML for the weapon levels tab
 */
function generateWeaponLevelsHTML(): string {
    return `
        <!-- Sub-tab Navigation -->
        <div class="optimization-sub-tabs">
            <button id="weapon-levels-subtab-button" class="tab-button active" onclick="switchWeaponLevelsTab('weapons-grid')">Weapons Grid</button>
            <button id="weapon-levels-subtab-button" class="tab-button" onclick="switchWeaponLevelsTab('upgrade-priority')">Upgrade Priority</button>
        </div>

        <!-- Weapons Grid Sub-Tab -->
        <div id="weapon-levels-weapons-grid" class="weapon-levels-subtab active">
            <!-- Summary Stats -->
            <div class="wl-summary-stats">
                <div class="wl-summary-card">
                    <span class="wl-summary-label">Total Inventory Attack %</span>
                    <div class="wl-summary-value" id="total-inventory-attack">0%</div>
                </div>
                <div class="wl-summary-card">
                    <span class="wl-summary-label">Equipped Attack %</span>
                    <div class="wl-summary-value" id="equipped-weapon-attack-pct">0%</div>
                </div>
                <div class="wl-summary-card">
                    <span class="wl-summary-label">Total Weapon Attack %</span>
                    <div class="wl-summary-value" id="total-weapon-attack">0%</div>
                </div>
            </div>

            <!-- Info Banner -->
            <div class="wl-info-banner">
                <div class="wl-info-banner-content">
                    <strong>Instructions:</strong> Click stars to set star rating, enter weapon level. Check the "E" button to equip a weapon. The given inventory attack gain % is how much you'd expect if you spent 10k shards on the given weapon.
                </div>
            </div>

            <!-- No Weapon Equipped Indicator -->
            <div id="no-weapon-equipped-indicator" class="wl-warning-banner">
                <span class="wl-warning-banner-icon">⚠️</span>
                <span class="wl-warning-banner-text">No Weapon Equipped - Check the "E" button on a weapon to equip it</span>
            </div>

            <div id="weapons-grid">
                <!-- Weapons will be generated by initializeWeaponsUI() -->
            </div>
        </div>

        <!-- Upgrade Priority Sub-Tab -->
        <div id="weapon-levels-upgrade-priority" class="weapon-levels-subtab" style="display: none;">
            <!-- Content populated by weapon-priority-ui.ts -->
        </div>
    `;
}

// =======================
// Window Global Exports
// =======================
// These functions are attached to window for HTML onclick handlers

window.setWeaponStars = setWeaponStars;
window.previewStars = previewStars;
window.resetStarPreview = resetStarPreview;
window.handleEquippedCheckboxChange = handleEquippedCheckboxChange;
window.handleWeaponLevelChange = handleWeaponLevelChange;
window.switchWeaponLevelsTab = switchWeaponLevelsTab;
window.updateWeaponBonuses = updateWeaponBonuses;

// =======================
// DOM Initialization
// =======================

/**
 * Initialize all weapons UI elements - generates tab HTML and weapon grid
 */
export function initializeWeaponsUI(): void {
    // First, initialize the weapon levels tab container
    const container = document.getElementById('setup-weapon-levels');
    if (container) {
        container.innerHTML = generateWeaponLevelsHTML();
    }

    // Then, populate the weapons grid
    const weaponsGrid = document.getElementById('weapons-grid');
    if (!weaponsGrid) return;

    let html = '';

    rarities.forEach(rarity => {
        tiers.forEach(tier => {
            const baseAtk = weaponBaseAttackEquipped[rarity]?.[tier];
            const rarityCapitalized = rarity.charAt(0).toUpperCase() + rarity.slice(1);

            // Ancient T4 is enabled, T3/T2/T1 are disabled
            const isDisabled = rarity === WEAPON_RARITY.ANCIENT && tier === WEAPON_TIER.T1;

            if (baseAtk === null || baseAtk === undefined || isDisabled) {
                html += `<div class="weapon-card weapon-card--disabled" data-rarity="${rarity}">
                    <div class="weapon-header">${tier.toUpperCase()} ${rarityCapitalized}</div>
                    <div class="weapon-no-data">No data</div>
                </div>`;
            } else {
                // Default stars: 5 for normal/rare/epic/unique, 1 for legendary/mystic/ancient
                const defaultStars: StarRating = HIGH_TIER_RARITIES.includes(rarity) ? 1 : 5;

                html += `<div class="weapon-card" id="weapon-${rarity}-${tier}" data-rarity="${rarity}">
                    <!-- Equipped Checkbox in top right -->
                    <div class="weapon-equipped-toggle">
                        <input type="checkbox" id="equipped-checkbox-${rarity}-${tier}"
                               onchange="handleEquippedCheckboxChange('${rarity}', '${tier}')">
                        <label for="equipped-checkbox-${rarity}-${tier}"
                               class="weapon-equipped-label"
                               id="equipped-label-${rarity}-${tier}">E</label>
                    </div>

                    <div class="weapon-header">${tier.toUpperCase()} ${rarityCapitalized}</div>

                    <!-- Star Rating -->
                    <div class="weapon-stars">`;

                for (let i = 1; i <= 5; i++) {
                    const activeClass = i <= defaultStars ? 'active' : '';
                    html += `<span class="star-individual ${activeClass}"
                                   onclick="setWeaponStars('${rarity}', '${tier}', ${i})"
                                   onmouseenter="previewStars('${rarity}', '${tier}', ${i})"
                                   onmouseleave="resetStarPreview('${rarity}', '${tier}')"
                                   id="star-${rarity}-${tier}-${i}">⭐</span>`;
                }

                html += `</div>
                    <input type="hidden" id="stars-${rarity}-${tier}" value="${defaultStars}">

                    <div class="weapon-input-group">
                        <label for="level-${rarity}-${tier}">Level</label>
                        <input type="number" min="0" max="200" class="weapon-input" id="level-${rarity}-${tier}"
                               placeholder="0-200" value="0" oninput="handleWeaponLevelChange('${rarity}', '${tier}')">
                    </div>

                    <div class="weapon-stats">
                        <span class="weapon-inventory-display" id="inventory-display-${rarity}-${tier}">0.0% inventory attack</span>
                    </div>

                    <div class="weapon-upgrade-efficiency" id="upgrade-gain-container-${rarity}-${tier}">
                        <span class="weapon-efficiency-text" id="upgrade-gain-${rarity}-${tier}"></span>
                    </div>

                    <div class="weapon-equipped-display" id="equipped-display-${rarity}-${tier}" style="display:none;">
                        <span class="weapon-equipped-value" id="equipped-value-${rarity}-${tier}">0.0% equipped attack</span>
                    </div>
                </div>`;
            }
        });
    });

    weaponsGrid.innerHTML = html;
}

/**
 * Load weapons UI from saved state
 */
export function loadWeaponsUI(): void {
    const weapons = loadoutStore.getWeapons();
    Object.entries(weapons).forEach(([key, weapon]) => {
        const [rarity, tier] = key.split('-') as [WeaponRarity, WeaponTier];

        // Load level
        const levelInput = document.getElementById(`level-${rarity}-${tier}`) as HTMLInputElement;
        if (levelInput) {
            levelInput.value = weapon.level.toString();
        }

        // Load stars
        const starsInput = document.getElementById(`stars-${rarity}-${tier}`) as HTMLInputElement;
        if (starsInput) {
            starsInput.value = weapon.stars.toString();
            // Update star display
            for (let i = 1; i <= 5; i++) {
                const starElem = document.getElementById(`star-${rarity}-${tier}-${i}`);
                if (starElem) {
                    starElem.classList.toggle('active', i <= weapon.stars);
                }
            }
        }

        // Load equipped state
        if (weapon.equipped) {
            setEquippedState(rarity, tier);
        }

        // Update the display
        handleWeaponLevelChangeBulk(rarity, tier);
    });

    updateWeaponBonuses(false);
    updateWeaponUpgradeColors();
    updateEquippedWeaponIndicator();
}

/**
 * Attach event listeners for weapon UI elements
 */
export function attachWeaponEventListeners(): void {
    // Note: Level and star inputs are handled via oninput/onchange in HTML
    // No additional listeners needed here
    initializeWeaponMaxLevels();
}

/**
 * Initialize max level attributes for all weapons based on their current star rating
 */
function initializeWeaponMaxLevels(): void {
    rarities.forEach(rarity => {
        tiers.forEach(tier => {
            const starsInput = document.getElementById(`stars-${rarity}-${tier}`) as HTMLInputElement;
            const levelInput = document.getElementById(`level-${rarity}-${tier}`) as HTMLInputElement;

            if (starsInput && levelInput) {
                const stars: StarRating = (parseInt(starsInput.value) || 5) as StarRating;
                const maxLevel = getMaxLevelForStars(stars);
                levelInput.setAttribute('max', maxLevel.toString());
            }
        });
    });
}

// =======================
// Star Rating Handlers
// =======================

/**
 * Set weapon star rating
 * @param rarity - Weapon rarity
 * @param tier - Weapon tier
 * @param stars - Star rating to set (1-5)
 */
export function setWeaponStars(rarity: WeaponRarity, tier: WeaponTier, stars: StarRating): void {
    const starsInput = document.getElementById(`stars-${rarity}-${tier}`) as HTMLInputElement;
    if (!starsInput) return;

    // Toggle behavior: if clicking the same star, set to 0, otherwise set to clicked star
    const currentStars: StarRating = (parseInt(starsInput.value) || 0) as StarRating;
    const newStars: StarRating = (currentStars === stars) ? 0 : stars;
    starsInput.value = newStars.toString();

    // Update star display (1-5 stars)
    for (let i = 1; i <= 5; i++) {
        const starElem = document.getElementById(`star-${rarity}-${tier}-${i}`);
        if (starElem) {
            const isActive = i <= newStars;
            starElem.classList.toggle('active', isActive);

            // Add pop animation for newly active stars
            if (isActive && i > currentStars) {
                starElem.classList.remove('pop');
                void starElem.offsetWidth; // Trigger reflow
                starElem.classList.add('pop');
            }
        }
    }

    // Trigger level change to recalculate and enforce max level
    handleWeaponLevelChange(rarity, tier);

    // Save via loadout store (auto dual-writes)
    const key = `${rarity}-${tier}`;
    loadoutStore.updateWeapon(key, { stars: newStars });
}

/**
 * Preview star rating on hover
 * @param rarity - Weapon rarity
 * @param tier - Weapon tier
 * @param stars - Star rating to preview
 */
export function previewStars(rarity: WeaponRarity, tier: WeaponTier, stars: StarRating): void {
    // Temporarily show what the stars would look like if this star is clicked
    for (let i = 1; i <= 5; i++) {
        const starElem = document.getElementById(`star-${rarity}-${tier}-${i}`);
        if (starElem) {
            const shouldBeActive = i <= stars;
            starElem.style.opacity = shouldBeActive ? '1' : '0.25';
            starElem.style.filter = shouldBeActive ? 'grayscale(0)' : 'grayscale(0.7)';
            starElem.style.transform = shouldBeActive ? 'scale(1)' : 'scale(0.85)';
        }
    }
}

/**
 * Reset star preview on mouse leave
 * @param rarity - Weapon rarity
 * @param tier - Weapon tier
 */
export function resetStarPreview(rarity: WeaponRarity, tier: WeaponTier): void {
    // Reset stars to their actual stored value
    const starsInput = document.getElementById(`stars-${rarity}-${tier}`) as HTMLInputElement;
    if (!starsInput) return;

    const currentStars: StarRating = (parseInt(starsInput.value) || 0) as StarRating;
    for (let i = 1; i <= 5; i++) {
        const starElem = document.getElementById(`star-${rarity}-${tier}-${i}`);
        if (starElem) {
            // Remove inline styles and let CSS classes handle it
            starElem.style.opacity = '';
            starElem.style.filter = '';
            starElem.style.transform = '';
        }
    }
}

// =======================
// Weapon Level Handlers
// =======================

/**
 * Handle weapon level input change
 * @param rarity - Weapon rarity
 * @param tier - Weapon tier
 */
export function handleWeaponLevelChange(rarity: WeaponRarity, tier: WeaponTier): void {
    const levelInput = document.getElementById(`level-${rarity}-${tier}`) as HTMLInputElement;
    const starsInput = document.getElementById(`stars-${rarity}-${tier}`) as HTMLInputElement;

    if (!levelInput) return;

    const level = parseInt(levelInput.value) || 0;
    const stars: StarRating = (starsInput?.value !== undefined && starsInput?.value !== ''
        ? parseInt(starsInput.value)
        : 5) as StarRating;

    // Enforce max level based on stars
    const maxLevel = getMaxLevelForStars(stars);
    levelInput.setAttribute('max', maxLevel.toString());
    if (level > maxLevel) {
        levelInput.value = maxLevel.toString();
        return handleWeaponLevelChange(rarity, tier);
    }

    // Calculate inventory and equipped attack percentages
    const { inventoryAttack, equippedAttack } = calculateWeaponAttacks(rarity, tier, level);

    // Update inventory display
    const inventoryDisplay = document.getElementById(`inventory-display-${rarity}-${tier}`);
    if (inventoryDisplay) {
        inventoryDisplay.textContent = `${inventoryAttack.toFixed(1)}% inventory attack`;
    }

    // Show/hide upgrade gain display based on whether at max level
    const upgradeGainContainer = document.getElementById(`upgrade-gain-container-${rarity}-${tier}`);
    const upgradeGainDisplay = document.getElementById(`upgrade-gain-${rarity}-${tier}`);

    if (level < maxLevel && level > 0) {
        // Check if this weapon is equipped
        const equippedDisplay = document.getElementById(`equipped-display-${rarity}-${tier}`);
        const isEquipped = equippedDisplay && equippedDisplay.style.display !== 'none';

        // Calculate multi-level efficiency (what you actually get per 1k shards)
        const upgradeGain = calculateUpgradeGain(rarity, tier, level, stars, 1000, isEquipped);

        if (upgradeGainDisplay && upgradeGain.attackGain > 0) {
            let gainPer1k: number;
            let totalGainPer1k: number;

            if (upgradeGain.isUnaffordable) {
                // Next level costs more than 1k - normalize to per 1k
                gainPer1k = (upgradeGain.attackGain / upgradeGain.singleLevelCost) * 1000;
                const equippedGainPer1k = (upgradeGain.equippedAttackGain / upgradeGain.singleLevelCost) * 1000;
                totalGainPer1k = gainPer1k + equippedGainPer1k;

                if (isEquipped) {
                    upgradeGainDisplay.textContent = `+${totalGainPer1k.toFixed(2)}% per 1k shards (${gainPer1k.toFixed(2)}% inv + ${equippedGainPer1k.toFixed(2)}% eq, next level costs ${upgradeGain.singleLevelCost} shards)`;
                } else {
                    upgradeGainDisplay.textContent = `+${gainPer1k.toFixed(2)}% per 1k shards (next level costs ${upgradeGain.singleLevelCost} shards)`;
                }
            } else {
                // Can afford levels with 1k shards
                gainPer1k = upgradeGain.attackGain;
                totalGainPer1k = gainPer1k + upgradeGain.equippedAttackGain;

                if (isEquipped) {
                    upgradeGainDisplay.textContent = `+${totalGainPer1k.toFixed(2)}% per 1k shards (${gainPer1k.toFixed(2)}% inv + ${upgradeGain.equippedAttackGain.toFixed(2)}% eq, ${upgradeGain.levelsGained} levels)`;
                } else {
                    upgradeGainDisplay.textContent = `+${gainPer1k.toFixed(2)}% per 1k shards (${upgradeGain.levelsGained} levels)`;
                }
            }

            // Store totalGainPer1k for color coding (use total when equipped, otherwise just inventory)
            upgradeGainDisplay.dataset.gainPer1k = isEquipped ? totalGainPer1k.toString() : gainPer1k.toString();

            if (upgradeGainContainer) {
                upgradeGainContainer.classList.add('visible');
            }
        } else {
            // Hide if no gain or can't calculate
            if (upgradeGainContainer) {
                upgradeGainContainer.classList.remove('visible');
            }
        }
    } else {
        if (upgradeGainContainer) {
            upgradeGainContainer.classList.remove('visible');
        }
        if (upgradeGainDisplay) {
            delete upgradeGainDisplay.dataset.gainPer1k;
        }
    }

    // Update equipped display if this weapon is currently shown as equipped
    const equippedDisplay = document.getElementById(`equipped-display-${rarity}-${tier}`);
    if (equippedDisplay && equippedDisplay.style.display !== 'none') {
        const equippedValue = document.getElementById(`equipped-value-${rarity}-${tier}`);
        if (equippedValue) {
            equippedValue.textContent = `${equippedAttack.toFixed(1)}% equipped attack`;
        }
    }

    // Update totals and recalculate damage
    updateWeaponBonuses();
    updateEquippedWeaponIndicator();
    updateWeaponUpgradeColors();

    // Save via loadout store (auto dual-writes)
    const key = `${rarity}-${tier}`;
    loadoutStore.updateWeapon(key, { level });
}

/**
 * Bulk update version for loading - skips global updates to avoid cascading
 * Use this when loading multiple weapons at once, then call updateWeaponBonuses once after
 * @param rarity - Weapon rarity
 * @param tier - Weapon tier
 */
export function handleWeaponLevelChangeBulk(rarity: WeaponRarity, tier: WeaponTier): void {
    const levelInput = document.getElementById(`level-${rarity}-${tier}`) as HTMLInputElement;
    const starsInput = document.getElementById(`stars-${rarity}-${tier}`) as HTMLInputElement;

    if (!levelInput) return;

    const level = parseInt(levelInput.value) || 0;
    const stars: StarRating = (starsInput?.value !== undefined && starsInput?.value !== ''
        ? parseInt(starsInput.value)
        : 5) as StarRating;

    // Enforce max level based on stars
    const maxLevel = getMaxLevelForStars(stars);
    levelInput.setAttribute('max', maxLevel.toString());
    if (level > maxLevel) {
        levelInput.value = maxLevel.toString();
        return handleWeaponLevelChangeBulk(rarity, tier);
    }

    // Calculate inventory and equipped attack percentages
    const { inventoryAttack, equippedAttack } = calculateWeaponAttacks(rarity, tier, level);

    // Update inventory display
    const inventoryDisplay = document.getElementById(`inventory-display-${rarity}-${tier}`);
    if (inventoryDisplay) {
        inventoryDisplay.textContent = `${inventoryAttack.toFixed(1)}% inventory attack`;
    }

    // Show/hide upgrade gain display based on whether at max level
    const upgradeGainContainer = document.getElementById(`upgrade-gain-container-${rarity}-${tier}`);
    const upgradeGainDisplay = document.getElementById(`upgrade-gain-${rarity}-${tier}`);

    if (level < maxLevel && level > 0) {
        // Check if this weapon is equipped
        const equippedDisplay = document.getElementById(`equipped-display-${rarity}-${tier}`);
        const isEquipped = equippedDisplay && equippedDisplay.style.display !== 'none';

        // Calculate multi-level efficiency (what you actually get per 1k shards)
        const upgradeGain = calculateUpgradeGain(rarity, tier, level, stars, 1000, isEquipped);

        if (upgradeGainDisplay && upgradeGain.attackGain > 0) {
            let gainPer1k: number;
            let totalGainPer1k: number;

            if (upgradeGain.isUnaffordable) {
                // Next level costs more than 1k - normalize to per 1k
                gainPer1k = (upgradeGain.attackGain / upgradeGain.singleLevelCost) * 1000;
                const equippedGainPer1k = (upgradeGain.equippedAttackGain / upgradeGain.singleLevelCost) * 1000;
                totalGainPer1k = gainPer1k + equippedGainPer1k;

                if (isEquipped) {
                    upgradeGainDisplay.textContent = `+${totalGainPer1k.toFixed(2)}% per 1k shards (${gainPer1k.toFixed(2)}% inv + ${equippedGainPer1k.toFixed(2)}% eq, next level costs ${upgradeGain.singleLevelCost} shards)`;
                } else {
                    upgradeGainDisplay.textContent = `+${gainPer1k.toFixed(2)}% per 1k shards (next level costs ${upgradeGain.singleLevelCost} shards)`;
                }
            } else {
                // Can afford levels with 1k shards
                gainPer1k = upgradeGain.attackGain;
                totalGainPer1k = gainPer1k + upgradeGain.equippedAttackGain;

                if (isEquipped) {
                    upgradeGainDisplay.textContent = `+${totalGainPer1k.toFixed(2)}% per 1k shards (${gainPer1k.toFixed(2)}% inv + ${upgradeGain.equippedAttackGain.toFixed(2)}% eq, ${upgradeGain.levelsGained} levels)`;
                } else {
                    upgradeGainDisplay.textContent = `+${gainPer1k.toFixed(2)}% per 1k shards (${upgradeGain.levelsGained} levels)`;
                }
            }

            // Store totalGainPer1k for color coding (use total when equipped, otherwise just inventory)
            upgradeGainDisplay.dataset.gainPer1k = isEquipped ? totalGainPer1k.toString() : gainPer1k.toString();

            if (upgradeGainContainer) {
                upgradeGainContainer.classList.add('visible');
            }
        } else {
            // Hide if no gain or can't calculate
            if (upgradeGainContainer) {
                upgradeGainContainer.classList.remove('visible');
            }
        }
    } else {
        if (upgradeGainContainer) {
            upgradeGainContainer.classList.remove('visible');
        }
        if (upgradeGainDisplay) {
            delete upgradeGainDisplay.dataset.gainPer1k;
        }
    }

    // Update equipped display if this weapon is currently shown as equipped
    const equippedDisplay = document.getElementById(`equipped-display-${rarity}-${tier}`);
    if (equippedDisplay && equippedDisplay.style.display !== 'none') {
        const equippedValue = document.getElementById(`equipped-value-${rarity}-${tier}`);
        if (equippedValue) {
            equippedValue.textContent = `${equippedAttack.toFixed(1)}% equipped attack`;
        }
    }

    // NOTE: Does NOT call updateWeaponBonuses() to avoid cascading during bulk operations
}

// =======================
// Equipped Weapon Handlers
// =======================

/**
 * Refresh all equipped weapon UI states from the loadout store
 * This ensures UI is in sync with data state
 */
function refreshAllEquippedStates(): void {
    const weapons = loadoutStore.getWeapons();

    Object.entries(weapons).forEach(([key, weapon]) => {
        const [rarity, tier] = key.split('-') as [WeaponRarity, WeaponTier];
        const checkbox = document.getElementById(`equipped-checkbox-${rarity}-${tier}`) as HTMLInputElement;
        const equippedDisplay = document.getElementById(`equipped-display-${rarity}-${tier}`);
        const card = document.getElementById(`weapon-${rarity}-${tier}`);

        if (!checkbox) return;

        // Update checkbox state to match store
        checkbox.checked = weapon.equipped;

        // Update UI based on equipped state
        if (weapon.equipped) {
            const levelInput = document.getElementById(`level-${rarity}-${tier}`) as HTMLInputElement;
            const level = parseInt(levelInput?.value) || 0;
            const { equippedAttack } = calculateWeaponAttacks(rarity, tier, level);

            const equippedValue = document.getElementById(`equipped-value-${rarity}-${tier}`);
            if (equippedValue) {
                equippedValue.textContent = `${equippedAttack.toFixed(1)}% equipped attack`;
            }

            if (equippedDisplay) equippedDisplay.style.display = 'block';
            if (card) card.classList.add('equipped');
        } else {
            if (equippedDisplay) equippedDisplay.style.display = 'none';
            if (card) card.classList.remove('equipped');
        }
    });
}

/**
 * Handle equipped checkbox change
 * @param rarity - Weapon rarity
 * @param tier - Weapon tier
 */
export function handleEquippedCheckboxChange(rarity: WeaponRarity, tier: WeaponTier): void {
    const checkbox = document.getElementById(`equipped-checkbox-${rarity}-${tier}`) as HTMLInputElement;
    if (!checkbox) return;

    const key = `${rarity}-${tier}`;

    if (checkbox.checked) {
        // When equipping a weapon, unequip all others via the store
        const weapons = loadoutStore.getWeapons();
        Object.entries(weapons).forEach(([otherKey, otherWeapon]) => {
            if (otherKey !== key && otherWeapon.equipped) {
                loadoutStore.updateWeapon(otherKey, { equipped: false });
            }
        });

        // Equip the selected weapon
        loadoutStore.updateWeapon(key, { equipped: true });
    } else {
        // Unequip the selected weapon
        loadoutStore.updateWeapon(key, { equipped: false });
    }

    // Refresh all equipped UI states from the updated store
    refreshAllEquippedStates();

    updateWeaponBonuses();
    updateEquippedWeaponIndicator();
}

/**
 * Bulk update version for loading - skips save and global updates to avoid cascading
 * Use this when loading equipped state, then call updateWeaponBonuses once after
 * @param rarity - Weapon rarity
 * @param tier - Weapon tier
 */
export function setEquippedState(rarity: WeaponRarity, tier: WeaponTier): void {
    const checkbox = document.getElementById(`equipped-checkbox-${rarity}-${tier}`) as HTMLInputElement;
    const equippedDisplay = document.getElementById(`equipped-display-${rarity}-${tier}`);
    const card = document.getElementById(`weapon-${rarity}-${tier}`);

    if (!checkbox) return;

    checkbox.checked = true;
    // Uncheck all other equipped checkboxes
    rarities.forEach(r => {
        tiers.forEach(t => {
            if (r !== rarity || t !== tier) {
                const otherCheckbox = document.getElementById(`equipped-checkbox-${r}-${t}`) as HTMLInputElement;
                const otherDisplay = document.getElementById(`equipped-display-${r}-${t}`);
                const otherCard = document.getElementById(`weapon-${r}-${t}`);

                if (otherCheckbox) otherCheckbox.checked = false;
                if (otherDisplay) otherDisplay.style.display = 'none';
                if (otherCard) otherCard.classList.remove('equipped');
            }
        });
    });

    // Calculate and display equipped attack
    const levelInput = document.getElementById(`level-${rarity}-${tier}`) as HTMLInputElement;
    const level = parseInt(levelInput?.value) || 0;
    const { equippedAttack } = calculateWeaponAttacks(rarity, tier, level);

    const equippedValue = document.getElementById(`equipped-value-${rarity}-${tier}`);
    if (equippedValue) {
        equippedValue.textContent = `${equippedAttack.toFixed(1)}% equipped attack`;
    }

    if (equippedDisplay) equippedDisplay.style.display = 'block';
    if (card) card.classList.add('equipped');
}

/**
 * Update the equipped weapon indicator
 */
export function updateEquippedWeaponIndicator(): void {
    // Check if any weapon is equipped
    let hasEquipped = false;

    rarities.forEach(rarity => {
        tiers.forEach(tier => {
            const equippedDisplay = document.getElementById(`equipped-display-${rarity}-${tier}`);
            if (equippedDisplay && equippedDisplay.style.display !== 'none') {
                hasEquipped = true;
            }
        });
    });

    // Show/hide the indicator
    const indicator = document.getElementById('no-weapon-equipped-indicator');
    if (indicator) {
        indicator.style.display = hasEquipped ? 'none' : 'block';
    }
}

// =======================
// Weapon Bonus Calculations
// =======================

/**
 * Update weapon bonus displays and recalculate damage
 */
export function updateWeaponBonuses(calculateDamage: boolean = true): void {
    let totalInventory = 0;
    let equippedBonus = 0;

    rarities.forEach(rarity => {
        tiers.forEach(tier => {
            const levelInput = document.getElementById(`level-${rarity}-${tier}`) as HTMLInputElement;
            const equippedDisplay = document.getElementById(`equipped-display-${rarity}-${tier}`);

            if (levelInput) {
                const level = parseInt(levelInput.value) || 0;
                const { inventoryAttack, equippedAttack } = calculateWeaponAttacks(rarity, tier, level);

                totalInventory += inventoryAttack;

                // Check if equipped based on display visibility
                if (equippedDisplay && equippedDisplay.style.display !== 'none') {
                    equippedBonus = equippedAttack;
                }
            }
        });
    });

    const totalInventoryEl = document.getElementById('total-inventory-attack');
    const equippedEl = document.getElementById('equipped-weapon-attack-pct');
    const totalEl = document.getElementById('total-weapon-attack');

    if (totalInventoryEl) totalInventoryEl.textContent = totalInventory.toFixed(1) + '%';
    if (equippedEl) equippedEl.textContent = equippedBonus.toFixed(1) + '%';
    if (totalEl) totalEl.textContent = (totalInventory + equippedBonus).toFixed(1) + '%';

    // Persist weapon attack bonus to loadout store
    loadoutStore.updateWeaponAttackBonus({
        totalAttack: totalInventory + equippedBonus,
        equippedAttack: equippedBonus
    });

    // Recalculate damage
    if(calculateDamage)
    {
       // calculate();
    }

    // Update upgrade priority chain
    updateUpgradePriorityChain();
}

// =======================
// Tab Switching
// =======================

/**
 * Switch weapon levels sub-tabs
 * @param tabName - Name of the tab to switch to
 */
export function switchWeaponLevelsTab(tabName: string): void {
    const allSubTabContent = document.querySelectorAll('.weapon-levels-subtab');
    const allSubTabButtons = document.querySelectorAll('#weapon-levels-subtab-button');

    // Hide all subtabs
    allSubTabContent.forEach(tab => {
        tab.classList.remove('active');
        (tab as HTMLElement).style.display = 'none';
    });

    // Remove active from all buttons
    allSubTabButtons.forEach(btn => {
        btn.classList.remove('active');
    });

    // Show selected subtab
    const selectedTab = document.getElementById(`weapon-levels-${tabName}`);
    if (selectedTab) {
        selectedTab.classList.add('active');
        (selectedTab as HTMLElement).style.display = 'block';
    }

    // Activate button - Find the button by matching the onclick attribute
    allSubTabButtons.forEach(btn => {
        const onclickAttr = btn.getAttribute('onclick');
        if (onclickAttr && onclickAttr.includes(tabName)) {
            btn.classList.add('active');
        }
    });

    // Calculate upgrade priority when switching to the priority tab
    if (tabName === 'upgrade-priority') {
        setTimeout(() => {
            updateUpgradePriorityChain();
        }, 100);
    }
}
