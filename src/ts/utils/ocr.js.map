{
  "version": 3,
  "sources": ["ocr.ts"],
  "sourcesContent": ["export function preprocessImage(imageURL: string, applyGrayscale = false, applySharpen = false, applyThreshold = false): Promise<string> {\n    return new Promise((resolve) => {\n        const img = new Image();\n        img.src = imageURL;\n        img.onload = () => {\n            const canvas = document.createElement('canvas');\n            const ctx = canvas.getContext('2d');\n\n            canvas.width = img.width * 3;\n            canvas.height = img.height * 2;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n\n            // Get image data\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n            const data = imageData.data;\n            const contrast = 1.0; // tweak 1.2\u20131.6\n            const intercept = 128 * (1 - contrast);\n\n\n            for (let i = 0; i < data.length; i += 4) {\n                const r = data[i];\n                const g = data[i + 1];\n                const b = data[i + 2];\n\n                const avg = (r + g + b) / 3;\n\n                // Detect light gray icons\n                if (avg > 180) {\n                    data[i] = data[i + 1] = data[i + 2] = 255;\n                }\n            }\n\n            ctx.putImageData(imageData, 0, 0);\n\n            if (applyGrayscale) {\n                // Convert to grayscale and apply contrast stretching\n                for (let i = 0; i < data.length; i += 4) {\n                    const r = data[i];\n                    const g = data[i + 1];\n                    const b = data[i + 2];\n\n                    // grayscale\n                    let gray = 0.299 * r + 0.587 * g + 0.114 * b;\n\n                    // contrast\n                    gray = gray * contrast + intercept;\n\n                    data[i] = data[i + 1] = data[i + 2] = gray;\n                }\n                ctx.putImageData(imageData, 0, 0);\n            }\n\n            if (applySharpen) {\n                // Apply sharpening\n                const sharpenKernel = [\n                    0, -1, 0,\n                    -1, 5, -1,\n                    0, -1, 0\n                ];\n                const sharpenedData = applyConvolution(imageData, sharpenKernel, canvas.width, canvas.height);\n                ctx.putImageData(sharpenedData, 0, 0);\n            }\n\n            if (applyThreshold) {\n                // Apply thresholding\n                const threshold = 230;\n                const thresholdedData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                const thresholdedPixels = thresholdedData.data;\n                for (let i = 0; i < thresholdedPixels.length; i += 4) {\n                    const value = thresholdedPixels[i] > threshold ? 255 : 0;\n                    thresholdedPixels[i] = thresholdedPixels[i + 1] = thresholdedPixels[i + 2] = value; // Binarize\n                }\n                ctx.putImageData(thresholdedData, 0, 0);\n\n            }\n            resolve(canvas.toDataURL());\n        };\n    });\n}\n\nexport async function extractText(imageURL: string, debug = false): Promise<string | undefined> {\n    const preprocessedImageURL = await preprocessImage(imageURL, true, true, true);\n    const output = document.getElementById('debug-ocr');\n\n    if (debug) {\n        const originalLabel = document.createElement('div');\n        originalLabel.innerHTML = `<strong>Original Image:</strong>`;\n        output.appendChild(originalLabel);\n\n        const originalImgElement = document.createElement('img');\n        originalImgElement.src = imageURL;\n        originalImgElement.style = 'max-width: 100%; margin-bottom: 10px;';\n        output.appendChild(originalImgElement);\n\n        const preprocessedLabel = document.createElement('div');\n        preprocessedLabel.innerHTML = `<strong>Preprocessed Image:</strong>`;\n        output.appendChild(preprocessedLabel);\n\n        const preprocessedImgElement = document.createElement('img');\n        preprocessedImgElement.src = preprocessedImageURL;\n        preprocessedImgElement.style = 'max-width: 100%; margin-bottom: 10px;';\n        output.appendChild(preprocessedImgElement);\n    }\n\n    try {\n        // @ts-ignore - Tesseract is loaded via CDN\n        const worker = await (window as any).Tesseract.createWorker('eng');\n\n        worker.setParameters({\n            tessedit_pageseg_mode: 6,\n        })\n        const { data: { text } } = await worker.recognize(preprocessedImageURL);\n\n        if (debug) {\n            // Display the extracted text with a label\n            const extractedTextLabel = document.createElement('div');\n            extractedTextLabel.innerHTML = `<strong>Extracted Text:</strong>`;\n            output.appendChild(extractedTextLabel);\n\n            const extractedTextElement = document.createElement('div');\n            extractedTextElement.textContent = text;\n            output.appendChild(extractedTextElement);\n        }\n        return text;\n    } catch (error) {\n        console.error(error)\n    } finally {\n        URL.revokeObjectURL(imageURL); // Clean up object URL\n    }\n}\n\nfunction applyConvolution(imageData, kernel, width, height) {\n    const src = imageData.data;\n    const output = new Uint8ClampedArray(src.length);\n    const side = Math.round(Math.sqrt(kernel.length));\n    const halfSide = Math.floor(side / 2);\n\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const dstOffset = (y * width + x) * 4;\n            let r = 0, g = 0, b = 0;\n\n            for (let ky = 0; ky < side; ky++) {\n                for (let kx = 0; kx < side; kx++) {\n                    const scy = Math.min(height - 1, Math.max(0, y + ky - halfSide));\n                    const scx = Math.min(width - 1, Math.max(0, x + kx - halfSide));\n                    const srcOffset = (scy * width + scx) * 4;\n                    const weight = kernel[ky * side + kx];\n                    r += src[srcOffset] * weight;\n                    g += src[srcOffset + 1] * weight;\n                    b += src[srcOffset + 2] * weight;\n                }\n            }\n\n            output[dstOffset] = Math.min(255, Math.max(0, r));\n            output[dstOffset + 1] = Math.min(255, Math.max(0, g));\n            output[dstOffset + 2] = Math.min(255, Math.max(0, b));\n            output[dstOffset + 3] = src[dstOffset + 3]; // Preserve alpha\n        }\n    }\n\n    const result = new ImageData(output, width, height);\n    return result;\n}\n\nexport function parseBaseStatText(text: string): [string, string][] {\n    const displayNamesToInput = {\n        \"Attack\": \"attack\",\n        \"Defense\": \"defense\",\n        \"Critical Rate\": \"critRate\",\n        \"Critical Damage\": \"critDamage\",\n        \"Attack Speed\": \"attackSpeed\",\n        \"STR\": \"str\",\n        \"DEX\": \"dex\",\n        \"LUK\": \"luk\",\n        \"INT\": \"int\",\n        \"Stat Prop. Damage\": \"statDamage\",\n        \"Damage\": \"damage\",\n        \"Damage Amplification\": \"damageAmp\",\n        \"Defense Penetration\": \"defPen\",\n        \"Boss Monster Damage\": \"bossDamage\",\n        \"Normal Monster Damage\": \"normalDamage\",\n        \"Min Damage Multiplier\": \"minDamage\", // sometimes broken due to multi line\n        \"Max Damage Multiplier\": \"maxDamage\",\n        \"1st Job Skill Lv.\": \"skillLevel1st\",\n        \"2nd Job Skill Lv.\": \"skillLevel2nd\",\n        \"3rd Job Skill Lv.\": \"skillLevel3rd\",\n        \"4th Job Skill Lv.\": \"skillLevel4th\",\n        \"All Skill Levels\": \"skillLevelAll\",\n        \"Final Damage\": \"finalDamage\",\n    }\n\n    const cleanData = text.split(\"\\n\")\n        .map(x => x.trim())\n        .map(x => x.split(\" i \").join(\" \")) // information hover icon - replaceAll polyfill\n        .map(x => x.split(\" ; \").join(\" \")) // information hover icon - replaceAll polyfill\n        .filter((x, idx) => !(idx === 0 && !/\\d/.test(x)))\n        .filter(x => x)\n        .map((x) => { // split into [stat, value]\n            if (/^\\d/.test(x)) { // starts with digit, i.e: 1st Job Skill\n                const matches = x.match(/^(\\d\\D*)(.*)$/);\n                return [matches[1].trim(), matches[2].trim()];\n            }\n\n            const matches = x.match(/^(\\D*)(.*)$/);\n            return [matches[1].trim(), matches[2].trim()]\n        })\n        // for the case where OCR detects multiline stat names incorrectly\n        // i.e:\n        // Min Damage 147%\n        // Multiplier\n        .reduce((acc: [string, string][], [label, value]: [string, string]) => {\n            if (value === \"\") {\n                // merge label into previous element\n                if (acc.length > 1) {\n                    const prev = acc[acc.length - 1];\n                    prev[0] += ` ${label}`;\n                }\n            } else {\n                acc.push([label, value]);\n            }\n            return acc;\n        }, [])\n        .map(x => {\n            let value = x[1]\n            if (value.includes(\"M\") && value.includes(\"K\")) {\n                value = value\n                    .split(/\\s+/)\n                    .reduce((sum, part) => {\n                        const value = parseFloat(part);\n                        if (part.endsWith(\"M\")) return sum + value * 1_000_000;\n                        if (part.endsWith(\"K\")) return sum + value * 1_000;\n                        return sum;\n                    }, 0)\n                    .toString();\n            }\n            else {\n                value = value.split(\",\").join(\"\").split(\"%\").join(\"\")\n            }\n            return [x[0], value]\n        })\n\n    let matchedData: [string, string][] = cleanData.flatMap(x => {\n        const displayName = x[0];\n        const value = x[1];\n\n        // search for longer key match first. i.e: match priority 'Damage Amp' over 'Damage'\n        for (const displayNameKey of Object.keys(displayNamesToInput).sort((a, b) => b.length - a.length)) {\n            if (displayName.startsWith(displayNameKey)) {\n                return [[displayNamesToInput[displayNameKey], value]];\n            }\n        }\n\n        return [];\n    })\n    \n    return matchedData;\n}\n"],
  "mappings": "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",
  "names": ["matches", "value"]
}
